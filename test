-- BUBBLEGUM SIMULATOR - AUTO HATCH & SECRET NOTIFIER
-- Version 2.0 with auto hatch and Discord notifications

local P = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local VIM = game:GetService("VirtualInputManager")
local HttpService = game:GetService("HttpService")
local p = P.LocalPlayer

-- Detection Settings (MUST be defined before print statements)
local DETECT_LEGENDARIES = false -- Set to true to also detect Legendary pets (for testing)

-- Special Pets (pets that should receive special notifications)
-- Add pet names here (case insensitive, supports spaces)
local SPECIAL_PETS = {
    "Morning Star",
    "Christmas Robot",
    "The Leviathan",
    "Sylently's Pet"
    -- Add more pet names here as needed
}

-- Pre-compute lowercase special pets for faster lookup (optimization)
local SPECIAL_PETS_LOWER = {}
for _, petName in ipairs(SPECIAL_PETS) do
    SPECIAL_PETS_LOWER[string.lower(petName)] = true
end

print("========================================")
print("BUBBLEGUM AUTO HATCH & NOTIFIER")
print("Version: 2.0")
print("DETECT_LEGENDARIES: " .. tostring(DETECT_LEGENDARIES))
print("========================================")

-- Load required modules
local Remote = nil
local ItemUtil = nil
local PetsData = nil
local PetUtil = nil
local FormatCommas = nil

-- Settings
local autoHatchEnabled = false
local webhookURL = ""
local discordUserID = ""

-- Settings file path
local SETTINGS_FILE = "bubblegum_settings.json"

-- Load settings from file (non-blocking, won't break if it fails)
local function loadSettings()
    if not readfile or not isfile or not HttpService then
        return -- File system not available, use defaults
    end
    
    local success, result = pcall(function()
        if isfile(SETTINGS_FILE) then
            local content = readfile(SETTINGS_FILE)
            if content and content ~= "" then
                local decoded = HttpService:JSONDecode(content)
                if decoded and type(decoded) == "table" then
                    if decoded.webhookURL and type(decoded.webhookURL) == "string" then
                        webhookURL = decoded.webhookURL
                    end
                    if decoded.discordUserID and type(decoded.discordUserID) == "string" then
                        discordUserID = decoded.discordUserID
                    end
                    print("‚úì Settings loaded from file")
                    return true
                end
            end
        end
        return false
    end)
    
    if not success then
        -- Silently fail, use defaults
    end
end

-- Save settings to file (non-blocking, won't break if it fails)
local function saveSettings()
    if not writefile or not HttpService then
        return -- File system not available, skip saving
    end
    
    pcall(function()
        local settings = {
            webhookURL = webhookURL or "",
            discordUserID = discordUserID or ""
        }
        local json = HttpService:JSONEncode(settings)
        writefile(SETTINGS_FILE, json)
        print("‚úì Settings saved")
    end)
end

-- Webhook queue for rate limiting
local webhookQueue = {}
local isSendingWebhook = false
local messagesRemainingWithDelay = 0 -- Counter for messages that need 2s delay after rate limit

-- Script state
local scriptActive = true
local hatchEventConnection = nil

-- Load modules
local function loadModules()
    -- Load Remote
    local success, remoteModule = pcall(function()
        return require(RS.Shared.Framework.Network.Remote)
    end)
    if success and remoteModule then
        Remote = remoteModule
        print("‚úì Loaded Remote module")
    end
    
    -- Load ItemUtil
    local success2, itemUtil = pcall(function()
        return require(RS.Shared.Utils.Stats.ItemUtil)
    end)
    if success2 and itemUtil then
        ItemUtil = itemUtil
        print("‚úì Loaded ItemUtil")
    end
    
    -- Load Pets data for images
    local success3, petsData = pcall(function()
        return require(RS.Shared.Data.Pets)
    end)
    if success3 and petsData then
        PetsData = petsData
        print("‚úì Loaded Pets data")
    end
    
    -- Load PetUtil for chance calculation
    local success4, petUtil = pcall(function()
        return require(RS.Shared.Utils.Stats.PetUtil)
    end)
    if success4 and petUtil then
        PetUtil = petUtil
        print("‚úì Loaded PetUtil")
    end
    
    -- Load FormatCommas for number formatting
    local success5, formatCommas = pcall(function()
        return require(RS.Shared.Framework.Utilities.String.FormatCommas)
    end)
    if success5 and formatCommas then
        FormatCommas = formatCommas
        print("‚úì Loaded FormatCommas")
    end
end

loadModules()

-- Load saved settings (before GUI creation, non-blocking)
loadSettings()

-- HTTP for Delta Mobile (using the working method from testing)
local httpLib = nil
local httpLibName = nil
if request then
    httpLib = function(url, method, headers, body)
        local success, res, err = pcall(function()
            return request({Url=url, Method=method, Headers=headers or {}, Body=body})
        end)
        if success and res then
            local status = res.StatusCode or (res.Success and 200 or (res.success and 200 or 0))
            local body = res.Body or res.body or ""
            local ok = res.Success or res.success or status == 200 or status == 204
            return ok, body, status
        end
        return false, err or "Request exception", 0
    end
    httpLibName = "request"
end

-- Function to get Discord-compatible thumbnail URL from Roblox asset ID
local function getThumbnailUrl(assetId)
    if not assetId then
        return nil
    end
    
    local url = "https://thumbnails.roproxy.com/v1/assets?assetIds=" .. assetId .. "&size=420x420&format=Png&isCircular=false"
    
    local success, response, errorMsg = pcall(function()
        -- Try httpLib first (we know this works for webhooks)
        if httpLib then
            local ok, body, status = httpLib(url, "GET", {}, "")
            if ok and status == 200 then
                return body, nil
            else
                return nil, "httpLib returned status " .. tostring(status)
            end
        elseif HttpService and HttpService.GetAsync then
            return HttpService:GetAsync(url), nil
        else
            return nil, "No HTTP method available"
        end
    end)
    
    if not success then
        return nil
    end
    
    if not response then
        return nil
    end
    
    -- Try to decode JSON
    local success2, decoded = pcall(function()
        if HttpService and HttpService.JSONDecode then
            return HttpService:JSONDecode(response)
        end
        return nil
    end)
    
    if not success2 then
        return nil
    end
    
    if decoded and decoded.data and decoded.data[1] and decoded.data[1].imageUrl then
        return decoded.data[1].imageUrl
    end
    
    return nil
end

-- JSON encoder (properly handles nested structures)
local function jsonEncode(t)
    local function encodeValue(v, depth)
        depth = depth or 0
        if depth > 10 then return "null" end -- Prevent infinite recursion
        
        if type(v) == "string" then
            -- Escape special characters
            v = v:gsub("\\", "\\\\")
            v = v:gsub('"', '\\"')
            v = v:gsub("\n", "\\n")
            v = v:gsub("\r", "\\r")
            v = v:gsub("\t", "\\t")
            return '"' .. v .. '"'
        elseif type(v) == "number" then
            return tostring(v)
        elseif type(v) == "boolean" then
            return v and "true" or "false"
        elseif type(v) == "table" then
            -- Check if it's an array
            local isArray = false
            local maxIndex = 0
            for k in pairs(v) do
                if type(k) == "number" then
                    maxIndex = math.max(maxIndex, k)
                end
            end
            isArray = maxIndex > 0 and maxIndex == #v
            
            local parts = {}
            if isArray then
                for i = 1, maxIndex do
                    table.insert(parts, encodeValue(v[i], depth + 1))
                end
                return "[" .. table.concat(parts, ",") .. "]"
            else
                for k, val in pairs(v) do
                    if val ~= nil then
                        local key = type(k) == "string" and ('"' .. k .. '"') or tostring(k)
                        table.insert(parts, key .. ":" .. encodeValue(val, depth + 1))
                    end
                end
                return "{" .. table.concat(parts, ",") .. "}"
            end
        else
            return "null"
        end
    end
    return encodeValue(t, 0)
end

-- Helper function to check if a pet is in the special pets list (case insensitive)
-- Optimized: uses pre-computed lowercase lookup table
local function isSpecialPet(petName)
    if not petName then return false end
    return SPECIAL_PETS_LOWER[string.lower(petName)] == true
end

-- Helper function to check if rarity is Infinity (case insensitive)
local function isInfinityRarity(rarity)
    if not rarity then return false end
    return string.lower(tostring(rarity)) == "infinity"
end

-- Function to send debug webhook (no ping, plain text)
local function sendDebugWebhook(message)
    if not httpLib or webhookURL == "" then 
        return true
    end
    
    local embed = {
        title = "üîç Debug Info",
        description = message,
        color = 8421504, -- Grey color for debug
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    local payload = {
        embeds = {embed}
        -- No content field = no ping
    }
    
    local jsonPayload = jsonEncode(payload)
    
    local success, response, status = pcall(function()
        return httpLib(webhookURL, "POST", {
            ["Content-Type"] = "application/json"
        }, jsonPayload)
    end)
    
    if success and status == 200 then
        print("‚úì Debug webhook sent successfully")
        return true
    elseif success and status == 429 then
        print("‚úó Debug webhook rate limited (429)")
        return false -- Return false to trigger retry
    else
        print("‚úó Debug webhook failed: status=" .. tostring(status))
        return true -- Return true for other errors to not retry
    end
end

-- Function to send special webhook (with infinity colors and message)
local function sendSpecialDiscordNotificationInternal(petName, shiny, mythic, eggName, rarity, pet, petImageUrl, isInfinity)
    if not httpLib or webhookURL == "" then 
        print("‚úó Cannot send: httpLib=" .. tostring(httpLib) .. ", webhookURL=" .. tostring(webhookURL))
        return true
    end
    
    -- Get player name
    local playerName = p.Name or "Unknown Player"
    
    -- Build pet name with prefix
    local fullPetName = petName
    if shiny == true and mythic == true then
        fullPetName = "Shiny Mythic " .. petName
    elseif shiny == true then
        fullPetName = "Shiny " .. petName
    elseif mythic == true then
        fullPetName = "Mythic " .. petName
    end
    
    -- Determine color based on pet type (neon colors for special pets)
    local embedColor = 65535 -- Bright neon blue/cyan for normal special pets
    if shiny == true and mythic == true then
        embedColor = 65280 -- Neon green for Shiny Mythic special pets
    elseif shiny == true then
        embedColor = 16753920 -- Neon orange for Shiny special pets
    elseif mythic == true then
        embedColor = 16711935 -- Neon pink for Mythic special pets
    else
        embedColor = 65535 -- Bright neon blue/cyan for normal special pets
    end
    
    -- Build mention (for Discord ping)
    local mention = discordUserID ~= "" and ("<@" .. discordUserID .. ">") or ""
    
    -- Calculate probability if PetUtil is available
    local probabilityText = nil
    if PetUtil and pet then
        local success, petChance = pcall(function()
            return PetUtil:GetChance(pet)
        end)
        if success and petChance and petChance > 0 then
            local denominator = math.ceil(100 / petChance)
            if FormatCommas then
                probabilityText = "1/" .. FormatCommas(denominator)
            else
                local formatted = tostring(denominator)
                formatted = formatted:reverse():gsub("(%d%d%d)", "%1,"):reverse()
                formatted = formatted:gsub("^,", "")
                probabilityText = "1/" .. formatted
            end
        end
    end
    
    -- Determine "a" or "an" for the pet name
    local article = "a"
    if not shiny and not mythic and petName then
        local firstLetter = string.lower(string.sub(petName, 1, 1))
        if firstLetter == "a" or firstLetter == "e" or firstLetter == "i" or firstLetter == "o" or firstLetter == "u" then
            article = "an"
        end
    end
    
    -- Build description (infinity message is now in title)
    local description = "**" .. playerName .. "** hatched " .. article .. " **" .. fullPetName .. "**!"
    
    -- Build fields
    local fields = {
        {
            name = "Hatched",
            value = fullPetName,
            inline = false
        }
    }
    
    -- Add probability or rarity field
    if probabilityText then
        table.insert(fields, {
            name = "Rarity",
            value = probabilityText,
            inline = true
        })
    elseif rarity then
        table.insert(fields, {
            name = "Rarity",
            value = rarity,
            inline = true
        })
    end
    
    -- Build embed
    local embed = {
        title = "üéâ Congratulations! You hatched an ***INFINITY***! üéâ",
        description = description,
        color = embedColor,
        fields = fields,
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    -- Add thumbnail if pet image URL is available
    if petImageUrl then
        embed.thumbnail = {
            url = petImageUrl
        }
    end
    
    -- Build payload
    local payload = {
        content = mention, -- Ping in content field
        embeds = {embed}
    }
    
    local jsonPayload = jsonEncode(payload)
    
    local success, response, status = pcall(function()
        return httpLib(webhookURL, "POST", {
            ["Content-Type"] = "application/json"
        }, jsonPayload)
    end)
    
    if success and status == 200 then
        print("‚úì Special Discord notification sent successfully")
        return true
    elseif success and status == 429 then
        print("‚úó Special Discord notification rate limited (429)")
        return false -- Return false to trigger retry
    else
        print("‚úó Special Discord notification failed: status=" .. tostring(status))
        return true -- Return true for other errors to not retry
    end
end

-- Function to send webhook (with 429 retry logic) - MUST be defined first
local function sendDiscordNotificationInternal(petName, shiny, mythic, eggName, rarity, pet, petImageUrl)
    if not httpLib or webhookURL == "" then 
        print("‚úó Cannot send: httpLib=" .. tostring(httpLib) .. ", webhookURL=" .. tostring(webhookURL))
        return true -- Return true to not retry if webhook not configured
    end
    
    -- Get player name
    local playerName = p.Name or "Unknown Player"
    
    -- Build pet name with prefix
    local fullPetName = petName
    if shiny == true and mythic == true then
        fullPetName = "Shiny Mythic " .. petName
    elseif shiny == true then
        fullPetName = "Shiny " .. petName
    elseif mythic == true then
        fullPetName = "Mythic " .. petName
    end
    
    -- Determine color based on pet type
    local embedColor = 9807270 -- Grey for normal pets (default)
    if shiny == true and mythic == true then
        embedColor = 16711680 -- Bright red for Shiny Mythic
    elseif shiny == true then
        embedColor = 16766720 -- Gold/yellow-orange for Shiny
    elseif mythic == true then
        embedColor = 10181046 -- Purple-pink for Mythic
    else
        -- Not shiny or mythic - always grey regardless of rarity
        embedColor = 9807270 -- Grey
    end
    
    -- Build mention (for Discord ping)
    local mention = discordUserID ~= "" and ("<@" .. discordUserID .. ">") or ""
    
    -- Calculate probability if PetUtil is available
    local probabilityText = nil
    if PetUtil and pet then
        local success, petChance = pcall(function()
            return PetUtil:GetChance(pet)
        end)
        if success and petChance and petChance > 0 then
            local denominator = math.ceil(100 / petChance)
            if FormatCommas then
                probabilityText = "1/" .. FormatCommas(denominator)
            else
                -- Manual formatting for large numbers
                local formatted = tostring(denominator)
                -- Add commas every 3 digits from right
                formatted = formatted:reverse():gsub("(%d%d%d)", "%1,"):reverse()
                formatted = formatted:gsub("^,", "")
                probabilityText = "1/" .. formatted
            end
        end
    end
    
    -- Determine "a" or "an" for the pet name
    -- Use "a" if shiny/mythic/shiny mythic (regardless of vowel)
    -- Use "an" if pet name starts with a vowel AND is not shiny/mythic
    -- Use "a" if pet name starts with a consonant
    local article = "a"
    if not shiny and not mythic and petName then
        local firstLetter = string.lower(string.sub(petName, 1, 1))
        if firstLetter == "a" or firstLetter == "e" or firstLetter == "i" or firstLetter == "o" or firstLetter == "u" then
            article = "an"
        end
    end
    
    -- Build description
    local description = "**" .. playerName .. "** hatched " .. article .. " **" .. fullPetName .. "**!"
    
    -- Build fields (remove Egg, conditionally include Rarity/Probability)
    local fields = {
        {
            name = "Hatched",
            value = fullPetName,
            inline = false
        }
    }
    
    -- Add probability or rarity field
    if probabilityText then
        table.insert(fields, {
            name = "Rarity",
            value = probabilityText,
            inline = true
        })
    elseif rarity then
        table.insert(fields, {
            name = "Rarity",
            value = rarity,
            inline = true
        })
    end
    
    -- Build embed (always use full format, no simplification)
    local embed = {
        title = "üéâ Congratulations!",
        description = description,
        color = embedColor,
        fields = fields,
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    -- Add thumbnail if pet image URL is available
    if petImageUrl then
        embed.thumbnail = {
            url = petImageUrl
        }
    end
    
    -- Put mention in content field (required for Discord to actually ping)
    local payload = {
        content = mention ~= "" and mention or nil,
        embeds = {embed}
    }
    
    local headers = {["Content-Type"] = "application/json"}
    local json = jsonEncode(payload)
    local success, response, status = httpLib(webhookURL, "POST", headers, json)
    
    if success and (status == 200 or status == 204) then
        print("‚úì Discord notification sent! Status: " .. tostring(status))
        return true
    elseif status == 429 then
        -- Rate limited - return false to trigger retry
        print("‚úó Rate limited (429), will retry...")
        return false
    else
        print("‚úó Webhook failed!")
        print("  Status: " .. tostring(status))
        print("  Response: " .. tostring(response))
        -- For non-429 errors, return true to not retry (400 is likely permanent issue)
        return true
    end
end

-- Process webhook queue
local function processWebhookQueue()
    if isSendingWebhook or #webhookQueue == 0 or not scriptActive then
        return
    end
    
    isSendingWebhook = true
    
    spawn(function()
        while #webhookQueue > 0 and scriptActive do
            local webhookData = table.remove(webhookQueue, 1)
            
            -- Check if this is a debug message
            if webhookData.isDebug and webhookData.debugMessage then
                -- Processing debug webhook
                
                local maxRetries = 5
                local retryCount = 0
                local success = false
                
                while retryCount < maxRetries and not success do
                    success = sendDebugWebhook(webhookData.debugMessage)
                    
                    if not success then
                        retryCount = retryCount + 1
                        if retryCount < maxRetries then
                            print("Rate limited, waiting 1 second before retry " .. retryCount .. "/" .. maxRetries)
                            task.wait(1)
                        end
                    end
                end
                
                -- If still failed after max retries, add back to front of queue and increase delay
                if not success then
                    print("‚úó Debug webhook failed after " .. maxRetries .. " retries, re-queuing to front")
                    table.insert(webhookQueue, 1, webhookData)
                    messagesRemainingWithDelay = 5 -- Set delay for next 5 messages
                end
            else
                -- Regular or special notification
                local petName = webhookData.petName
                local shiny = webhookData.shiny
                local mythic = webhookData.mythic
                local eggName = webhookData.eggName
                local rarity = webhookData.rarity
                local pet = webhookData.pet
                local petImageUrl = webhookData.petImageUrl
                local isSpecial = webhookData.isSpecial == true
                local isInfinity = webhookData.isInfinity == true
                
                -- Processing webhook notification
                
                -- Try sending with retry on rate limit
                local maxRetries = 5
                local retryCount = 0
                local success = false
                
                while retryCount < maxRetries and not success do
                    if isSpecial then
                        success = sendSpecialDiscordNotificationInternal(petName, shiny, mythic, eggName, rarity, pet, petImageUrl, isInfinity)
                    else
                        success = sendDiscordNotificationInternal(petName, shiny, mythic, eggName, rarity, pet, petImageUrl)
                    end
                    
                    if not success then
                        retryCount = retryCount + 1
                        if retryCount < maxRetries then
                            print("Rate limited, waiting 1 second before retry " .. retryCount .. "/" .. maxRetries)
                            task.wait(1)
                        end
                    end
                end
                
                -- If still failed after max retries, add back to front of queue and increase delay
                if not success then
                    print("‚úó Webhook failed after " .. maxRetries .. " retries, re-queuing to front")
                    table.insert(webhookQueue, 1, webhookData)
                    messagesRemainingWithDelay = 5 -- Set delay for next 5 messages
                end
            end
            
            -- Determine delay based on rate limit counter
            local delay = (messagesRemainingWithDelay > 0) and 2 or 1
            if messagesRemainingWithDelay > 0 then
                messagesRemainingWithDelay = messagesRemainingWithDelay - 1
            end
            
            -- Wait before sending next message in queue
            if #webhookQueue > 0 then
                task.wait(delay)
            end
        end
        
        isSendingWebhook = false
    end)
end

-- Public function to queue webhook (handles rate limiting)
local function sendDiscordNotification(petName, shiny, mythic, eggName, rarity, pet)
    -- Don't process if script is closed
    if not scriptActive then
        return
    end
    
    if webhookURL == "" then
        print("‚úó Webhook URL not set")
        return
    end
    
    if not httpLib then
        print("‚úó HTTP library not available")
        return
    end
    
    -- Get pet image URL
    local petImageUrl = nil
    if PetsData and petName then
        local success, petData = pcall(function()
            return PetsData[petName]
        end)
        
        if success and petData and petData.Images then
            -- Determine image type based on shiny/mythic status
            local imageType = "Normal"
            if shiny == true and mythic == true then
                imageType = "MythicShiny"
            elseif shiny == true then
                imageType = "Shiny"
            elseif mythic == true then
                imageType = "Mythic"
            end
            
            -- Get the image asset ID
            local petImageAsset = petData.Images[imageType] or petData.Images["Normal"]
            
            if petImageAsset then
                -- Extract asset ID from rbxassetid:// format
                local assetId = petImageAsset:match("rbxassetid://(%d+)")
                
                if assetId then
                    -- Convert to Discord-compatible thumbnail URL
                    petImageUrl = getThumbnailUrl(assetId)
                end
            end
        end
    end
    
    -- Check if this is a special pet
    local isSpecial = isSpecialPet(petName)
    local isInfinity = isInfinityRarity(rarity)
    
    -- If special pet, send special notification and debug message
    if isSpecial then
        -- Add special notification to queue
        table.insert(webhookQueue, {
            petName = petName,
            shiny = shiny,
            mythic = mythic,
            eggName = eggName,
            rarity = rarity,
            pet = pet,
            petImageUrl = petImageUrl,
            isSpecial = true,
            isInfinity = isInfinity
        })
        
        -- Add debug message to queue (separate message, no ping)
        local debugMessage = isInfinity and 
            "The rarity of this pet is specified as Infinity" or 
            ("The rarity is not infinity. Rarity: " .. (rarity or "Unknown"))
        table.insert(webhookQueue, {
            debugMessage = debugMessage,
            isDebug = true
        })
        
        -- Special pet notification and debug message added to queue
    else
        -- Add regular notification to queue
        table.insert(webhookQueue, {
            petName = petName,
            shiny = shiny,
            mythic = mythic,
            eggName = eggName,
            rarity = rarity,
            pet = pet,
            petImageUrl = petImageUrl,
            isSpecial = false
        })
        
        -- Regular notification added to queue
    end
    
    -- Start processing queue if not already processing
    processWebhookQueue()
end

-- Connect to HatchEgg event
local function connectToEvents()
    if not Remote then
        print("‚úó Remote module not loaded!")
        return false
    end
    
    if not ItemUtil then
        print("‚úó ItemUtil not loaded!")
        return false
    end
    
    local success, err = pcall(function()
        hatchEventConnection = Remote.Event("HatchEgg"):Connect(function(hatchedTable)
            -- Wrap entire handler in pcall to prevent errors from breaking the connection
            pcall(function()
                -- Don't process if script is closed
                if not scriptActive then
                    return
                end
                
                -- Optimized: Removed verbose prints that fire on every hatch
                if type(hatchedTable) == "table" and hatchedTable.Pets then
                    local eggName = hatchedTable.Name
                    
                    for i = 1, 20 do
                        local petData = hatchedTable.Pets[i]
                        if not petData then break end
                        
                        if type(petData) == "table" and petData.Pet then
                            local pet = petData.Pet
                            local petName = pet.Name
                            local shiny = pet.Shiny == true
                            local mythic = pet.Mythic == true
                            
                            if petName and ItemUtil then
                                local rarity = ItemUtil:GetRarity(pet)
                                
                                -- Check if this is a special pet (regardless of rarity)
                                local isSpecial = isSpecialPet(petName)
                                
                                -- Check if Secret
                                local isSecret = rarity == "Secret"
                                
                                -- Check if Legendary (only if flag is enabled)
                                -- If DETECT_LEGENDARIES is false, isLegendary will always be false
                                local isLegendary = false
                                if DETECT_LEGENDARIES then
                                    isLegendary = (rarity == "Legendary")
                                end
                                
                                -- Send notification if:
                                -- 1. It's a Secret pet, OR
                                -- 2. It's a Legendary pet (only if DETECT_LEGENDARIES is true), OR
                                -- 3. It's a special pet (regardless of rarity)
                                if isSecret or isLegendary or isSpecial then
                                    if isSecret then
                                        print(">>> SECRET DETECTED! <<<")
                                    elseif isLegendary then
                                        print(">>> LEGENDARY DETECTED! <<<")
                                    elseif isSpecial then
                                        print(">>> SPECIAL PET DETECTED! <<<")
                                    end
                                    
                                    -- Send webhook only (no in-game notifications)
                                    -- Pass the pet object so we can calculate probability
                                    sendDiscordNotification(petName, shiny, mythic, eggName, rarity, pet)
                                end
                            end
                        end
                    end
                end
            end)
        end)
    end)
    
    if success then
        print("‚úì Connected to HatchEgg events")
        return true
    else
        print("‚úó Failed to connect: " .. tostring(err))
        return false
    end
end

-- Connect after modules load
task.wait(1)
connectToEvents()

-- GUI
local g = Instance.new("ScreenGui")
g.Name = "BubblegumAutoHatch"
g.ResetOnSpawn = false  -- Prevent GUI from being destroyed on character reset
g.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
g.Parent = p.PlayerGui

-- Main frame
local f = Instance.new("Frame")
f.Size = UDim2.new(0, 350, 0, 240)
f.Position = UDim2.new(0.5, -175, 0.5, -120)
f.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
f.BorderSizePixel = 0
f.Parent = g

-- Title bar
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -90, 0, 40)
title.Position = UDim2.new(0, 50, 0, 0)
title.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
title.Text = "Auto Hatch & Notifier"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextSize = 16
title.Font = Enum.Font.GothamBold
title.BorderSizePixel = 0
title.Parent = f

-- Close button (top left - opens confirmation dialog)
local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 50, 0, 40)
closeBtn.Position = UDim2.new(0, 0, 0, 0)
closeBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
closeBtn.Text = "Close"
closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeBtn.TextSize = 12
closeBtn.Font = Enum.Font.GothamBold
closeBtn.BorderSizePixel = 0
closeBtn.Parent = f

-- Hide button (top right - hides GUI)
local closeXBtn = Instance.new("TextButton")
closeXBtn.Size = UDim2.new(0, 40, 0, 40)
closeXBtn.Position = UDim2.new(1, -40, 0, 0)
closeXBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
closeXBtn.Text = "X"
closeXBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeXBtn.TextSize = 24
closeXBtn.Font = Enum.Font.GothamBold
closeXBtn.BorderSizePixel = 0
closeXBtn.Parent = f

-- Confirmation dialog (initially hidden)
local confirmFrame = Instance.new("Frame")
confirmFrame.Size = UDim2.new(0, 300, 0, 150)
confirmFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
confirmFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
confirmFrame.BorderSizePixel = 2
confirmFrame.BorderColor3 = Color3.fromRGB(200, 50, 50)
confirmFrame.Visible = false
confirmFrame.ZIndex = 10
confirmFrame.Parent = g

local confirmTitle = Instance.new("TextLabel")
confirmTitle.Size = UDim2.new(1, 0, 0, 40)
confirmTitle.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
confirmTitle.Text = "Close Script?"
confirmTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmTitle.TextSize = 16
confirmTitle.Font = Enum.Font.GothamBold
confirmTitle.BorderSizePixel = 0
confirmTitle.ZIndex = 11
confirmTitle.Parent = confirmFrame

local confirmText = Instance.new("TextLabel")
confirmText.Size = UDim2.new(0, 280, 0, 50)
confirmText.Position = UDim2.new(0, 10, 0, 45)
confirmText.BackgroundTransparency = 1
confirmText.Text = "Are you sure you want to close the script?\nAll functionality will stop."
confirmText.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmText.TextSize = 12
confirmText.Font = Enum.Font.Gotham
confirmText.TextWrapped = true
confirmText.ZIndex = 11
confirmText.Parent = confirmFrame

local yesBtn = Instance.new("TextButton")
yesBtn.Size = UDim2.new(0, 120, 0, 35)
yesBtn.Position = UDim2.new(0, 20, 1, -50)
yesBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
yesBtn.Text = "Yes, Close"
yesBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
yesBtn.TextSize = 12
yesBtn.Font = Enum.Font.GothamBold
yesBtn.BorderSizePixel = 0
yesBtn.ZIndex = 11
yesBtn.Parent = confirmFrame

local noBtn = Instance.new("TextButton")
noBtn.Size = UDim2.new(0, 120, 0, 35)
noBtn.Position = UDim2.new(1, -140, 1, -50)
noBtn.BackgroundColor3 = Color3.fromRGB(80, 140, 80)
noBtn.Text = "No, Cancel"
noBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
noBtn.TextSize = 12
noBtn.Font = Enum.Font.GothamBold
noBtn.BorderSizePixel = 0
noBtn.ZIndex = 11
noBtn.Parent = confirmFrame

-- Auto Hatch button
local autoHatchBtn = Instance.new("TextButton")
autoHatchBtn.Size = UDim2.new(0, 320, 0, 45)
autoHatchBtn.Position = UDim2.new(0, 15, 0, 55)
autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
autoHatchBtn.Text = "Auto Hatch: OFF"
autoHatchBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
autoHatchBtn.TextSize = 14
autoHatchBtn.Font = Enum.Font.GothamBold
autoHatchBtn.BorderSizePixel = 0
autoHatchBtn.Parent = f

-- Webhook URL label
local webhookLabel = Instance.new("TextLabel")
webhookLabel.Size = UDim2.new(0, 320, 0, 20)
webhookLabel.Position = UDim2.new(0, 15, 0, 110)
webhookLabel.BackgroundTransparency = 1
webhookLabel.Text = "Discord Webhook URL:"
webhookLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
webhookLabel.TextSize = 11
webhookLabel.Font = Enum.Font.Gotham
webhookLabel.TextXAlignment = Enum.TextXAlignment.Left
webhookLabel.Parent = f

-- Webhook URL input
local webhookInput = Instance.new("TextBox")
webhookInput.Size = UDim2.new(0, 320, 0, 30)
webhookInput.Position = UDim2.new(0, 15, 0, 130)
webhookInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
webhookInput.TextColor3 = Color3.fromRGB(255, 255, 255)
webhookInput.Text = webhookURL or "" -- Pre-fill with loaded value if available
webhookInput.PlaceholderText = "https://discord.com/api/webhooks/..."
webhookInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
webhookInput.TextSize = 10
webhookInput.Font = Enum.Font.Gotham
webhookInput.BorderSizePixel = 0
webhookInput.TextTruncate = Enum.TextTruncate.AtEnd
webhookInput.Parent = f

-- Discord User ID label
local userIDLabel = Instance.new("TextLabel")
userIDLabel.Size = UDim2.new(0, 320, 0, 20)
userIDLabel.Position = UDim2.new(0, 15, 0, 170)
userIDLabel.BackgroundTransparency = 1
userIDLabel.Text = "Discord User ID (optional):"
userIDLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
userIDLabel.TextSize = 11
userIDLabel.Font = Enum.Font.Gotham
userIDLabel.TextXAlignment = Enum.TextXAlignment.Left
userIDLabel.Parent = f

-- Discord User ID input
local userIDInput = Instance.new("TextBox")
userIDInput.Size = UDim2.new(0, 320, 0, 30)
userIDInput.Position = UDim2.new(0, 15, 0, 190)
userIDInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
userIDInput.TextColor3 = Color3.fromRGB(255, 255, 255)
userIDInput.Text = discordUserID or "" -- Pre-fill with loaded value if available
userIDInput.PlaceholderText = "123456789012345678"
userIDInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
userIDInput.TextSize = 11
userIDInput.Font = Enum.Font.Gotham
userIDInput.BorderSizePixel = 0
userIDInput.Parent = f

-- Toggle GUI button (top right, moved up)
local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0, 50, 0, 50)
toggleBtn.Position = UDim2.new(1, -60, 0, -40)
toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
toggleBtn.Text = "GUI"
toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleBtn.TextSize = 12
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.BorderSizePixel = 0
toggleBtn.Parent = g

-- Auto Hatch functionality
autoHatchBtn.Activated:Connect(function()
    -- Don't process if script is closed
    if not scriptActive then
        return
    end
    
    autoHatchEnabled = not autoHatchEnabled
    
    if autoHatchEnabled then
        autoHatchBtn.Text = "Auto Hatch: ON"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
        
        -- Start E key spam
        spawn(function()
            while autoHatchEnabled and scriptActive do
                VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                task.wait(0.05)
                VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                task.wait(0.2)
            end
        end)
    else
        autoHatchBtn.Text = "Auto Hatch: OFF"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
end)

-- Webhook URL input handler
webhookInput.FocusLost:Connect(function(enterPressed)
    local url = webhookInput.Text:gsub("^%s*(.-)%s*$", "%1")
    webhookURL = url
    print("Webhook URL saved: " .. (url ~= "" and "SET (" .. string.sub(url, 1, 50) .. "...)" or "EMPTY"))
    saveSettings() -- Save to file (non-blocking, won't break if it fails)
end)

-- Discord User ID input handler
userIDInput.FocusLost:Connect(function(enterPressed)
    local id = userIDInput.Text:gsub("^%s*(.-)%s*$", "%1")
    discordUserID = id
    print("Discord User ID saved: " .. (id ~= "" and id or "EMPTY"))
    saveSettings() -- Save to file (non-blocking, won't break if it fails)
end)

-- Close button (top left) - opens confirmation dialog
closeBtn.Activated:Connect(function()
    confirmFrame.Visible = true
end)

-- Hide button (top right X) - hides GUI
closeXBtn.Activated:Connect(function()
    f.Visible = false
    if toggleBtn then
        toggleBtn.Text = ">>>"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    end
end)

-- Yes button - closes everything
yesBtn.Activated:Connect(function()
    print("Closing script...")
    
    -- Mark script as inactive (stops all processing)
    scriptActive = false
    
    -- Stop auto hatch
    autoHatchEnabled = false
    
    -- Disconnect event connection
    if hatchEventConnection then
        hatchEventConnection:Disconnect()
        hatchEventConnection = nil
        print("‚úì Event connection disconnected")
    end
    
    -- Clear webhook queue
    webhookQueue = {}
    isSendingWebhook = false
    print("‚úì Webhook queue cleared")
    
    -- Destroy GUI
    g:Destroy()
    print("‚úì GUI destroyed")
    
    -- Stop script
    print("Script closed by user - all functionality stopped")
    error("Script closed")
end)

-- No button - closes confirmation dialog
noBtn.Activated:Connect(function()
    confirmFrame.Visible = false
end)

-- Toggle GUI button
toggleBtn.Activated:Connect(function()
    f.Visible = not f.Visible
    if f.Visible then
        toggleBtn.Text = "GUI"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
    else
        toggleBtn.Text = ">>>"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    end
end)

print("‚úì GUI created")
print("Ready! Click 'Auto Hatch' to start hatching")

-- Monitor GUI to detect if it gets destroyed unexpectedly
g.AncestryChanged:Connect(function(child, parent)
    if not parent and scriptActive then
        warn("WARNING: GUI was destroyed or removed! This might be caused by a game update or character reset.")
        warn("Parent changed to: " .. tostring(parent))
    end
end)
