-- BUBBLEGUM SIMULATOR - AUTO HATCH & SECRET NOTIFIER
-- Final version with auto hatch and Discord notifications

local P = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local VIM = game:GetService("VirtualInputManager")
local p = P.LocalPlayer

print("========================================")
print("BUBBLEGUM AUTO HATCH & NOTIFIER")
print("Version: Final")
print("========================================")

-- Load required modules
local Remote = nil
local ItemUtil = nil
local PetsData = nil

-- Settings
local autoHatchEnabled = false
local webhookURL = ""
local discordUserID = ""

-- Load modules
local function loadModules()
    -- Load Remote
    local success, remoteModule = pcall(function()
        return require(RS.Shared.Framework.Network.Remote)
    end)
    if success and remoteModule then
        Remote = remoteModule
        print("âœ“ Loaded Remote module")
    end
    
    -- Load ItemUtil
    local success2, itemUtil = pcall(function()
        return require(RS.Shared.Utils.Stats.ItemUtil)
    end)
    if success2 and itemUtil then
        ItemUtil = itemUtil
        print("âœ“ Loaded ItemUtil")
    end
    
    -- Load Pets data for images
    local success3, petsData = pcall(function()
        return require(RS.Shared.Data.Pets)
    end)
    if success3 and petsData then
        PetsData = petsData
        print("âœ“ Loaded Pets data")
    end
end

loadModules()

-- HTTP for Delta Mobile (using the working method from testing)
local httpLib = nil
local httpLibName = nil
if request then
    httpLib = function(url, method, headers, body)
        local success, res, err = pcall(function()
            return request({Url=url, Method=method, Headers=headers or {}, Body=body})
        end)
        if success and res then
            local status = res.StatusCode or (res.Success and 200 or (res.success and 200 or 0))
            local body = res.Body or res.body or ""
            local ok = res.Success or res.success or status == 200 or status == 204
            return ok, body, status
        end
        return false, err or "Request exception", 0
    end
    httpLibName = "request"
end

-- JSON encoder (properly handles nested structures)
local function jsonEncode(t)
    local function encodeValue(v, depth)
        depth = depth or 0
        if depth > 10 then return "null" end -- Prevent infinite recursion
        
        if type(v) == "string" then
            -- Escape special characters
            v = v:gsub("\\", "\\\\")
            v = v:gsub('"', '\\"')
            v = v:gsub("\n", "\\n")
            v = v:gsub("\r", "\\r")
            v = v:gsub("\t", "\\t")
            return '"' .. v .. '"'
        elseif type(v) == "number" then
            return tostring(v)
        elseif type(v) == "boolean" then
            return v and "true" or "false"
        elseif type(v) == "table" then
            -- Check if it's an array
            local isArray = false
            local maxIndex = 0
            for k in pairs(v) do
                if type(k) == "number" then
                    maxIndex = math.max(maxIndex, k)
                end
            end
            isArray = maxIndex > 0 and maxIndex == #v
            
            local parts = {}
            if isArray then
                for i = 1, maxIndex do
                    table.insert(parts, encodeValue(v[i], depth + 1))
                end
                return "[" .. table.concat(parts, ",") .. "]"
            else
                for k, val in pairs(v) do
                    if val ~= nil then
                        local key = type(k) == "string" and ('"' .. k .. '"') or tostring(k)
                        table.insert(parts, key .. ":" .. encodeValue(val, depth + 1))
                    end
                end
                return "{" .. table.concat(parts, ",") .. "}"
            end
        else
            return "null"
        end
    end
    return encodeValue(t, 0)
end

-- Get pet image
local function getPetImage(pet, shiny, mythic)
    if not PetsData or not pet then return nil end
    
    local petData = PetsData[pet]
    if not petData or not petData.Images then return nil end
    
    local imageType = "Normal"
    if shiny and mythic then
        imageType = "MythicShiny"
    elseif shiny then
        imageType = "Shiny"
    elseif mythic then
        imageType = "Mythic"
    end
    
    return petData.Images[imageType] or petData.Images.Normal
end

-- Send Discord webhook with beautiful embed
local function sendDiscordNotification(petName, shiny, mythic, eggName, rarity)
    if not httpLib or webhookURL == "" then 
        print("âœ— Cannot send: httpLib=" .. tostring(httpLib) .. ", webhookURL=" .. tostring(webhookURL))
        return 
    end
    
    -- Get player name
    local playerName = p.Name or "Unknown Player"
    
    -- Build pet name with prefix
    local fullPetName = petName
    if shiny and mythic then
        fullPetName = "Shiny Mythic " .. petName
    elseif shiny then
        fullPetName = "Shiny " .. petName
    elseif mythic then
        fullPetName = "Mythic " .. petName
    end
    
    -- Get pet image
    local petImage = getPetImage(petName, shiny, mythic)
    
    -- Determine color based on pet type
    local embedColor = 3447003 -- Default blue
    if shiny and mythic then
        embedColor = 16711680 -- Bright red for Shiny Mythic
    elseif shiny then
        embedColor = 16766720 -- Gold/yellow-orange for Shiny
    elseif mythic then
        embedColor = 10181046 -- Purple-pink for Mythic
    elseif rarity == "Secret" then
        embedColor = 16711680 -- Red for Secret
    elseif rarity == "Legendary" then
        embedColor = 16755200 -- Orange for Legendary
    end
    
    -- Build mention
    local mention = discordUserID ~= "" and ("<@" .. discordUserID .. "> ") or ""
    
    -- Try progressively simpler payloads
    local attempts = {
        -- Attempt 1: Full embed with all features
        function()
            local embed = {
                title = "ðŸŽ‰ Congratulations!",
                description = mention .. "**" .. playerName .. "** hatched **" .. fullPetName .. "**!",
                color = embedColor,
                fields = {
                    {
                        name = "Hatched",
                        value = fullPetName,
                        inline = false
                    },
                    {
                        name = "Rarity",
                        value = rarity,
                        inline = true
                    },
                    {
                        name = "Egg",
                        value = eggName or "Unknown",
                        inline = true
                    }
                },
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }
            
            if petImage then
                embed.thumbnail = {
                    url = petImage
                }
            end
            
            return {
                content = mention,
                embeds = {embed}
            }
        end,
        
        -- Attempt 2: Embed without thumbnail
        function()
            local embed = {
                title = "ðŸŽ‰ Congratulations!",
                description = mention .. "**" .. playerName .. "** hatched **" .. fullPetName .. "**!",
                color = embedColor,
                fields = {
                    {
                        name = "Hatched",
                        value = fullPetName,
                        inline = false
                    },
                    {
                        name = "Rarity",
                        value = rarity,
                        inline = true
                    }
                },
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }
            
            return {
                content = mention,
                embeds = {embed}
            }
        end,
        
        -- Attempt 3: Embed without fields
        function()
            local embed = {
                title = "ðŸŽ‰ Congratulations!",
                description = mention .. "**" .. playerName .. "** hatched **" .. fullPetName .. "**!\n**Rarity:** " .. rarity,
                color = embedColor,
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }
            
            if petImage then
                embed.thumbnail = {
                    url = petImage
                }
            end
            
            return {
                content = mention,
                embeds = {embed}
            }
        end,
        
        -- Attempt 4: Simple embed
        function()
            return {
                content = mention .. "ðŸŽ‰ **Congratulations!** " .. playerName .. " hatched **" .. fullPetName .. "**! (" .. rarity .. ")",
                embeds = {}
            }
        end,
        
        -- Attempt 5: Plain message
        function()
            return {
                content = mention .. "ðŸŽ‰ Congratulations! " .. playerName .. " hatched " .. fullPetName .. "! (" .. rarity .. ")"
            }
        end
    }
    
    print("Sending webhook for " .. rarity .. " pet: " .. petName)
    
    local headers = {["Content-Type"] = "application/json"}
    local success = false
    local status = 0
    local response = ""
    
    -- Try each attempt in order
    for i, attemptFunc in ipairs(attempts) do
        local payload = attemptFunc()
        local json = jsonEncode(payload)
        
        print("Attempt " .. i .. ": " .. (#json < 200 and json or string.sub(json, 1, 200) .. "..."))
        
        success, response, status = httpLib(webhookURL, "POST", headers, json)
        
        if success and (status == 200 or status == 204) then
            print("âœ“ Discord notification sent! (Attempt " .. i .. ", Status: " .. tostring(status) .. ")")
            return
        else
            print("âœ— Attempt " .. i .. " failed: Status " .. tostring(status))
            if i < #attempts then
                print("  Trying simpler format...")
            end
        end
    end
    
    print("âœ— All attempts failed!")
    print("  Final Status: " .. tostring(status))
    print("  Response: " .. tostring(response))
end

-- Send in-game notification
local function sendInGameNotification(petName, shiny, mythic, rarity)
    local prefix = ""
    if shiny and mythic then
        prefix = "Shiny Mythic "
    elseif shiny then
        prefix = "Shiny "
    elseif mythic then
        prefix = "Mythic "
    end
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "ðŸŽ‰ " .. rarity .. " Pet Hatched!",
        Text = prefix .. petName,
        Duration = 5,
        Button1 = "OK"
    })
end

-- Connect to HatchEgg event
local function connectToEvents()
    if not Remote then
        print("âœ— Remote module not loaded!")
        if statusLabel then
            statusLabel.Text = "Status: ERROR - Remote module not loaded!"
            statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        end
        return false
    end
    
    if not ItemUtil then
        print("âœ— ItemUtil not loaded!")
        if statusLabel then
            statusLabel.Text = "Status: ERROR - ItemUtil not loaded!"
            statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        end
        return false
    end
    
    local success, err = pcall(function()
        Remote.Event("HatchEgg"):Connect(function(hatchedTable)
            print("=== HatchEgg Event Fired ===")
            
            if type(hatchedTable) == "table" then
                print("hatchedTable is table")
                if hatchedTable.Pets then
                    print("Pets found: " .. tostring(type(hatchedTable.Pets)))
                    local eggName = hatchedTable.Name
                    print("Egg: " .. tostring(eggName))
                    
                    for i = 1, 20 do
                        local petData = hatchedTable.Pets[i]
                        if not petData then break end
                        
                        if type(petData) == "table" and petData.Pet then
                            local pet = petData.Pet
                            local petName = pet.Name
                            local shiny = pet.Shiny == true
                            local mythic = pet.Mythic == true
                            
                            print("Pet " .. i .. ": " .. tostring(petName) .. " (Shiny: " .. tostring(shiny) .. ", Mythic: " .. tostring(mythic) .. ")")
                            
                            if petName and ItemUtil then
                                local rarity = ItemUtil:GetRarity(pet)
                                print("Rarity: " .. tostring(rarity))
                                
                                -- Check if Legendary or Secret
                                if rarity == "Legendary" or rarity == "Secret" then
                                    print(">>> " .. rarity .. " DETECTED! <<<")
                                    
                                    -- Update status
                                    if statusLabel then
                                        statusLabel.Text = "Status: " .. rarity .. " hatched!\n" .. petName
                                        statusLabel.TextColor3 = rarity == "Secret" and Color3.fromRGB(255, 100, 100) or Color3.fromRGB(255, 200, 100)
                                    end
                                    
                                    -- Send notifications
                                    sendInGameNotification(petName, shiny, mythic, rarity)
                                    sendDiscordNotification(petName, shiny, mythic, eggName, rarity)
                                end
                            end
                        end
                    end
                else
                    print("âœ— No Pets in hatchedTable")
                end
            else
                print("âœ— hatchedTable is not a table: " .. type(hatchedTable))
            end
        end)
    end)
    
    if success then
        print("âœ“ Connected to HatchEgg events")
        if statusLabel then
            statusLabel.Text = "Status: Connected to events\nWaiting for Legendary/Secret..."
            statusLabel.TextColor3 = Color3.fromRGB(150, 255, 150)
        end
        return true
    else
        print("âœ— Failed to connect: " .. tostring(err))
        if statusLabel then
            statusLabel.Text = "Status: Connection failed!\n" .. tostring(err)
            statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        end
        return false
    end
end

-- Connect after modules load
task.wait(1)
connectToEvents()

-- GUI
local g = Instance.new("ScreenGui")
g.Name = "BubblegumAutoHatch"
g.Parent = p.PlayerGui

-- Main frame
local f = Instance.new("Frame")
f.Size = UDim2.new(0, 350, 0, 400)
f.Position = UDim2.new(0.5, -175, 0.5, -200)
f.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
f.BorderSizePixel = 0
f.Parent = g

-- Title bar
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -50, 0, 40)
title.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
title.Text = "Auto Hatch & Notifier"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextSize = 16
title.Font = Enum.Font.GothamBold
title.BorderSizePixel = 0
title.Parent = f

-- Close button (red X)
local closeXBtn = Instance.new("TextButton")
closeXBtn.Size = UDim2.new(0, 40, 0, 40)
closeXBtn.Position = UDim2.new(1, -40, 0, 0)
closeXBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeXBtn.Text = "âœ•"
closeXBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeXBtn.TextSize = 20
closeXBtn.Font = Enum.Font.GothamBold
closeXBtn.BorderSizePixel = 0
closeXBtn.Parent = f

-- Confirmation dialog (initially hidden)
local confirmFrame = Instance.new("Frame")
confirmFrame.Size = UDim2.new(0, 300, 0, 150)
confirmFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
confirmFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
confirmFrame.BorderSizePixel = 2
confirmFrame.BorderColor3 = Color3.fromRGB(200, 50, 50)
confirmFrame.Visible = false
confirmFrame.ZIndex = 10
confirmFrame.Parent = g

local confirmTitle = Instance.new("TextLabel")
confirmTitle.Size = UDim2.new(1, 0, 0, 40)
confirmTitle.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
confirmTitle.Text = "Close Script?"
confirmTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmTitle.TextSize = 16
confirmTitle.Font = Enum.Font.GothamBold
confirmTitle.BorderSizePixel = 0
confirmTitle.Parent = confirmFrame

local confirmText = Instance.new("TextLabel")
confirmText.Size = UDim2.new(0, 280, 0, 50)
confirmText.Position = UDim2.new(0, 10, 0, 45)
confirmText.BackgroundTransparency = 1
confirmText.Text = "Are you sure you want to close the script?\nAll functionality will stop."
confirmText.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmText.TextSize = 12
confirmText.Font = Enum.Font.Gotham
confirmText.TextWrapped = true
confirmText.Parent = confirmFrame

local yesBtn = Instance.new("TextButton")
yesBtn.Size = UDim2.new(0, 120, 0, 35)
yesBtn.Position = UDim2.new(0, 20, 1, -50)
yesBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
yesBtn.Text = "Yes, Close"
yesBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
yesBtn.TextSize = 12
yesBtn.Font = Enum.Font.GothamBold
yesBtn.BorderSizePixel = 0
yesBtn.Parent = confirmFrame

local noBtn = Instance.new("TextButton")
noBtn.Size = UDim2.new(0, 120, 0, 35)
noBtn.Position = UDim2.new(1, -140, 1, -50)
noBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
noBtn.Text = "No, Cancel"
noBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
noBtn.TextSize = 12
noBtn.Font = Enum.Font.GothamBold
noBtn.BorderSizePixel = 0
noBtn.Parent = confirmFrame

-- Auto Hatch button
local autoHatchBtn = Instance.new("TextButton")
autoHatchBtn.Size = UDim2.new(0, 320, 0, 45)
autoHatchBtn.Position = UDim2.new(0, 15, 0, 55)
autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
autoHatchBtn.Text = "Auto Hatch: OFF"
autoHatchBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
autoHatchBtn.TextSize = 14
autoHatchBtn.Font = Enum.Font.GothamBold
autoHatchBtn.BorderSizePixel = 0
autoHatchBtn.Parent = f

-- Webhook URL label
local webhookLabel = Instance.new("TextLabel")
webhookLabel.Size = UDim2.new(0, 320, 0, 20)
webhookLabel.Position = UDim2.new(0, 15, 0, 110)
webhookLabel.BackgroundTransparency = 1
webhookLabel.Text = "Discord Webhook URL:"
webhookLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
webhookLabel.TextSize = 11
webhookLabel.Font = Enum.Font.Gotham
webhookLabel.TextXAlignment = Enum.TextXAlignment.Left
webhookLabel.Parent = f

-- Webhook URL input
local webhookInput = Instance.new("TextBox")
webhookInput.Size = UDim2.new(0, 320, 0, 30)
webhookInput.Position = UDim2.new(0, 15, 0, 130)
webhookInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
webhookInput.TextColor3 = Color3.fromRGB(255, 255, 255)
webhookInput.Text = ""
webhookInput.PlaceholderText = "https://discord.com/api/webhooks/..."
webhookInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
webhookInput.TextSize = 11
webhookInput.Font = Enum.Font.Gotham
webhookInput.BorderSizePixel = 0
webhookInput.Parent = f

-- Discord User ID label
local userIDLabel = Instance.new("TextLabel")
userIDLabel.Size = UDim2.new(0, 320, 0, 20)
userIDLabel.Position = UDim2.new(0, 15, 0, 170)
userIDLabel.BackgroundTransparency = 1
userIDLabel.Text = "Discord User ID (optional):"
userIDLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
userIDLabel.TextSize = 11
userIDLabel.Font = Enum.Font.Gotham
userIDLabel.TextXAlignment = Enum.TextXAlignment.Left
userIDLabel.Parent = f

-- Discord User ID input
local userIDInput = Instance.new("TextBox")
userIDInput.Size = UDim2.new(0, 320, 0, 30)
userIDInput.Position = UDim2.new(0, 15, 0, 190)
userIDInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
userIDInput.TextColor3 = Color3.fromRGB(255, 255, 255)
userIDInput.Text = ""
userIDInput.PlaceholderText = "123456789012345678"
userIDInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
userIDInput.TextSize = 11
userIDInput.Font = Enum.Font.Gotham
userIDInput.BorderSizePixel = 0
userIDInput.Parent = f

-- Status label (for debugging)
local statusLabel = Instance.new("TextLabel")
statusLabel.Size = UDim2.new(0, 320, 0, 120)
statusLabel.Position = UDim2.new(0, 15, 0, 230)
statusLabel.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
statusLabel.Text = "Status: Loading modules...\nWaiting for connection..."
statusLabel.TextColor3 = Color3.fromRGB(150, 255, 150)
statusLabel.TextSize = 11
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextWrapped = true
statusLabel.BorderSizePixel = 0
statusLabel.Parent = f


-- Toggle GUI button (top right)
local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0, 50, 0, 50)
toggleBtn.Position = UDim2.new(1, -60, 0, 10)
toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
toggleBtn.Text = "GUI"
toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleBtn.TextSize = 12
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.BorderSizePixel = 0
toggleBtn.Parent = g

-- Auto Hatch functionality
autoHatchBtn.Activated:Connect(function()
    autoHatchEnabled = not autoHatchEnabled
    
    if autoHatchEnabled then
        autoHatchBtn.Text = "Auto Hatch: ON"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
        statusLabel.Text = "Status: Auto Hatch Active\nPressing E every 0.2s"
        
        -- Start E key spam
        spawn(function()
            while autoHatchEnabled do
                VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                task.wait(0.05)
                VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                task.wait(0.2)
            end
        end)
    else
        autoHatchBtn.Text = "Auto Hatch: OFF"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        statusLabel.Text = "Status: Auto Hatch Stopped"
    end
end)

-- Webhook URL input handler
webhookInput.FocusLost:Connect(function(enterPressed)
    local url = webhookInput.Text:gsub("^%s*(.-)%s*$", "%1")
    webhookURL = url
    
    if url ~= "" then
        statusLabel.Text = "Status: Webhook URL saved\nNotifications enabled for Legendary & Secret pets"
        statusLabel.TextColor3 = Color3.fromRGB(150, 255, 150)
    else
        statusLabel.Text = "Status: No webhook URL\nNotifications disabled"
        statusLabel.TextColor3 = Color3.fromRGB(255, 150, 150)
    end
end)

-- Discord User ID input handler
userIDInput.FocusLost:Connect(function(enterPressed)
    local id = userIDInput.Text:gsub("^%s*(.-)%s*$", "%1")
    discordUserID = id
    
    if id ~= "" then
        statusLabel.Text = "Status: User ID saved\nYou will be pinged in notifications"
    end
end)

-- Close X button - opens confirmation dialog
closeXBtn.Activated:Connect(function()
    confirmFrame.Visible = true
end)

-- Yes button - closes everything
yesBtn.Activated:Connect(function()
    -- Stop auto hatch
    autoHatchEnabled = false
    
    -- Destroy GUI
    g:Destroy()
    
    -- Stop script
    print("Script closed by user")
    error("Script closed")
end)

-- No button - closes confirmation dialog
noBtn.Activated:Connect(function()
    confirmFrame.Visible = false
end)

-- Toggle GUI button
toggleBtn.Activated:Connect(function()
    f.Visible = not f.Visible
    if f.Visible then
        toggleBtn.Text = "GUI"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
    else
        toggleBtn.Text = ">>>"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    end
end)

print("âœ“ GUI created")
print("Ready! Click 'Auto Hatch' to start hatching")

