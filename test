-- BUBBLEGUM SIMULATOR - AUTO HATCH & SECRET NOTIFIER
-- Version 2.0 with auto hatch and Discord notifications

local P = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local VIM = game:GetService("VirtualInputManager")
local p = P.LocalPlayer

print("========================================")
print("BUBBLEGUM AUTO HATCH & NOTIFIER")
print("Version: 2.0")
print("========================================")

-- Load required modules
local Remote = nil
local ItemUtil = nil
local PetsData = nil
local PetUtil = nil
local FormatCommas = nil

-- Settings
local autoHatchEnabled = false
local webhookURL = ""
local discordUserID = ""

-- Webhook queue for rate limiting
local webhookQueue = {}
local isSendingWebhook = false

-- Script state
local scriptActive = true
local hatchEventConnection = nil

-- Load modules
local function loadModules()
    -- Load Remote
    local success, remoteModule = pcall(function()
        return require(RS.Shared.Framework.Network.Remote)
    end)
    if success and remoteModule then
        Remote = remoteModule
        print("âœ“ Loaded Remote module")
    end
    
    -- Load ItemUtil
    local success2, itemUtil = pcall(function()
        return require(RS.Shared.Utils.Stats.ItemUtil)
    end)
    if success2 and itemUtil then
        ItemUtil = itemUtil
        print("âœ“ Loaded ItemUtil")
    end
    
    -- Load Pets data for images
    local success3, petsData = pcall(function()
        return require(RS.Shared.Data.Pets)
    end)
    if success3 and petsData then
        PetsData = petsData
        print("âœ“ Loaded Pets data")
    end
    
    -- Load PetUtil for chance calculation
    local success4, petUtil = pcall(function()
        return require(RS.Shared.Utils.Stats.PetUtil)
    end)
    if success4 and petUtil then
        PetUtil = petUtil
        print("âœ“ Loaded PetUtil")
    end
    
    -- Load FormatCommas for number formatting
    local success5, formatCommas = pcall(function()
        return require(RS.Shared.Framework.Utilities.String.FormatCommas)
    end)
    if success5 and formatCommas then
        FormatCommas = formatCommas
        print("âœ“ Loaded FormatCommas")
    end
end

loadModules()

-- HTTP for Delta Mobile (using the working method from testing)
local httpLib = nil
local httpLibName = nil
if request then
    httpLib = function(url, method, headers, body)
        local success, res, err = pcall(function()
            return request({Url=url, Method=method, Headers=headers or {}, Body=body})
        end)
        if success and res then
            local status = res.StatusCode or (res.Success and 200 or (res.success and 200 or 0))
            local body = res.Body or res.body or ""
            local ok = res.Success or res.success or status == 200 or status == 204
            return ok, body, status
        end
        return false, err or "Request exception", 0
    end
    httpLibName = "request"
end

-- JSON encoder (properly handles nested structures)
local function jsonEncode(t)
    local function encodeValue(v, depth)
        depth = depth or 0
        if depth > 10 then return "null" end -- Prevent infinite recursion
        
        if type(v) == "string" then
            -- Escape special characters
            v = v:gsub("\\", "\\\\")
            v = v:gsub('"', '\\"')
            v = v:gsub("\n", "\\n")
            v = v:gsub("\r", "\\r")
            v = v:gsub("\t", "\\t")
            return '"' .. v .. '"'
        elseif type(v) == "number" then
            return tostring(v)
        elseif type(v) == "boolean" then
            return v and "true" or "false"
        elseif type(v) == "table" then
            -- Check if it's an array
            local isArray = false
            local maxIndex = 0
            for k in pairs(v) do
                if type(k) == "number" then
                    maxIndex = math.max(maxIndex, k)
                end
            end
            isArray = maxIndex > 0 and maxIndex == #v
            
            local parts = {}
            if isArray then
                for i = 1, maxIndex do
                    table.insert(parts, encodeValue(v[i], depth + 1))
                end
                return "[" .. table.concat(parts, ",") .. "]"
            else
                for k, val in pairs(v) do
                    if val ~= nil then
                        local key = type(k) == "string" and ('"' .. k .. '"') or tostring(k)
                        table.insert(parts, key .. ":" .. encodeValue(val, depth + 1))
                    end
                end
                return "{" .. table.concat(parts, ",") .. "}"
            end
        else
            return "null"
        end
    end
    return encodeValue(t, 0)
end

-- Function to send webhook (with 429 retry logic) - MUST be defined first
local function sendDiscordNotificationInternal(petName, shiny, mythic, eggName, rarity, pet)
    if not httpLib or webhookURL == "" then 
        print("âœ— Cannot send: httpLib=" .. tostring(httpLib) .. ", webhookURL=" .. tostring(webhookURL))
        return true -- Return true to not retry if webhook not configured
    end
    
    -- Get player name
    local playerName = p.Name or "Unknown Player"
    
    -- Build pet name with prefix
    local fullPetName = petName
    if shiny == true and mythic == true then
        fullPetName = "Shiny Mythic " .. petName
    elseif shiny == true then
        fullPetName = "Shiny " .. petName
    elseif mythic == true then
        fullPetName = "Mythic " .. petName
    end
    
    -- Determine color based on pet type
    local embedColor = 9807270 -- Grey for normal pets (default)
    if shiny == true and mythic == true then
        embedColor = 16711680 -- Bright red for Shiny Mythic
    elseif shiny == true then
        embedColor = 16766720 -- Gold/yellow-orange for Shiny
    elseif mythic == true then
        embedColor = 10181046 -- Purple-pink for Mythic
    else
        -- Not shiny or mythic - always grey regardless of rarity
        embedColor = 9807270 -- Grey
    end
    
    -- Build mention (for Discord ping)
    local mention = discordUserID ~= "" and ("<@" .. discordUserID .. ">") or ""
    
    -- Calculate probability if PetUtil is available
    local probabilityText = nil
    if PetUtil and pet then
        local success, petChance = pcall(function()
            return PetUtil:GetChance(pet)
        end)
        if success and petChance and petChance > 0 then
            local denominator = math.ceil(100 / petChance)
            if FormatCommas then
                probabilityText = "1/" .. FormatCommas(denominator)
            else
                -- Manual formatting for large numbers
                local formatted = tostring(denominator)
                -- Add commas every 3 digits from right
                formatted = formatted:reverse():gsub("(%d%d%d)", "%1,"):reverse()
                formatted = formatted:gsub("^,", "")
                probabilityText = "1/" .. formatted
            end
        end
    end
    
    -- Determine "a" or "an" for the pet name
    -- Use "a" if shiny/mythic/shiny mythic (regardless of vowel)
    -- Use "an" if pet name starts with a vowel AND is not shiny/mythic
    -- Use "a" if pet name starts with a consonant
    local article = "a"
    if not shiny and not mythic and petName then
        local firstLetter = string.lower(string.sub(petName, 1, 1))
        if firstLetter == "a" or firstLetter == "e" or firstLetter == "i" or firstLetter == "o" or firstLetter == "u" then
            article = "an"
        end
    end
    
    -- Build description
    local description = "**" .. playerName .. "** hatched " .. article .. " **" .. fullPetName .. "**!"
    
    -- Build fields (remove Egg, conditionally include Rarity/Probability)
    local fields = {
        {
            name = "Hatched",
            value = fullPetName,
            inline = false
        }
    }
    
    -- Add probability or rarity field
    if probabilityText then
        table.insert(fields, {
            name = "Rarity",
            value = probabilityText,
            inline = true
        })
    elseif rarity then
        table.insert(fields, {
            name = "Rarity",
            value = rarity,
            inline = true
        })
    end
    
    -- Build embed (always use full format, no simplification)
    local embed = {
        title = "ðŸŽ‰ Congratulations!",
        description = description,
        color = embedColor,
        fields = fields,
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    -- Put mention in content field (required for Discord to actually ping)
    local payload = {
        content = mention ~= "" and mention or nil,
        embeds = {embed}
    }
    
    print("Sending webhook for " .. (probabilityText or rarity or "pet") .. " pet: " .. petName)
    
    local headers = {["Content-Type"] = "application/json"}
    local json = jsonEncode(payload)
    local success, response, status = httpLib(webhookURL, "POST", headers, json)
    
    if success and (status == 200 or status == 204) then
        print("âœ“ Discord notification sent! Status: " .. tostring(status))
        return true
    elseif status == 429 then
        -- Rate limited - return false to trigger retry
        print("âœ— Rate limited (429), will retry...")
        return false
    else
        print("âœ— Webhook failed!")
        print("  Status: " .. tostring(status))
        print("  Response: " .. tostring(response))
        -- For non-429 errors, return true to not retry (400 is likely permanent issue)
        return true
    end
end

-- Process webhook queue
local function processWebhookQueue()
    if isSendingWebhook or #webhookQueue == 0 or not scriptActive then
        return
    end
    
    print("Starting to process webhook queue. Items: " .. #webhookQueue)
    isSendingWebhook = true
    
    spawn(function()
        while #webhookQueue > 0 and scriptActive do
            local webhookData = table.remove(webhookQueue, 1)
            local petName = webhookData.petName
            local shiny = webhookData.shiny
            local mythic = webhookData.mythic
            local eggName = webhookData.eggName
            local rarity = webhookData.rarity
            local pet = webhookData.pet
            
            print("Processing webhook for: " .. tostring(petName))
            
            -- Try sending with retry on rate limit
            local maxRetries = 5
            local retryCount = 0
            local success = false
            
            while retryCount < maxRetries and not success do
                success = sendDiscordNotificationInternal(petName, shiny, mythic, eggName, rarity, pet)
                
                if not success then
                    retryCount = retryCount + 1
                    if retryCount < maxRetries then
                        print("Rate limited, waiting 1 second before retry " .. retryCount .. "/" .. maxRetries)
                        task.wait(1)
                    end
                end
            end
            
            -- Wait 1 second before sending next message in queue
            if #webhookQueue > 0 then
                task.wait(1)
            end
        end
        
        print("Queue processing complete")
        isSendingWebhook = false
    end)
end

-- Public function to queue webhook (handles rate limiting)
local function sendDiscordNotification(petName, shiny, mythic, eggName, rarity, pet)
    -- Don't process if script is closed
    if not scriptActive then
        return
    end
    
    print("sendDiscordNotification called for: " .. tostring(petName))
    
    if webhookURL == "" then
        print("âœ— Webhook URL not set! Cannot send notification.")
        return
    end
    
    if not httpLib then
        print("âœ— HTTP library not available! Cannot send notification.")
        return
    end
    
    -- Add to queue
    table.insert(webhookQueue, {
        petName = petName,
        shiny = shiny,
        mythic = mythic,
        eggName = eggName,
        rarity = rarity,
        pet = pet
    })
    
    print("Added to queue. Queue size: " .. #webhookQueue)
    
    -- Start processing queue if not already processing
    processWebhookQueue()
end

-- Connect to HatchEgg event
local function connectToEvents()
    if not Remote then
        print("âœ— Remote module not loaded!")
        return false
    end
    
    if not ItemUtil then
        print("âœ— ItemUtil not loaded!")
        return false
    end
    
    local success, err = pcall(function()
        hatchEventConnection = Remote.Event("HatchEgg"):Connect(function(hatchedTable)
            -- Don't process if script is closed
            if not scriptActive then
                return
            end
            
            print("=== HatchEgg Event Fired ===")
            
            if type(hatchedTable) == "table" then
                print("hatchedTable is table")
                if hatchedTable.Pets then
                    print("Pets found: " .. tostring(type(hatchedTable.Pets)))
                    local eggName = hatchedTable.Name
                    print("Egg: " .. tostring(eggName))
                    
                    for i = 1, 20 do
                        local petData = hatchedTable.Pets[i]
                        if not petData then break end
                        
                        if type(petData) == "table" and petData.Pet then
                            local pet = petData.Pet
                            local petName = pet.Name
                            local shiny = pet.Shiny == true
                            local mythic = pet.Mythic == true
                            
                            print("Pet " .. i .. ": " .. tostring(petName) .. " (Shiny: " .. tostring(shiny) .. ", Mythic: " .. tostring(mythic) .. ")")
                            
                            if petName and ItemUtil then
                                local rarity = ItemUtil:GetRarity(pet)
                                print("Rarity: " .. tostring(rarity))
                                
                                -- Check if Secret
                                if rarity == "Secret" then
                                    print(">>> SECRET DETECTED! <<<")
                                    print("Calling sendDiscordNotification...")
                                    
                                    -- Send webhook only (no in-game notifications)
                                    -- Pass the pet object so we can calculate probability
                                    sendDiscordNotification(petName, shiny, mythic, eggName, rarity, pet)
                                else
                                    print("Pet is " .. rarity .. " (not Secret, skipping)")
                                end
                            end
                        end
                    end
                else
                    print("âœ— No Pets in hatchedTable")
                end
            else
                print("âœ— hatchedTable is not a table: " .. type(hatchedTable))
            end
        end)
    end)
    
    if success then
        print("âœ“ Connected to HatchEgg events")
        return true
    else
        print("âœ— Failed to connect: " .. tostring(err))
        return false
    end
end

-- Connect after modules load
task.wait(1)
connectToEvents()

-- GUI
local g = Instance.new("ScreenGui")
g.Name = "BubblegumAutoHatch"
g.Parent = p.PlayerGui

-- Main frame
local f = Instance.new("Frame")
f.Size = UDim2.new(0, 350, 0, 240)
f.Position = UDim2.new(0.5, -175, 0.5, -120)
f.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
f.BorderSizePixel = 0
f.Parent = g

-- Title bar
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -90, 0, 40)
title.Position = UDim2.new(0, 50, 0, 0)
title.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
title.Text = "Auto Hatch & Notifier"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextSize = 16
title.Font = Enum.Font.GothamBold
title.BorderSizePixel = 0
title.Parent = f

-- Close button (top left - opens confirmation dialog)
local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 50, 0, 40)
closeBtn.Position = UDim2.new(0, 0, 0, 0)
closeBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
closeBtn.Text = "Close"
closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeBtn.TextSize = 12
closeBtn.Font = Enum.Font.GothamBold
closeBtn.BorderSizePixel = 0
closeBtn.Parent = f

-- Hide button (top right - hides GUI)
local closeXBtn = Instance.new("TextButton")
closeXBtn.Size = UDim2.new(0, 40, 0, 40)
closeXBtn.Position = UDim2.new(1, -40, 0, 0)
closeXBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
closeXBtn.Text = "X"
closeXBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeXBtn.TextSize = 24
closeXBtn.Font = Enum.Font.GothamBold
closeXBtn.BorderSizePixel = 0
closeXBtn.Parent = f

-- Confirmation dialog (initially hidden)
local confirmFrame = Instance.new("Frame")
confirmFrame.Size = UDim2.new(0, 300, 0, 150)
confirmFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
confirmFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
confirmFrame.BorderSizePixel = 2
confirmFrame.BorderColor3 = Color3.fromRGB(200, 50, 50)
confirmFrame.Visible = false
confirmFrame.ZIndex = 10
confirmFrame.Parent = g

local confirmTitle = Instance.new("TextLabel")
confirmTitle.Size = UDim2.new(1, 0, 0, 40)
confirmTitle.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
confirmTitle.Text = "Close Script?"
confirmTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmTitle.TextSize = 16
confirmTitle.Font = Enum.Font.GothamBold
confirmTitle.BorderSizePixel = 0
confirmTitle.ZIndex = 11
confirmTitle.Parent = confirmFrame

local confirmText = Instance.new("TextLabel")
confirmText.Size = UDim2.new(0, 280, 0, 50)
confirmText.Position = UDim2.new(0, 10, 0, 45)
confirmText.BackgroundTransparency = 1
confirmText.Text = "Are you sure you want to close the script?\nAll functionality will stop."
confirmText.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmText.TextSize = 12
confirmText.Font = Enum.Font.Gotham
confirmText.TextWrapped = true
confirmText.ZIndex = 11
confirmText.Parent = confirmFrame

local yesBtn = Instance.new("TextButton")
yesBtn.Size = UDim2.new(0, 120, 0, 35)
yesBtn.Position = UDim2.new(0, 20, 1, -50)
yesBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
yesBtn.Text = "Yes, Close"
yesBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
yesBtn.TextSize = 12
yesBtn.Font = Enum.Font.GothamBold
yesBtn.BorderSizePixel = 0
yesBtn.ZIndex = 11
yesBtn.Parent = confirmFrame

local noBtn = Instance.new("TextButton")
noBtn.Size = UDim2.new(0, 120, 0, 35)
noBtn.Position = UDim2.new(1, -140, 1, -50)
noBtn.BackgroundColor3 = Color3.fromRGB(80, 140, 80)
noBtn.Text = "No, Cancel"
noBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
noBtn.TextSize = 12
noBtn.Font = Enum.Font.GothamBold
noBtn.BorderSizePixel = 0
noBtn.ZIndex = 11
noBtn.Parent = confirmFrame

-- Auto Hatch button
local autoHatchBtn = Instance.new("TextButton")
autoHatchBtn.Size = UDim2.new(0, 320, 0, 45)
autoHatchBtn.Position = UDim2.new(0, 15, 0, 55)
autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
autoHatchBtn.Text = "Auto Hatch: OFF"
autoHatchBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
autoHatchBtn.TextSize = 14
autoHatchBtn.Font = Enum.Font.GothamBold
autoHatchBtn.BorderSizePixel = 0
autoHatchBtn.Parent = f

-- Webhook URL label
local webhookLabel = Instance.new("TextLabel")
webhookLabel.Size = UDim2.new(0, 320, 0, 20)
webhookLabel.Position = UDim2.new(0, 15, 0, 110)
webhookLabel.BackgroundTransparency = 1
webhookLabel.Text = "Discord Webhook URL:"
webhookLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
webhookLabel.TextSize = 11
webhookLabel.Font = Enum.Font.Gotham
webhookLabel.TextXAlignment = Enum.TextXAlignment.Left
webhookLabel.Parent = f

-- Webhook URL input
local webhookInput = Instance.new("TextBox")
webhookInput.Size = UDim2.new(0, 320, 0, 30)
webhookInput.Position = UDim2.new(0, 15, 0, 130)
webhookInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
webhookInput.TextColor3 = Color3.fromRGB(255, 255, 255)
webhookInput.Text = ""
webhookInput.PlaceholderText = "https://discord.com/api/webhooks/..."
webhookInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
webhookInput.TextSize = 10
webhookInput.Font = Enum.Font.Gotham
webhookInput.BorderSizePixel = 0
webhookInput.TextTruncate = Enum.TextTruncate.AtEnd
webhookInput.Parent = f

-- Discord User ID label
local userIDLabel = Instance.new("TextLabel")
userIDLabel.Size = UDim2.new(0, 320, 0, 20)
userIDLabel.Position = UDim2.new(0, 15, 0, 170)
userIDLabel.BackgroundTransparency = 1
userIDLabel.Text = "Discord User ID (optional):"
userIDLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
userIDLabel.TextSize = 11
userIDLabel.Font = Enum.Font.Gotham
userIDLabel.TextXAlignment = Enum.TextXAlignment.Left
userIDLabel.Parent = f

-- Discord User ID input
local userIDInput = Instance.new("TextBox")
userIDInput.Size = UDim2.new(0, 320, 0, 30)
userIDInput.Position = UDim2.new(0, 15, 0, 190)
userIDInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
userIDInput.TextColor3 = Color3.fromRGB(255, 255, 255)
userIDInput.Text = ""
userIDInput.PlaceholderText = "123456789012345678"
userIDInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
userIDInput.TextSize = 11
userIDInput.Font = Enum.Font.Gotham
userIDInput.BorderSizePixel = 0
userIDInput.Parent = f

-- Toggle GUI button (top right, moved up)
local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0, 50, 0, 50)
toggleBtn.Position = UDim2.new(1, -60, 0, -40)
toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
toggleBtn.Text = "GUI"
toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleBtn.TextSize = 12
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.BorderSizePixel = 0
toggleBtn.Parent = g

-- Auto Hatch functionality
autoHatchBtn.Activated:Connect(function()
    -- Don't process if script is closed
    if not scriptActive then
        return
    end
    
    autoHatchEnabled = not autoHatchEnabled
    
    if autoHatchEnabled then
        autoHatchBtn.Text = "Auto Hatch: ON"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
        
        -- Start E key spam
        spawn(function()
            while autoHatchEnabled and scriptActive do
                VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                task.wait(0.05)
                VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                task.wait(0.2)
            end
        end)
    else
        autoHatchBtn.Text = "Auto Hatch: OFF"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
end)

-- Webhook URL input handler
webhookInput.FocusLost:Connect(function(enterPressed)
    local url = webhookInput.Text:gsub("^%s*(.-)%s*$", "%1")
    webhookURL = url
    print("Webhook URL saved: " .. (url ~= "" and "SET (" .. string.sub(url, 1, 50) .. "...)" or "EMPTY"))
end)

-- Discord User ID input handler
userIDInput.FocusLost:Connect(function(enterPressed)
    local id = userIDInput.Text:gsub("^%s*(.-)%s*$", "%1")
    discordUserID = id
    print("Discord User ID saved: " .. (id ~= "" and id or "EMPTY"))
end)

-- Close button (top left) - opens confirmation dialog
closeBtn.Activated:Connect(function()
    confirmFrame.Visible = true
end)

-- Hide button (top right X) - hides GUI
closeXBtn.Activated:Connect(function()
    f.Visible = false
    if toggleBtn then
        toggleBtn.Text = ">>>"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    end
end)

-- Yes button - closes everything
yesBtn.Activated:Connect(function()
    print("Closing script...")
    
    -- Mark script as inactive (stops all processing)
    scriptActive = false
    
    -- Stop auto hatch
    autoHatchEnabled = false
    
    -- Disconnect event connection
    if hatchEventConnection then
        hatchEventConnection:Disconnect()
        hatchEventConnection = nil
        print("âœ“ Event connection disconnected")
    end
    
    -- Clear webhook queue
    webhookQueue = {}
    isSendingWebhook = false
    print("âœ“ Webhook queue cleared")
    
    -- Destroy GUI
    g:Destroy()
    print("âœ“ GUI destroyed")
    
    -- Stop script
    print("Script closed by user - all functionality stopped")
    error("Script closed")
end)

-- No button - closes confirmation dialog
noBtn.Activated:Connect(function()
    confirmFrame.Visible = false
end)

-- Toggle GUI button
toggleBtn.Activated:Connect(function()
    f.Visible = not f.Visible
    if f.Visible then
        toggleBtn.Text = "GUI"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
    else
        toggleBtn.Text = ">>>"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    end
end)

print("âœ“ GUI created")
print("Ready! Click 'Auto Hatch' to start hatching")
