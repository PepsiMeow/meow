-- BUBBLEGUM SIMULATOR - AUTO HATCH & SECRET NOTIFIER
-- Final version with auto hatch and Discord notifications

local P = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local VIM = game:GetService("VirtualInputManager")
local p = P.LocalPlayer

print("========================================")
print("BUBBLEGUM AUTO HATCH & NOTIFIER")
print("Version: 2.0")
print("========================================")

-- Load required modules
local Remote = nil
local ItemUtil = nil
local PetsData = nil

-- Settings
local autoHatchEnabled = false
local webhookURL = ""
local discordUserID = ""

-- Webhook queue for rate limiting
local webhookQueue = {}
local isSendingWebhook = false

-- Load modules
local function loadModules()
    -- Load Remote
    local success, remoteModule = pcall(function()
        return require(RS.Shared.Framework.Network.Remote)
    end)
    if success and remoteModule then
        Remote = remoteModule
        print("âœ“ Loaded Remote module")
    end
    
    -- Load ItemUtil
    local success2, itemUtil = pcall(function()
        return require(RS.Shared.Utils.Stats.ItemUtil)
    end)
    if success2 and itemUtil then
        ItemUtil = itemUtil
        print("âœ“ Loaded ItemUtil")
    end
    
    -- Load Pets data for images
    local success3, petsData = pcall(function()
        return require(RS.Shared.Data.Pets)
    end)
    if success3 and petsData then
        PetsData = petsData
        print("âœ“ Loaded Pets data")
    end
end

loadModules()

-- HTTP for Delta Mobile (using the working method from testing)
local httpLib = nil
local httpLibName = nil
if request then
    httpLib = function(url, method, headers, body)
        local success, res, err = pcall(function()
            return request({Url=url, Method=method, Headers=headers or {}, Body=body})
        end)
        if success and res then
            local status = res.StatusCode or (res.Success and 200 or (res.success and 200 or 0))
            local body = res.Body or res.body or ""
            local ok = res.Success or res.success or status == 200 or status == 204
            return ok, body, status
        end
        return false, err or "Request exception", 0
    end
    httpLibName = "request"
end

-- JSON encoder (properly handles nested structures)
local function jsonEncode(t)
    local function encodeValue(v, depth)
        depth = depth or 0
        if depth > 10 then return "null" end -- Prevent infinite recursion
        
        if type(v) == "string" then
            -- Escape special characters
            v = v:gsub("\\", "\\\\")
            v = v:gsub('"', '\\"')
            v = v:gsub("\n", "\\n")
            v = v:gsub("\r", "\\r")
            v = v:gsub("\t", "\\t")
            return '"' .. v .. '"'
        elseif type(v) == "number" then
            return tostring(v)
        elseif type(v) == "boolean" then
            return v and "true" or "false"
        elseif type(v) == "table" then
            -- Check if it's an array
            local isArray = false
            local maxIndex = 0
            for k in pairs(v) do
                if type(k) == "number" then
                    maxIndex = math.max(maxIndex, k)
                end
            end
            isArray = maxIndex > 0 and maxIndex == #v
            
            local parts = {}
            if isArray then
                for i = 1, maxIndex do
                    table.insert(parts, encodeValue(v[i], depth + 1))
                end
                return "[" .. table.concat(parts, ",") .. "]"
            else
                for k, val in pairs(v) do
                    if val ~= nil then
                        local key = type(k) == "string" and ('"' .. k .. '"') or tostring(k)
                        table.insert(parts, key .. ":" .. encodeValue(val, depth + 1))
                    end
                end
                return "{" .. table.concat(parts, ",") .. "}"
            end
        else
            return "null"
        end
    end
    return encodeValue(t, 0)
end

-- Get pet image
local function getPetImage(pet, shiny, mythic)
    if not PetsData or not pet then return nil end
    
    local petData = PetsData[pet]
    if not petData or not petData.Images then return nil end
    
    local imageType = "Normal"
    if shiny and mythic then
        imageType = "MythicShiny"
    elseif shiny then
        imageType = "Shiny"
    elseif mythic then
        imageType = "Mythic"
    end
    
    return petData.Images[imageType] or petData.Images.Normal
end

-- Process webhook queue
local function processWebhookQueue()
    if isSendingWebhook or #webhookQueue == 0 then
        return
    end
    
    isSendingWebhook = true
    
    spawn(function()
        while #webhookQueue > 0 do
            local webhookData = table.remove(webhookQueue, 1)
            local petName = webhookData.petName
            local shiny = webhookData.shiny
            local mythic = webhookData.mythic
            local eggName = webhookData.eggName
            local rarity = webhookData.rarity
            
            -- Try sending with retry on rate limit
            local maxRetries = 5
            local retryCount = 0
            local success = false
            
            while retryCount < maxRetries and not success do
                success = sendDiscordNotificationInternal(petName, shiny, mythic, eggName, rarity)
                
                if not success then
                    retryCount = retryCount + 1
                    if retryCount < maxRetries then
                        print("Rate limited, waiting 1 second before retry " .. retryCount .. "/" .. maxRetries)
                        task.wait(1)
                    end
                end
            end
            
            -- Wait 1 second before sending next message in queue
            if #webhookQueue > 0 then
                task.wait(1)
            end
        end
        
        isSendingWebhook = false
    end)
end

-- Internal function to send webhook (returns true if successful, false if rate limited)
local function sendDiscordNotificationInternal(petName, shiny, mythic, eggName, rarity)
    if not httpLib or webhookURL == "" then 
        print("âœ— Cannot send: httpLib=" .. tostring(httpLib) .. ", webhookURL=" .. tostring(webhookURL))
        return true -- Return true to not retry if webhook not configured
    end
    
    -- Get player name
    local playerName = p.Name or "Unknown Player"
    
    -- Build pet name with prefix
    local fullPetName = petName
    if shiny and mythic then
        fullPetName = "Shiny Mythic " .. petName
    elseif shiny then
        fullPetName = "Shiny " .. petName
    elseif mythic then
        fullPetName = "Mythic " .. petName
    end
    
    -- Get pet image
    local petImage = getPetImage(petName, shiny, mythic)
    
    -- Determine color based on pet type (check shiny/mythic first, then rarity)
    local embedColor = 9807270 -- Grey for normal pets (default)
    
    -- Priority: Shiny Mythic > Shiny > Mythic > Rarity
    if shiny == true and mythic == true then
        embedColor = 16711680 -- Bright red for Shiny Mythic
    elseif shiny == true then
        embedColor = 16766720 -- Gold/yellow-orange for Shiny
    elseif mythic == true then
        embedColor = 10181046 -- Purple-pink for Mythic
    else
        -- Not shiny or mythic - always grey regardless of rarity
        embedColor = 9807270 -- Grey
    end
    
    -- Build mention (for Discord ping)
    local mention = discordUserID ~= "" and ("<@" .. discordUserID .. ">") or ""
    
    -- Build embed (always use full format, no simplification)
    local embed = {
        title = "ðŸŽ‰ Congratulations!",
        description = "**" .. playerName .. "** hatched **" .. fullPetName .. "**!",
        color = embedColor,
        fields = {
            {
                name = "Hatched",
                value = fullPetName,
                inline = false
            },
            {
                name = "Rarity",
                value = rarity,
                inline = true
            },
            {
                name = "Egg",
                value = eggName or "Unknown",
                inline = true
            }
        },
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    -- Don't add thumbnail - Discord doesn't accept Roblox asset URLs directly
    -- Images would need to be hosted externally or converted to a format Discord accepts
    -- For now, we'll skip thumbnails to avoid 400 errors
    
    -- Put mention in content field (required for Discord to actually ping)
    local payload = {
        content = mention ~= "" and mention or nil,
        embeds = {embed}
    }
    
    print("Sending webhook for " .. rarity .. " pet: " .. petName)
    
    local headers = {["Content-Type"] = "application/json"}
    local json = jsonEncode(payload)
    local success, response, status = httpLib(webhookURL, "POST", headers, json)
    
    if success and (status == 200 or status == 204) then
        print("âœ“ Discord notification sent! Status: " .. tostring(status))
        return true
    elseif status == 429 then
        -- Rate limited - return false to trigger retry
        print("âœ— Rate limited (429), will retry...")
        return false
    else
        print("âœ— Webhook failed!")
        print("  Status: " .. tostring(status))
        print("  Response: " .. tostring(response))
        -- For non-429 errors, return true to not retry (400 is likely permanent issue)
        return true
    end
end

-- Public function to queue webhook (handles rate limiting)
local function sendDiscordNotification(petName, shiny, mythic, eggName, rarity)
    -- Add to queue
    table.insert(webhookQueue, {
        petName = petName,
        shiny = shiny,
        mythic = mythic,
        eggName = eggName,
        rarity = rarity
    })
    
    -- Start processing queue if not already processing
    processWebhookQueue()
end

-- Track recent notifications to prevent duplicates
local recentNotifications = {}
local notificationCooldown = 2 -- seconds

-- Send in-game notification (with deduplication)
local function sendInGameNotification(petName, shiny, mythic, rarity)
    -- Create unique key for this pet
    local key = petName .. "_" .. tostring(shiny) .. "_" .. tostring(mythic) .. "_" .. rarity
    local currentTime = tick()
    
    -- Check if we've sent this notification recently
    if recentNotifications[key] and (currentTime - recentNotifications[key]) < notificationCooldown then
        print("Skipping duplicate notification for: " .. key)
        return
    end
    
    -- Mark as sent
    recentNotifications[key] = currentTime
    
    -- Clean old entries (older than cooldown)
    for k, v in pairs(recentNotifications) do
        if currentTime - v > notificationCooldown then
            recentNotifications[k] = nil
        end
    end
    
    local prefix = ""
    if shiny and mythic then
        prefix = "Shiny Mythic "
    elseif shiny then
        prefix = "Shiny "
    elseif mythic then
        prefix = "Mythic "
    end
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "ðŸŽ‰ " .. rarity .. " Pet Hatched!",
        Text = prefix .. petName,
        Duration = 5,
        Button1 = "OK"
    })
end

-- Connect to HatchEgg event
local function connectToEvents()
    if not Remote then
        print("âœ— Remote module not loaded!")
        if statusLabel then
            statusLabel.Text = "Status: ERROR - Remote module not loaded!"
            statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        end
        return false
    end
    
    if not ItemUtil then
        print("âœ— ItemUtil not loaded!")
        if statusLabel then
            statusLabel.Text = "Status: ERROR - ItemUtil not loaded!"
            statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        end
        return false
    end
    
    local success, err = pcall(function()
        Remote.Event("HatchEgg"):Connect(function(hatchedTable)
            print("=== HatchEgg Event Fired ===")
            
            if type(hatchedTable) == "table" then
                print("hatchedTable is table")
                if hatchedTable.Pets then
                    print("Pets found: " .. tostring(type(hatchedTable.Pets)))
                    local eggName = hatchedTable.Name
                    print("Egg: " .. tostring(eggName))
                    
                    for i = 1, 20 do
                        local petData = hatchedTable.Pets[i]
                        if not petData then break end
                        
                        if type(petData) == "table" and petData.Pet then
                            local pet = petData.Pet
                            local petName = pet.Name
                            local shiny = pet.Shiny == true
                            local mythic = pet.Mythic == true
                            
                            print("Pet " .. i .. ": " .. tostring(petName) .. " (Shiny: " .. tostring(shiny) .. ", Mythic: " .. tostring(mythic) .. ")")
                            
                            if petName and ItemUtil then
                                local rarity = ItemUtil:GetRarity(pet)
                                print("Rarity: " .. tostring(rarity))
                                
                                -- Check if Legendary or Secret
                                if rarity == "Legendary" or rarity == "Secret" then
                                    print(">>> " .. rarity .. " DETECTED! <<<")
                                    
                                    -- Send webhook only (no in-game notifications)
                                    sendDiscordNotification(petName, shiny, mythic, eggName, rarity)
                                end
                            end
                        end
                    end
                else
                    print("âœ— No Pets in hatchedTable")
                end
            else
                print("âœ— hatchedTable is not a table: " .. type(hatchedTable))
            end
        end)
    end)
    
    if success then
        print("âœ“ Connected to HatchEgg events")
        return true
    else
        print("âœ— Failed to connect: " .. tostring(err))
        return false
    end
end

-- Connect after modules load
task.wait(1)
connectToEvents()

-- GUI
local g = Instance.new("ScreenGui")
g.Name = "BubblegumAutoHatch"
g.Parent = p.PlayerGui

-- Main frame
local f = Instance.new("Frame")
f.Size = UDim2.new(0, 350, 0, 240)
f.Position = UDim2.new(0.5, -175, 0.5, -120)
f.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
f.BorderSizePixel = 0
f.Parent = g

-- Title bar
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -50, 0, 40)
title.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
title.Text = "Auto Hatch & Notifier v2"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextSize = 16
title.Font = Enum.Font.GothamBold
title.BorderSizePixel = 0
title.Parent = f

-- Close button (red X)
local closeXBtn = Instance.new("TextButton")
closeXBtn.Size = UDim2.new(0, 40, 0, 40)
closeXBtn.Position = UDim2.new(1, -40, 0, 0)
closeXBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeXBtn.Text = "X"
closeXBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeXBtn.TextSize = 24
closeXBtn.Font = Enum.Font.GothamBold
closeXBtn.BorderSizePixel = 0
closeXBtn.Parent = f

-- Confirmation dialog (initially hidden)
local confirmFrame = Instance.new("Frame")
confirmFrame.Size = UDim2.new(0, 300, 0, 150)
confirmFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
confirmFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
confirmFrame.BorderSizePixel = 2
confirmFrame.BorderColor3 = Color3.fromRGB(200, 50, 50)
confirmFrame.Visible = false
confirmFrame.ZIndex = 10
confirmFrame.Parent = g

local confirmTitle = Instance.new("TextLabel")
confirmTitle.Size = UDim2.new(1, 0, 0, 40)
confirmTitle.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
confirmTitle.Text = "Close Script?"
confirmTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmTitle.TextSize = 16
confirmTitle.Font = Enum.Font.GothamBold
confirmTitle.BorderSizePixel = 0
confirmTitle.ZIndex = 11
confirmTitle.Parent = confirmFrame

local confirmText = Instance.new("TextLabel")
confirmText.Size = UDim2.new(0, 280, 0, 50)
confirmText.Position = UDim2.new(0, 10, 0, 45)
confirmText.BackgroundTransparency = 1
confirmText.Text = "Are you sure you want to close the script?\nAll functionality will stop."
confirmText.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmText.TextSize = 12
confirmText.Font = Enum.Font.Gotham
confirmText.TextWrapped = true
confirmText.ZIndex = 11
confirmText.Parent = confirmFrame

local yesBtn = Instance.new("TextButton")
yesBtn.Size = UDim2.new(0, 120, 0, 35)
yesBtn.Position = UDim2.new(0, 20, 1, -50)
yesBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
yesBtn.Text = "Yes, Close"
yesBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
yesBtn.TextSize = 12
yesBtn.Font = Enum.Font.GothamBold
yesBtn.BorderSizePixel = 0
yesBtn.ZIndex = 11
yesBtn.Parent = confirmFrame

local noBtn = Instance.new("TextButton")
noBtn.Size = UDim2.new(0, 120, 0, 35)
noBtn.Position = UDim2.new(1, -140, 1, -50)
noBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
noBtn.Text = "No, Cancel"
noBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
noBtn.TextSize = 12
noBtn.Font = Enum.Font.GothamBold
noBtn.BorderSizePixel = 0
noBtn.ZIndex = 11
noBtn.Parent = confirmFrame

-- Auto Hatch button
local autoHatchBtn = Instance.new("TextButton")
autoHatchBtn.Size = UDim2.new(0, 320, 0, 45)
autoHatchBtn.Position = UDim2.new(0, 15, 0, 55)
autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
autoHatchBtn.Text = "Auto Hatch: OFF"
autoHatchBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
autoHatchBtn.TextSize = 14
autoHatchBtn.Font = Enum.Font.GothamBold
autoHatchBtn.BorderSizePixel = 0
autoHatchBtn.Parent = f

-- Webhook URL label
local webhookLabel = Instance.new("TextLabel")
webhookLabel.Size = UDim2.new(0, 320, 0, 20)
webhookLabel.Position = UDim2.new(0, 15, 0, 110)
webhookLabel.BackgroundTransparency = 1
webhookLabel.Text = "Discord Webhook URL:"
webhookLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
webhookLabel.TextSize = 11
webhookLabel.Font = Enum.Font.Gotham
webhookLabel.TextXAlignment = Enum.TextXAlignment.Left
webhookLabel.Parent = f

-- Webhook URL input
local webhookInput = Instance.new("TextBox")
webhookInput.Size = UDim2.new(0, 320, 0, 30)
webhookInput.Position = UDim2.new(0, 15, 0, 130)
webhookInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
webhookInput.TextColor3 = Color3.fromRGB(255, 255, 255)
webhookInput.Text = ""
webhookInput.PlaceholderText = "https://discord.com/api/webhooks/..."
webhookInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
webhookInput.TextSize = 10
webhookInput.Font = Enum.Font.Gotham
webhookInput.BorderSizePixel = 0
webhookInput.TextTruncate = Enum.TextTruncate.AtEnd
webhookInput.Parent = f

-- Discord User ID label
local userIDLabel = Instance.new("TextLabel")
userIDLabel.Size = UDim2.new(0, 320, 0, 20)
userIDLabel.Position = UDim2.new(0, 15, 0, 170)
userIDLabel.BackgroundTransparency = 1
userIDLabel.Text = "Discord User ID (optional):"
userIDLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
userIDLabel.TextSize = 11
userIDLabel.Font = Enum.Font.Gotham
userIDLabel.TextXAlignment = Enum.TextXAlignment.Left
userIDLabel.Parent = f

-- Discord User ID input
local userIDInput = Instance.new("TextBox")
userIDInput.Size = UDim2.new(0, 320, 0, 30)
userIDInput.Position = UDim2.new(0, 15, 0, 190)
userIDInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
userIDInput.TextColor3 = Color3.fromRGB(255, 255, 255)
userIDInput.Text = ""
userIDInput.PlaceholderText = "123456789012345678"
userIDInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
userIDInput.TextSize = 11
userIDInput.Font = Enum.Font.Gotham
userIDInput.BorderSizePixel = 0
userIDInput.Parent = f

-- Status label (hidden, used for internal status tracking)
local statusLabel = nil


-- Toggle GUI button (top right, moved up)
local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0, 50, 0, 50)
toggleBtn.Position = UDim2.new(1, -60, 0, -40)
toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
toggleBtn.Text = "GUI"
toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleBtn.TextSize = 12
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.BorderSizePixel = 0
toggleBtn.Parent = g

-- Auto Hatch functionality
autoHatchBtn.Activated:Connect(function()
    autoHatchEnabled = not autoHatchEnabled
    
    if autoHatchEnabled then
        autoHatchBtn.Text = "Auto Hatch: ON"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
        
        -- Start E key spam
        spawn(function()
            while autoHatchEnabled do
                VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                task.wait(0.05)
                VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                task.wait(0.2)
            end
        end)
    else
        autoHatchBtn.Text = "Auto Hatch: OFF"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
end)

-- Webhook URL input handler
webhookInput.FocusLost:Connect(function(enterPressed)
    local url = webhookInput.Text:gsub("^%s*(.-)%s*$", "%1")
    webhookURL = url
end)

-- Discord User ID input handler
userIDInput.FocusLost:Connect(function(enterPressed)
    local id = userIDInput.Text:gsub("^%s*(.-)%s*$", "%1")
    discordUserID = id
end)

-- Close X button - opens confirmation dialog
closeXBtn.Activated:Connect(function()
    confirmFrame.Visible = true
end)

-- Yes button - closes everything
yesBtn.Activated:Connect(function()
    -- Stop auto hatch
    autoHatchEnabled = false
    
    -- Destroy GUI
    g:Destroy()
    
    -- Stop script
    print("Script closed by user")
    error("Script closed")
end)

-- No button - closes confirmation dialog
noBtn.Activated:Connect(function()
    confirmFrame.Visible = false
end)

-- Toggle GUI button
toggleBtn.Activated:Connect(function()
    f.Visible = not f.Visible
    if f.Visible then
        toggleBtn.Text = "GUI"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
    else
        toggleBtn.Text = ">>>"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    end
end)

print("âœ“ GUI created")
print("Ready! Click 'Auto Hatch' to start hatching")

