-- ============================================================================
-- BUBBLEGUM SIMULATOR - AUTO HATCH & SECRET NOTIFIER
-- Version 5.0 - Modular, Optimized, Refactored
-- ============================================================================

--[[
    MODULAR ARCHITECTURE:
    - Config: Constants, special pets, rift definitions
    - Services: Game service references
    - SettingsManager: Load/save settings
    - ModuleLoader: Game module loading
    - HTTPClient: Webhook queue and sending
    - PetDetector: Pet detection and notification logic
    - RiftManager: Rift detection and teleportation
    - AutoHatch: Auto-hatch functionality
    - EggMonitor: Egg count monitoring
    - PlayerTracker: Player tracking
    - ChatMonitor: Chat monitoring
    - GUIManager: GUI creation and management
    - Main: Orchestrator
]]

-- ============================================================================
-- SECTION 1: CONFIGURATION & CONSTANTS
-- ============================================================================

local Config = {
    VERSION = "5.0",
    SETTINGS_FILE = "bubblegum_settings.json",
    
    -- Special pets that receive special notification treatment
    SPECIAL_PETS = {
        "Morning Star",
        "Christmas Robot",
        "Rumblecon God",
        "The Leviathan",
        "Sylently's Pet",
        "Giant Nert's Pufferfish"
    },
    
    -- Available rifts
    AVAILABLE_RIFTS = {
        {name = "peppermint-chest", displayName = "Peppermint Chest", category = "Chest"},
        {name = "gingerbread-egg", displayName = "Gingerbread Egg", category = "Egg"},
        {name = "candycane-egg", displayName = "Candycane Egg", category = "Egg"},
        {name = "yuletide-egg", displayName = "Yuletide Egg", category = "Egg"},
        {name = "northpole-egg", displayName = "Northpole Egg", category = "Egg"},
        {name = "aurora-egg", displayName = "Aurora Egg", category = "Egg"},
        {name = "festive-egg", displayName = "Festive Egg", category = "Egg"},
        {name = "2026-egg", displayName = "2026 Egg", category = "Egg"}
    },
    
    -- Default settings
    DEFAULTS = {
        autoHatchEnabled = false,
        webhookURL = "",
        discordUserID = "",
        playerTrackingEnabled = true,
        eggCountMonitoringEnabled = true,
        eggMonitorIntervalHours = 1,
        secretNotifyNormal = true,
        secretNotifyShiny = false,
        secretNotifyMythic = false,
        secretNotifyShinyMythic = false,
        secretNotifyXL = false,
        secretPingNormal = false,
        secretPingShiny = false,
        secretPingMythic = false,
        secretPingShinyMythic = false,
        secretPingXL = false,
        secretFilterUnder1B = false,
        infinityNotifyEnabled = true,
        infinityPingEnabled = true,
        xlDetectionEnabled = false,
        xlPingEnabled = false,
        legendaryDetectionEnabled = false,
        legendaryPingEnabled = false,
        riftPingEnabled = false,
        riftSelections = {
            ["peppermint-chest"] = true,
            ["gingerbread-egg"] = true,
            ["candycane-egg"] = true,
            ["yuletide-egg"] = true,
            ["northpole-egg"] = true,
            ["aurora-egg"] = true,
            ["festive-egg"] = true,
            ["2026-egg"] = true
        }
    },
    
    -- Webhook rate limiting
    WEBHOOK_RATE_LIMIT = {
        INITIAL_DELAY = 2, -- seconds after first 5 messages
        NORMAL_DELAY = 1, -- seconds for subsequent messages
        INITIAL_COUNT = 5, -- number of messages with initial delay
        MAX_RETRIES = 5 -- retry attempts for failed requests
    },
    
    -- Rift settings
    RIFT = {
        HEIGHT_OFFSET = 15, -- studs above rift
        DEFAULT_DURATION = 600, -- 10 minutes
        TELEPORT_DELAY = 0.1, -- seconds before re-enabling collision
        RETURN_DELAY = 0.5 -- seconds before resetting state after return
    },
    
    -- GUI settings
    GUI = {
        WIDTH = 400,
        HEIGHT = 360,
        CORNER_RADIUS = 8,
        BUTTON_HEIGHT = 30,
        TAB_HEIGHT = 35
    }
}

-- Pre-compute special pets lookup for O(1) access
local SPECIAL_PETS_LOWER = {}
for _, petName in ipairs(Config.SPECIAL_PETS) do
    SPECIAL_PETS_LOWER[string.lower(petName)] = true
end

-- ============================================================================
-- SECTION 2: SERVICES
-- ============================================================================

local Services = {
    Players = game:GetService("Players"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    UserInputService = game:GetService("UserInputService"),
    VirtualInputManager = game:GetService("VirtualInputManager"),
    HttpService = game:GetService("HttpService"),
    TextChatService = game:GetService("TextChatService"),
    RunService = game:GetService("RunService")
}

local LocalPlayer = Services.Players.LocalPlayer

-- ============================================================================
-- SECTION 3: UTILITY FUNCTIONS
-- ============================================================================

local Utils = {}

-- Format number with commas
function Utils.FormatNumber(num)
    if not num then return "0" end
    return tostring(num):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")
end

-- Check if pet is special
function Utils.IsSpecialPet(petName)
    if not petName then return false end
    return SPECIAL_PETS_LOWER[string.lower(petName)] == true
end

-- Get variant name from flags
function Utils.GetVariantName(shiny, mythic, xl)
    local parts = {}
    if shiny and mythic then
        table.insert(parts, "Shiny Mythic")
    elseif shiny then
        table.insert(parts, "Shiny")
    elseif mythic then
        table.insert(parts, "Mythic")
    end
    if xl then
        table.insert(parts, "XL")
    end
    return table.concat(parts, " ")
end

-- Get variant hierarchy value for sorting
function Utils.GetVariantHierarchy(shiny, mythic, xl)
    if shiny and mythic and xl then return 8 end
    if mythic and xl then return 7 end
    if shiny and xl then return 6 end
    if xl then return 5 end
    if shiny and mythic then return 4 end
    if mythic then return 3 end
    if shiny then return 2 end
    return 1
end

-- Safe JSON encode/decode
function Utils.JSONEncode(data)
    if Services.HttpService and Services.HttpService.JSONEncode then
        return Services.HttpService:JSONEncode(data)
    end
    return nil
end

function Utils.JSONDecode(json)
    if Services.HttpService and Services.HttpService.JSONDecode then
        local success, result = pcall(function()
            return Services.HttpService:JSONDecode(json)
        end)
        return success and result or nil
    end
    return nil
end

-- Safe file operations
function Utils.ReadFile(path)
    if readfile then
        local success, content = pcall(readfile, path)
        return success and content or nil
    end
    return nil
end

function Utils.WriteFile(path, content)
    if writefile then
        local success = pcall(writefile, path, content)
        return success
    end
    return false
end

function Utils.FileExists(path)
    if isfile then
        return isfile(path)
    end
    return false
end

-- ============================================================================
-- SECTION 4: MODULE LOADER
-- ============================================================================

local ModuleLoader = {
    modules = {},
    loaded = false
}

function ModuleLoader.Load()
    if ModuleLoader.loaded then return ModuleLoader.modules end
    
    local modules = {}
    local moduleNames = {"Remote", "ItemUtil", "PetsData", "PetUtil", "FormatCommas", "LocalData"}
    
    for _, name in ipairs(moduleNames) do
        local success, module = pcall(function()
            return Services.ReplicatedStorage:WaitForChild(name, 5)
        end)
        
        if success and module then
            modules[name] = module
        else
            warn("âš  Failed to load module: " .. name)
        end
    end
    
    ModuleLoader.modules = modules
    ModuleLoader.loaded = true
    return modules
end

function ModuleLoader.Get(name)
    return ModuleLoader.modules[name]
end

-- ============================================================================
-- SECTION 5: HTTP CLIENT
-- ============================================================================

local HTTPClient = {
    httpLib = nil,
    httpLibName = nil,
    queue = {},
    isProcessing = false,
    rateLimitCounter = Config.WEBHOOK_RATE_LIMIT.INITIAL_COUNT,
    thumbnailCache = {}
}

-- Initialize HTTP library (mobile/Delta compatible)
function HTTPClient.Init()
    if request then
        -- Delta Mobile
        HTTPClient.httpLib = function(url, method, headers, body)
            local success, res, err = pcall(function()
                return request({Url = url, Method = method, Headers = headers or {}, Body = body})
            end)
            if success and res then
                local status = res.StatusCode or (res.Success and 200 or (res.success and 200 or 0))
                local body = res.Body or res.body or ""
                local ok = res.Success or res.success or status == 200 or status == 204
                return ok, body, status
            end
            return false, err or "Request exception", 0
        end
        HTTPClient.httpLibName = "request"
    elseif syn and syn.request then
        -- Synapse
        HTTPClient.httpLib = function(url, method, headers, body)
            local success, res = pcall(function()
                return syn.request({Url = url, Method = method, Headers = headers or {}, Body = body})
            end)
            if success and res then
                return res.Success or res.StatusCode == 200, res.Body or "", res.StatusCode or 0
            end
            return false, "Request failed", 0
        end
        HTTPClient.httpLibName = "syn.request"
    elseif http and http.request then
        -- Standard http
        HTTPClient.httpLib = function(url, method, headers, body)
            local success, res = pcall(function()
                return http.request({Url = url, Method = method, Headers = headers or {}, Body = body})
            end)
            if success and res then
                return res.Success or res.StatusCode == 200, res.Body or "", res.StatusCode or 0
            end
            return false, "Request failed", 0
        end
        HTTPClient.httpLibName = "http.request"
    end
    
    if HTTPClient.httpLib then
        print("âœ“ HTTP library initialized: " .. (HTTPClient.httpLibName or "unknown"))
    else
        warn("âš  No HTTP library available - webhooks will not work")
    end
end

-- Get thumbnail URL with caching
function HTTPClient.GetThumbnailUrl(assetId)
    if not assetId then return nil end
    if HTTPClient.thumbnailCache[assetId] then
        return HTTPClient.thumbnailCache[assetId]
    end
    
    local url = "https://thumbnails.roproxy.com/v1/assets?assetIds=" .. assetId .. "&size=420x420&format=Png&isCircular=false"
    
    if not HTTPClient.httpLib then return nil end
    
    local success, response = pcall(function()
        local ok, body, status = HTTPClient.httpLib(url, "GET", {}, "")
        return ok and status == 200 and body or nil
    end)
    
    if not success or not response then return nil end
    
    local decoded = Utils.JSONDecode(response)
    if decoded and decoded.data and decoded.data[1] and decoded.data[1].imageUrl then
        HTTPClient.thumbnailCache[assetId] = decoded.data[1].imageUrl
        return decoded.data[1].imageUrl
    end
    
    return nil
end

-- Send webhook request
function HTTPClient.SendRequest(webhookURL, payload, retries)
    if not HTTPClient.httpLib or not webhookURL or webhookURL == "" then
        return false, "No HTTP library or webhook URL"
    end
    
    retries = retries or Config.WEBHOOK_RATE_LIMIT.MAX_RETRIES
    local json = Utils.JSONEncode(payload)
    if not json then return false, "JSON encode failed" end
    
    for attempt = 1, retries do
        local ok, response, status = HTTPClient.httpLib(webhookURL, "POST", {
            ["Content-Type"] = "application/json"
        }, json)
        
        if ok and (status == 200 or status == 204) then
            return true, response, status
        elseif status == 429 then
            -- Rate limited - wait and retry
            if attempt < retries then
                task.wait(1)
            end
        else
            -- Other error - don't retry
            return false, response or "Request failed", status or 0
        end
    end
    
    return false, "Max retries exceeded", 0
end

-- Queue webhook message
function HTTPClient.Queue(data)
    table.insert(HTTPClient.queue, data)
    HTTPClient.ProcessQueue()
end

-- ProcessWebhookItem and ProcessQueue are defined later in WebhookFormatter section

-- ============================================================================
-- SECTION 6: SETTINGS MANAGER
-- ============================================================================

local SettingsManager = {
    settings = {},
    initialized = false
}

-- Initialize settings with defaults
function SettingsManager.Init()
    if SettingsManager.initialized then return end
    
    -- Copy defaults
    for key, value in pairs(Config.DEFAULTS) do
        SettingsManager.settings[key] = value
    end
    
    SettingsManager.Load()
    SettingsManager.initialized = true
end

-- Load settings from file
function SettingsManager.Load()
    if not Utils.FileExists(Config.SETTINGS_FILE) then
        print("â„¹ No settings file found, using defaults")
        return false
    end
    
    local content = Utils.ReadFile(Config.SETTINGS_FILE)
    if not content then
        warn("âš  Failed to read settings file")
        return false
    end
    
    local decoded = Utils.JSONDecode(content)
    if not decoded then
        warn("âš  Failed to decode settings file")
        return false
    end
    
    -- Merge loaded settings with defaults
    for key, value in pairs(decoded) do
        if Config.DEFAULTS[key] ~= nil then
            SettingsManager.settings[key] = value
        end
    end
    
    print("âœ“ Settings loaded from file")
    return true
end

-- Save settings to file
function SettingsManager.Save()
    local json = Utils.JSONEncode(SettingsManager.settings)
    if not json then
        warn("âš  Failed to encode settings")
        return false
    end
    
    local success = Utils.WriteFile(Config.SETTINGS_FILE, json)
    if success then
        print("âœ“ Settings saved")
    else
        warn("âš  Failed to write settings file")
    end
    
    return success
end

-- Get setting value
function SettingsManager.Get(key)
    return SettingsManager.settings[key]
end

-- Set setting value
function SettingsManager.Set(key, value)
    SettingsManager.settings[key] = value
end

-- Get all settings (for debugging)
function SettingsManager.GetAll()
    return SettingsManager.settings
end

-- ============================================================================
-- SECTION 7: STATE MANAGER
-- ============================================================================

local StateManager = {
    scriptActive = true,
    autoHatchEnabled = false,
    riftAutoTeleportEnabled = false, -- NOT saved, always defaults to false
    isAtRift = false,
    returningFromRift = false,
    currentRift = nil,
    storedPosition = nil,
    riftStartTime = nil,
    riftStartEggCount = nil,
    riftHatchedPets = {},
    adminAbuseActive = false,
    adminAbusePets = {},
    adminAbuseStartEggCount = nil
}

function StateManager.Reset()
    StateManager.scriptActive = true
    StateManager.autoHatchEnabled = false
    StateManager.riftAutoTeleportEnabled = false
    StateManager.isAtRift = false
    StateManager.returningFromRift = false
    StateManager.currentRift = nil
    StateManager.storedPosition = nil
    StateManager.riftStartTime = nil
    StateManager.riftStartEggCount = nil
    StateManager.riftHatchedPets = {}
    StateManager.adminAbuseActive = false
    StateManager.adminAbusePets = {}
    StateManager.adminAbuseStartEggCount = nil
end

-- ============================================================================
-- INITIALIZATION
-- ============================================================================

print("========================================")
print("BUBBLEGUM AUTO HATCH & NOTIFIER")
print("Version: " .. Config.VERSION)
print("========================================")
print("âœ“ Script started - if you see this, script is running")

-- ============================================================================
-- SECTION 8: EGG COUNT HELPER
-- ============================================================================

local EggHelper = {}

function EggHelper.GetTotalHatched()
    local LocalData = ModuleLoader.Get("LocalData")
    if not LocalData then return nil end
    
    local success, data = pcall(function()
        return LocalData:Get()
    end)
    
    if not success or not data or not data.Stats then
        return nil
    end
    
    return data.Stats.Hatches 
        or data.Stats.TotalEggsOpened 
        or data.Stats["ðŸ¥šHatches"]
        or data.Stats["ðŸ¥š Hatches"]
end

-- ============================================================================
-- SECTION 9: PET DETECTOR
-- ============================================================================

local PetDetector = {
    connection = nil,
    initialized = false
}

-- Get active settings (admin abuse or normal)
function PetDetector.GetActiveSettings()
    if StateManager.adminAbuseActive then
        return {
            notifyNormal = SettingsManager.Get("adminAbuseSecretSettings") and SettingsManager.Get("adminAbuseSecretSettings").notifyNormal or false,
            notifyShiny = SettingsManager.Get("adminAbuseSecretSettings") and SettingsManager.Get("adminAbuseSecretSettings").notifyShiny or false,
            notifyMythic = SettingsManager.Get("adminAbuseSecretSettings") and SettingsManager.Get("adminAbuseSecretSettings").notifyMythic or false,
            notifyShinyMythic = SettingsManager.Get("adminAbuseSecretSettings") and SettingsManager.Get("adminAbuseSecretSettings").notifyShinyMythic or false,
            notifyXL = SettingsManager.Get("adminAbuseSecretSettings") and SettingsManager.Get("adminAbuseSecretSettings").notifyXL or false,
            pingNormal = SettingsManager.Get("adminAbuseSecretSettings") and SettingsManager.Get("adminAbuseSecretSettings").pingNormal or false,
            pingShiny = SettingsManager.Get("adminAbuseSecretSettings") and SettingsManager.Get("adminAbuseSecretSettings").pingShiny or false,
            pingMythic = SettingsManager.Get("adminAbuseSecretSettings") and SettingsManager.Get("adminAbuseSecretSettings").pingMythic or false,
            pingShinyMythic = SettingsManager.Get("adminAbuseSecretSettings") and SettingsManager.Get("adminAbuseSecretSettings").pingShinyMythic or false,
            pingXL = SettingsManager.Get("adminAbuseSecretSettings") and SettingsManager.Get("adminAbuseSecretSettings").pingXL or false,
            filterUnder1B = SettingsManager.Get("adminAbuseSecretSettings") and SettingsManager.Get("adminAbuseSecretSettings").filterUnder1B or false,
            infinityNotify = SettingsManager.Get("adminAbuseSecretSettings") and (SettingsManager.Get("adminAbuseSecretSettings").notifyInfinity or true),
            infinityPing = SettingsManager.Get("adminAbuseSecretSettings") and (SettingsManager.Get("adminAbuseSecretSettings").pingInfinity or true)
        }
    else
        return {
            notifyNormal = SettingsManager.Get("secretNotifyNormal"),
            notifyShiny = SettingsManager.Get("secretNotifyShiny"),
            notifyMythic = SettingsManager.Get("secretNotifyMythic"),
            notifyShinyMythic = SettingsManager.Get("secretNotifyShinyMythic"),
            notifyXL = SettingsManager.Get("secretNotifyXL"),
            pingNormal = SettingsManager.Get("secretPingNormal"),
            pingShiny = SettingsManager.Get("secretPingShiny"),
            pingMythic = SettingsManager.Get("secretPingMythic"),
            pingShinyMythic = SettingsManager.Get("secretPingShinyMythic"),
            pingXL = SettingsManager.Get("secretPingXL"),
            filterUnder1B = SettingsManager.Get("secretFilterUnder1B"),
            infinityNotify = SettingsManager.Get("infinityNotifyEnabled"),
            infinityPing = SettingsManager.Get("infinityPingEnabled")
        }
    end
end

-- Detect XL variant (optimized)
function PetDetector.IsXL(pet, petName)
    return (pet.XL == true)
        or (pet.xl == true)
        or (pet.Xl == true)
        or (type(pet.XL) == "number" and pet.XL > 0)
        or (petName and string.find(string.upper(petName), "XL", 1, true) ~= nil)
end

-- Cascading detection logic for secrets
function PetDetector.ShouldNotifySecret(shiny, mythic, xl, activeSettings)
    if shiny and mythic and xl then
        return activeSettings.notifyShiny or activeSettings.notifyMythic or activeSettings.notifyShinyMythic or activeSettings.notifyXL,
               activeSettings.pingShiny or activeSettings.pingMythic or activeSettings.pingShinyMythic or activeSettings.pingXL
    elseif mythic and xl then
        return activeSettings.notifyMythic or activeSettings.notifyXL,
               activeSettings.pingMythic or activeSettings.pingXL
    elseif shiny and xl then
        return activeSettings.notifyShiny or activeSettings.notifyXL,
               activeSettings.pingShiny or activeSettings.pingXL
    elseif shiny and mythic then
        return activeSettings.notifyShiny or activeSettings.notifyMythic or activeSettings.notifyShinyMythic,
               activeSettings.pingShiny or activeSettings.pingMythic or activeSettings.pingShinyMythic
    elseif xl then
        return activeSettings.notifyXL, activeSettings.pingXL
    elseif mythic then
        return activeSettings.notifyMythic, activeSettings.pingMythic
    elseif shiny then
        return activeSettings.notifyShiny, activeSettings.pingShiny
    else
        return activeSettings.notifyNormal, activeSettings.pingNormal
    end
end

-- Check if pet passes 1B filter
function PetDetector.Passes1BFilter(pet, shiny, mythic, xl, activeSettings, PetUtil)
    if not activeSettings.filterUnder1B then return true end
    
    if not PetUtil or not pet then return true end
    
    local success, petChance = pcall(function()
        return PetUtil:GetChance(pet)
    end)
    
    if not success or not petChance or petChance <= 0 then return true end
    
    local denominator = math.ceil(100 / petChance)
    if denominator >= 1000000000 then return true end -- >= 1B, pass
    
    -- < 1B, check if any enabled variant overrides
    if xl and activeSettings.notifyXL then return true end
    if (shiny and mythic) and activeSettings.notifyShinyMythic then return true end
    if mythic and activeSettings.notifyMythic then return true end
    if shiny and activeSettings.notifyShiny then return true end
    if (not shiny and not mythic and not xl) and activeSettings.notifyNormal then return true end
    
    return false -- Blocked by filter
end

-- Track pet for summaries
function PetDetector.TrackPet(petName, shiny, mythic, xl, rarity, pet, isInfinity, target)
    table.insert(target, {
        name = petName,
        shiny = shiny,
        mythic = mythic,
        xl = xl,
        rarity = rarity,
        isInfinity = isInfinity or false,
        pet = pet
    })
end

-- Process pet hatch
function PetDetector.ProcessPet(pet, eggName, ItemUtil, PetUtil, PetsData)
    if not pet or not pet.Name then return end
    
    local petName = pet.Name
    local shiny = pet.Shiny == true
    local mythic = pet.Mythic == true
    local xl = PetDetector.IsXL(pet, petName)
    
    if not ItemUtil then return end
    
    local rarity = ItemUtil:GetRarity(pet)
    local isSpecial = Utils.IsSpecialPet(petName)
    local isSecret = rarity == "Secret"
    local isLegendary = rarity == "Legendary"
    
    local activeSettings = PetDetector.GetActiveSettings()
    
    -- Priority 1: Infinity pets
    if isSpecial then
        if activeSettings.infinityNotify then
            local shouldPing = activeSettings.infinityPing
            
            if StateManager.adminAbuseActive then
                PetDetector.TrackPet(petName, shiny, mythic, xl, rarity, pet, true, StateManager.adminAbusePets)
            end
            
            if StateManager.isAtRift then
                PetDetector.TrackPet(petName, shiny, mythic, xl, rarity, pet, true, StateManager.riftHatchedPets)
            end
            
            PetDetector.SendNotification(petName, shiny, mythic, xl, eggName, rarity, pet, "infinity", shouldPing, PetsData)
        end
        return
    end
    
    -- Priority 2: Secret pets
    if isSecret then
        local shouldNotify, shouldPing = PetDetector.ShouldNotifySecret(shiny, mythic, xl, activeSettings)
        
        if shouldNotify and PetDetector.Passes1BFilter(pet, shiny, mythic, xl, activeSettings, PetUtil) then
            if StateManager.adminAbuseActive then
                PetDetector.TrackPet(petName, shiny, mythic, xl, rarity, pet, false, StateManager.adminAbusePets)
            end
            
            if StateManager.isAtRift then
                PetDetector.TrackPet(petName, shiny, mythic, xl, rarity, pet, false, StateManager.riftHatchedPets)
            end
            
            PetDetector.SendNotification(petName, shiny, mythic, xl, eggName, rarity, pet, "secret", shouldPing, PetsData)
        end
        return
    end
    
    -- Priority 3: XL pets (non-secret)
    if xl and SettingsManager.Get("xlDetectionEnabled") then
        PetDetector.SendNotification(petName, shiny, mythic, xl, eggName, rarity, pet, "xl", SettingsManager.Get("xlPingEnabled"), PetsData)
        return
    end
    
    -- Priority 4: Legendary pets (non-XL, non-secret)
    if isLegendary and SettingsManager.Get("legendaryDetectionEnabled") then
        PetDetector.SendNotification(petName, shiny, mythic, xl, eggName, rarity, pet, "legendary", SettingsManager.Get("legendaryPingEnabled"), PetsData)
    end
end

-- Send pet notification (queues to webhook)
function PetDetector.SendNotification(petName, shiny, mythic, xl, eggName, rarity, pet, notificationType, shouldPing, PetsData)
    local petImageAssetId = nil
    if PetsData and pet then
        local success, data = pcall(function()
            return PetsData[petName]
        end)
        if success and data and data.Image then
            petImageAssetId = data.Image
        end
    end
    
    HTTPClient.Queue({
        webhookURL = SettingsManager.Get("webhookURL"),
        payload = {
            petName = petName,
            shiny = shiny,
            mythic = mythic,
            xl = xl,
            eggName = eggName,
            rarity = rarity,
            pet = pet,
            petImageAssetId = petImageAssetId,
            notificationType = notificationType,
            shouldPing = shouldPing,
            isSpecial = (notificationType == "infinity")
        }
    })
end

-- Initialize pet detection
function PetDetector.Init()
    if PetDetector.initialized then return end
    
    local Remote = ModuleLoader.Get("Remote")
    local ItemUtil = ModuleLoader.Get("ItemUtil")
    local PetUtil = ModuleLoader.Get("PetUtil")
    local PetsData = ModuleLoader.Get("PetsData")
    
    if not Remote or not ItemUtil then
        warn("âš  PetDetector: Required modules not loaded")
        return false
    end
    
    local success, err = pcall(function()
        PetDetector.connection = Remote.Event("HatchEgg"):Connect(function(hatchedTable)
            pcall(function()
                if not StateManager.scriptActive then return end
                
                if type(hatchedTable) == "table" and hatchedTable.Pets then
                    local eggName = hatchedTable.Name
                    
                    for i = 1, 20 do
                        local petData = hatchedTable.Pets[i]
                        if not petData then break end
                        
                        if type(petData) == "table" and petData.Pet then
                            PetDetector.ProcessPet(petData.Pet, eggName, ItemUtil, PetUtil, PetsData)
                        end
                    end
                end
            end)
        end)
    end)
    
    if success then
        print("âœ“ PetDetector initialized")
        PetDetector.initialized = true
        return true
    else
        warn("âš  PetDetector failed to initialize: " .. tostring(err))
        return false
    end
end

-- Disconnect pet detection
function PetDetector.Disconnect()
    if PetDetector.connection then
        PetDetector.connection:Disconnect()
        PetDetector.connection = nil
    end
    PetDetector.initialized = false
end

-- ============================================================================
-- SECTION 10: RIFT MANAGER
-- ============================================================================

local RiftManager = {
    connection = nil,
    initialized = false
}

-- Get rift destination position
function RiftManager.GetDestinationPosition(rift)
    local riftType = rift:GetAttribute("Type") or "unknown"
    
    -- Chest rifts
    if riftType == "Chest" then
        local chest = rift:FindFirstChild("Chest")
        if chest then
            if chest:FindFirstChild("Prompt") then
                local prompt = chest.Prompt
                if prompt.Parent and prompt.Parent:IsA("BasePart") then
                    return prompt.Parent.Position
                end
            end
            if chest:IsA("BasePart") then
                return chest.Position
            end
            if chest.PrimaryPart then
                return chest.PrimaryPart.Position
            end
            for _, child in pairs(chest:GetChildren()) do
                if child:IsA("BasePart") and child.Name ~= "Display" then
                    return child.Position
                end
            end
        end
    end
    
    -- Gift rifts
    if riftType == "Gift" then
        local gift = rift:FindFirstChild("Gift")
        if gift then
            if gift:FindFirstChild("Prompt") then
                local prompt = gift.Prompt
                if prompt.Parent and prompt.Parent:IsA("BasePart") then
                    return prompt.Parent.Position
                end
            end
            if gift:IsA("BasePart") then
                return gift.Position
            end
            if gift.PrimaryPart then
                return gift.PrimaryPart.Position
            end
            for _, child in pairs(gift:GetChildren()) do
                if child:IsA("BasePart") and child.Name ~= "Display" then
                    return child.Position
                end
            end
        end
    end
    
    -- Egg rifts
    if riftType == "Egg" then
        for _, child in pairs(rift:GetDescendants()) do
            if child:IsA("BasePart") then
                local childName = string.lower(child.Name)
                if childName:find("egg") or childName:find("root") or childName:find("prompt") then
                    return child.Position
                end
            end
        end
        
        local pivotCF = rift:GetPivot()
        if pivotCF then
            return pivotCF.Position
        end
    end
    
    -- Fallback: Display sign
    local display = rift:FindFirstChild("Display")
    if display and display.Position then
        return display.Position
    end
    
    -- Ultimate fallback
    if rift.PrimaryPart then
        return rift.PrimaryPart.Position
    elseif rift:IsA("Model") then
        local pivotCF = rift:GetPivot()
        if pivotCF then
            return pivotCF.Position
        end
    end
    
    return nil
end

-- Teleport to position
function RiftManager.TeleportToPosition(targetPosition, heightOffset, onArrival)
    local character = LocalPlayer.Character
    if not character then
        if onArrival then onArrival() end
        return false
    end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        if onArrival then onArrival() end
        return false
    end
    
    local adjustedPosition = targetPosition + Vector3.new(0, heightOffset or Config.RIFT.HEIGHT_OFFSET, 0)
    
    -- Disable collision
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
    
    -- Teleport
    rootPart.CFrame = CFrame.new(adjustedPosition)
    
    task.wait(Config.RIFT.TELEPORT_DELAY)
    
    -- Re-enable collision
    spawn(function()
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = true
            end
        end
    end)
    
    if onArrival then
        onArrival()
    end
    
    return true
end

-- Send rift arrival notification
function RiftManager.SendArrivalNotification(displayName, duration, multiplier)
    local webhookURL = SettingsManager.Get("webhookURL")
    if not webhookURL or webhookURL == "" then return end
    
    local playerName = LocalPlayer.Name or "Unknown Player"
    local description = string.format("**%s** teleported to **%s**\n**Duration:** %d seconds", playerName, displayName, math.floor(duration))
    
    if multiplier then
        description = description .. string.format("\n**Multiplier:** %sx Luck", tostring(multiplier))
    end
    
    local mention = ""
    if SettingsManager.Get("riftPingEnabled") and SettingsManager.Get("discordUserID") ~= "" then
        mention = "<@" .. SettingsManager.Get("discordUserID") .. ">"
    end
    
    HTTPClient.Queue({
        webhookURL = webhookURL,
        payload = {
            content = mention ~= "" and mention or nil,
            embeds = {{
                title = "ðŸŒ€ Rift Arrival",
                description = description,
                color = 10181046,
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }}
        }
    })
end

-- Send rift summary
function RiftManager.SendSummary(displayName)
    local webhookURL = SettingsManager.Get("webhookURL")
    if not webhookURL or webhookURL == "" then return end
    
    local currentEggCount = EggHelper.GetTotalHatched()
    local eggsHatched = 0
    if StateManager.riftStartEggCount and currentEggCount then
        eggsHatched = currentEggCount - StateManager.riftStartEggCount
    end
    
    local description = string.format("Returned from **%s**\n\n**Total Eggs Hatched:** %s", displayName, Utils.FormatNumber(eggsHatched))
    
    if #StateManager.riftHatchedPets > 0 then
        -- Sort and format pets
        table.sort(StateManager.riftHatchedPets, function(a, b)
            if a.isInfinity ~= b.isInfinity then
                return a.isInfinity
            end
            local aVar = Utils.GetVariantHierarchy(a.shiny, a.mythic, a.xl)
            local bVar = Utils.GetVariantHierarchy(b.shiny, b.mythic, b.xl)
            if aVar ~= bVar then
                return aVar > bVar
            end
            -- Sort by rarity if available
            return false
        end)
        
        local petList = {}
        for _, petData in ipairs(StateManager.riftHatchedPets) do
            local variantName = Utils.GetVariantName(petData.shiny, petData.mythic, petData.xl)
            local fullName = (variantName ~= "" and variantName .. " " or "") .. petData.name
            if petData.isInfinity then
                fullName = "âˆž " .. fullName
            end
            table.insert(petList, "â€¢ " .. fullName)
        end
        
        description = description .. "\n\n**Secrets/Infinities Hatched:**\n" .. table.concat(petList, "\n")
    else
        description = description .. "\n\nNo secrets or infinities were hatched."
    end
    
    HTTPClient.Queue({
        webhookURL = webhookURL,
        payload = {
            embeds = {{
                title = "ðŸŒ€ Rift Complete",
                description = description,
                color = 10181046,
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }}
        }
    })
    
    -- Reset tracking
    StateManager.riftHatchedPets = {}
    StateManager.riftStartEggCount = nil
end

-- Return to stored position
function RiftManager.ReturnToStoredPosition()
    if not StateManager.storedPosition then return end
    
    StateManager.returningFromRift = true
    
    local displayName = "Rift"
    if StateManager.currentRift then
        local riftName = string.lower(StateManager.currentRift.Name)
        for _, riftInfo in ipairs(Config.AVAILABLE_RIFTS) do
            if riftInfo.name == riftName then
                displayName = riftInfo.displayName
                break
            end
        end
    end
    
    RiftManager.TeleportToPosition(StateManager.storedPosition, 0, function()
        RiftManager.SendSummary(displayName)
        
        task.wait(Config.RIFT.RETURN_DELAY)
        
        StateManager.isAtRift = false
        StateManager.currentRift = nil
        StateManager.riftStartTime = nil
        StateManager.storedPosition = nil
        StateManager.returningFromRift = false
        StateManager.riftHatchedPets = {}
        StateManager.riftStartEggCount = nil
    end)
end

-- Handle rift detected
function RiftManager.OnRiftDetected(rift)
    if not StateManager.riftAutoTeleportEnabled then return end
    if StateManager.isAtRift then return end
    if StateManager.returningFromRift then return end
    
    local riftName = string.lower(rift.Name)
    local riftSelections = SettingsManager.Get("riftSelections") or {}
    
    if not riftSelections[riftName] then return end
    
    local displayName = riftName
    for _, riftInfo in ipairs(Config.AVAILABLE_RIFTS) do
        if riftInfo.name == riftName then
            displayName = riftInfo.displayName
            break
        end
    end
    
    local destination = RiftManager.GetDestinationPosition(rift)
    if not destination then return end
    
    local despawnAt = rift:GetAttribute("DespawnAt")
    local duration = Config.RIFT.DEFAULT_DURATION
    if despawnAt then
        duration = math.max(0, despawnAt - workspace:GetServerTimeNow())
    end
    
    local multiplier = nil
    if rift:GetAttribute("Type") == "Egg" then
        multiplier = rift:GetAttribute("BonusLuck")
    end
    
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    
    StateManager.storedPosition = character.HumanoidRootPart.Position
    StateManager.riftStartEggCount = EggHelper.GetTotalHatched()
    StateManager.currentRift = rift
    StateManager.riftHatchedPets = {}
    
    RiftManager.TeleportToPosition(destination, Config.RIFT.HEIGHT_OFFSET, function()
        StateManager.isAtRift = true
        StateManager.riftStartTime = tick()
        
        RiftManager.SendArrivalNotification(displayName, duration, multiplier)
        
        -- Start timer
        spawn(function()
            task.wait(duration)
            
            if StateManager.isAtRift and StateManager.currentRift then
                RiftManager.ReturnToStoredPosition()
            end
        end)
        
        -- Monitor despawn
        local despawnConnection = nil
        despawnConnection = rift.AncestryChanged:Connect(function()
            if not rift.Parent and StateManager.isAtRift and StateManager.currentRift then
                if despawnConnection then
                    despawnConnection:Disconnect()
                end
                RiftManager.ReturnToStoredPosition()
            elseif not rift.Parent and despawnConnection then
                despawnConnection:Disconnect()
            end
        end)
    end)
end

-- Initialize rift manager
function RiftManager.Init()
    if RiftManager.initialized then return end
    
    spawn(function()
        task.wait(2) -- Wait for other systems
        
        local success, riftsFolder = pcall(function()
            return workspace:WaitForChild("Rendered", 10):WaitForChild("Rifts", 10)
        end)
        
        if success and riftsFolder then
            -- Check existing rifts (log only)
            for _, rift in pairs(riftsFolder:GetChildren()) do
                print("   Found existing rift: " .. rift.Name .. " (ignoring)")
            end
            
            -- Listen for new rifts
            RiftManager.connection = riftsFolder.ChildAdded:Connect(function(rift)
                if not StateManager.scriptActive then return end
                task.wait(0.1) -- Wait for attributes
                RiftManager.OnRiftDetected(rift)
            end)
            
            print("âœ“ RiftManager initialized")
            RiftManager.initialized = true
        else
            warn("âš  RiftManager: Could not find Rifts folder")
        end
    end)
end

-- ============================================================================
-- SECTION 11: AUTO HATCH
-- ============================================================================

local AutoHatch = {
    running = false,
    connection = nil
}

function AutoHatch.Start()
    if AutoHatch.running then return end
    
    AutoHatch.running = true
    StateManager.autoHatchEnabled = true
    
    AutoHatch.connection = Services.RunService.Heartbeat:Connect(function()
        if not StateManager.scriptActive or not StateManager.autoHatchEnabled then
            AutoHatch.Stop()
            return
        end
        
        Services.VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
        task.wait(0.05)
        Services.VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
    end)
    
    print("âœ“ Auto-hatch started")
end

function AutoHatch.Stop()
    if not AutoHatch.running then return end
    
    AutoHatch.running = false
    StateManager.autoHatchEnabled = false
    
    if AutoHatch.connection then
        AutoHatch.connection:Disconnect()
        AutoHatch.connection = nil
    end
    
    print("âœ“ Auto-hatch stopped")
end

function AutoHatch.Toggle()
    if AutoHatch.running then
        AutoHatch.Stop()
    else
        AutoHatch.Start()
    end
end

-- ============================================================================
-- SECTION 12: WEBHOOK FORMATTER
-- ============================================================================

local WebhookFormatter = {}

-- Get embed color based on pet variants
function WebhookFormatter.GetEmbedColor(shiny, mythic, xl, isInfinity)
    if isInfinity then
        if shiny and mythic and xl then return 16711935 end -- Magenta
        if mythic and xl then return 16711680 end -- Red
        if shiny and xl then return 16776960 end -- Yellow
        if xl then return 16753920 end -- Orange
        if shiny and mythic then return 8388608 end -- Dark red
        if mythic then return 8388736 end -- Dark orange
        if shiny then return 65535 end -- Cyan
        return 16777215 -- White
    else
        if shiny and mythic and xl then return 16711935 end -- Magenta
        if mythic and xl then return 16711680 end -- Red
        if shiny and xl then return 16776960 end -- Yellow
        if xl then return 11053224 end -- Light grey
        if shiny and mythic then return 8388608 end -- Dark red
        if mythic then return 8388736 end -- Dark orange
        if shiny then return 65535 end -- Cyan
        return 3447003 -- Blue
    end
end

-- Format pet notification payload
function WebhookFormatter.FormatPetNotification(data)
    local petName = data.petName
    local shiny = data.shiny
    local mythic = data.mythic
    local xl = data.xl
    local eggName = data.eggName
    local rarity = data.rarity
    local pet = data.pet
    local petImageAssetId = data.petImageAssetId
    local notificationType = data.notificationType or "secret"
    local shouldPing = data.shouldPing or false
    local isInfinity = data.isInfinity or false
    
    local playerName = LocalPlayer.Name or "Unknown Player"
    local eggsHatched = EggHelper.GetTotalHatched()
    
    -- Build full pet name
    local fullPetName = Utils.GetVariantName(shiny, mythic, xl)
    if fullPetName ~= "" then
        fullPetName = fullPetName .. " "
    end
    fullPetName = fullPetName .. petName
    
    -- Get embed color
    local embedColor = WebhookFormatter.GetEmbedColor(shiny, mythic, xl, isInfinity)
    
    -- Build mention
    local mention = ""
    if shouldPing and SettingsManager.Get("discordUserID") ~= "" then
        mention = "<@" .. SettingsManager.Get("discordUserID") .. ">"
    end
    
    -- Calculate probability
    local probabilityText = nil
    local PetUtil = ModuleLoader.Get("PetUtil")
    local FormatCommas = ModuleLoader.Get("FormatCommas")
    
    if PetUtil and pet then
        local success, petChance = pcall(function()
            return PetUtil:GetChance(pet)
        end)
        if success and petChance and petChance > 0 then
            local denominator = math.ceil(100 / petChance)
            if FormatCommas then
                probabilityText = "1/" .. FormatCommas(denominator)
            else
                probabilityText = "1/" .. Utils.FormatNumber(denominator)
            end
        end
    end
    
    -- Determine article
    local article = "a"
    if not shiny and not mythic and petName then
        local firstLetter = string.lower(string.sub(petName, 1, 1))
        if firstLetter == "a" or firstLetter == "e" or firstLetter == "i" or firstLetter == "o" or firstLetter == "u" then
            article = "an"
        end
    end
    
    -- Build description
    local description = string.format("**%s** hatched %s **%s**!", playerName, article, fullPetName)
    
    -- Build fields
    local fields = {{
        name = "Hatched",
        value = fullPetName,
        inline = false
    }}
    
    if probabilityText then
        table.insert(fields, {
            name = "Rarity",
            value = probabilityText,
            inline = true
        })
    elseif rarity then
        table.insert(fields, {
            name = "Rarity",
            value = rarity,
            inline = true
        })
    end
    
    -- Build title based on type
    local title = "ðŸŽ‰ Congratulations!"
    if notificationType == "infinity" then
        title = "ðŸŽ‰ Congratulations! You hatched an ***INFINITY***! ðŸŽ‰"
    elseif notificationType == "xl" then
        title = "ðŸŽ‰ XL Pet Hatched!"
    elseif notificationType == "legendary" then
        title = "âœ¨ Legendary Pet Hatched!"
    end
    
    -- Build embed
    local embed = {
        title = title,
        description = description,
        color = embedColor,
        fields = fields,
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    -- Add thumbnail (fetch lazily)
    if petImageAssetId then
        local thumbnailUrl = HTTPClient.GetThumbnailUrl(petImageAssetId)
        if thumbnailUrl then
            embed.thumbnail = {url = thumbnailUrl}
        end
    end
    
    -- Add footer
    if eggsHatched then
        local FormatCommas = ModuleLoader.Get("FormatCommas")
        local formattedCount = FormatCommas and FormatCommas(eggsHatched) or Utils.FormatNumber(eggsHatched)
        embed.footer = {text = "Eggs hatched: " .. formattedCount}
    end
    
    return {
        content = mention ~= "" and mention or nil,
        embeds = {embed}
    }
end

-- Process webhook queue item (formats and sends)
function HTTPClient.ProcessWebhookItem(item)
    local webhookURL = item.webhookURL or SettingsManager.Get("webhookURL")
    if not webhookURL or webhookURL == "" then return false end
    
    local payload = nil
    
    if item.isCustomEmbed then
        payload = item.payload
    elseif item.isPlainText then
        payload = {
            content = item.message
        }
    elseif item.petName then
        -- Pet notification - format it
        payload = WebhookFormatter.FormatPetNotification(item)
    else
        return false
    end
    
    if not payload then return false end
    
    local success, response, status = HTTPClient.SendRequest(webhookURL, payload)
    return success, status
end

-- Update HTTPClient.ProcessQueue to use formatter
function HTTPClient.ProcessQueue()
    if HTTPClient.isProcessing or #HTTPClient.queue == 0 then return end
    
    HTTPClient.isProcessing = true
    
    spawn(function()
        while #HTTPClient.queue > 0 do
            local item = table.remove(HTTPClient.queue, 1)
            local success, status = HTTPClient.ProcessWebhookItem(item)
            
            if not success and status == 429 then
                -- Rate limited - re-queue
                table.insert(HTTPClient.queue, 1, item)
                HTTPClient.rateLimitCounter = Config.WEBHOOK_RATE_LIMIT.INITIAL_COUNT
            elseif not success then
                -- Other error - re-queue (will retry)
                table.insert(HTTPClient.queue, 1, item)
            end
            
            -- Rate limiting delay
            local delay = (HTTPClient.rateLimitCounter > 0) and Config.WEBHOOK_RATE_LIMIT.INITIAL_DELAY or Config.WEBHOOK_RATE_LIMIT.NORMAL_DELAY
            if HTTPClient.rateLimitCounter > 0 then
                HTTPClient.rateLimitCounter = HTTPClient.rateLimitCounter - 1
            end
            
            if #HTTPClient.queue > 0 then
                task.wait(delay)
            end
        end
        
        HTTPClient.isProcessing = false
    end)
end

-- Update PetDetector.SendNotification to use new format
function PetDetector.SendNotification(petName, shiny, mythic, xl, eggName, rarity, pet, notificationType, shouldPing, PetsData)
    local petImageAssetId = nil
    if PetsData and pet then
        local success, data = pcall(function()
            return PetsData[petName]
        end)
        if success and data and data.Images then
            local imageType = "Normal"
            if shiny and mythic and xl then
                imageType = "MythicShinyXL"
            elseif shiny and mythic then
                imageType = "MythicShiny"
            elseif mythic and xl then
                imageType = "MythicXL"
            elseif shiny and xl then
                imageType = "ShinyXL"
            elseif shiny then
                imageType = "Shiny"
            elseif mythic then
                imageType = "Mythic"
            elseif xl then
                imageType = "XL"
            end
            
            local petImageAsset = data.Images[imageType] or data.Images["Normal"]
            if petImageAsset then
                petImageAssetId = petImageAsset:match("rbxassetid://(%d+)")
            end
        end
    end
    
    HTTPClient.Queue({
        webhookURL = SettingsManager.Get("webhookURL"),
        payload = nil, -- Will be formatted in ProcessWebhookItem
        petName = petName,
        shiny = shiny,
        mythic = mythic,
        xl = xl,
        eggName = eggName,
        rarity = rarity,
        pet = pet,
        petImageAssetId = petImageAssetId,
        notificationType = notificationType,
        shouldPing = shouldPing,
        isInfinity = (notificationType == "infinity")
    })
end

-- ============================================================================
-- SECTION 13: EGG MONITOR
-- ============================================================================

local EggMonitor = {
    running = false,
    lastEggCount = nil,
    lastHourlyEggCount = nil,
    firstCheckTime = nil,
    lastHourNotified = nil,
    hasStoppedHatching = false,
    hourlyEggHistory = {},
    hoursCountedSinceLastNotif = 0
}

function EggMonitor.Start()
    if EggMonitor.running then return end
    
    EggMonitor.running = true
    
    spawn(function()
        while StateManager.scriptActive and EggMonitor.running do
            if SettingsManager.Get("eggCountMonitoringEnabled") and SettingsManager.Get("webhookURL") ~= "" then
                -- Calculate time until next :X0 minute
                local currentTime = os.date("*t")
                local currentMinute = currentTime.min
                local currentSecond = currentTime.sec
                
                local minutesUntilNextCheck = 10 - (currentMinute % 10)
                if minutesUntilNextCheck == 10 and currentSecond == 0 then
                    minutesUntilNextCheck = 10
                elseif minutesUntilNextCheck == 10 then
                    minutesUntilNextCheck = 0
                end
                
                local secondsUntilNextCheck = (minutesUntilNextCheck * 60) - currentSecond
                if secondsUntilNextCheck <= 0 then
                    secondsUntilNextCheck = 600
                end
                
                task.wait(math.min(secondsUntilNextCheck, 600))
                
                if not SettingsManager.Get("eggCountMonitoringEnabled") or SettingsManager.Get("webhookURL") == "" or not StateManager.scriptActive then
                    task.wait(60)
                    goto continue
                end
                
                local currentEggCount = EggHelper.GetTotalHatched()
                
                if currentEggCount == nil then
                    if EggMonitor.lastEggCount ~= nil and not EggMonitor.hasStoppedHatching then
                        HTTPClient.Queue({
                            webhookURL = SettingsManager.Get("webhookURL"),
                            isPlainText = true,
                            message = string.format("%s is no longer hatching.", LocalPlayer.Name)
                        })
                        EggMonitor.hasStoppedHatching = true
                    end
                    EggMonitor.lastEggCount = nil
                    EggMonitor.lastHourlyEggCount = nil
                    EggMonitor.firstCheckTime = nil
                elseif EggMonitor.lastEggCount == nil then
                    EggMonitor.lastEggCount = currentEggCount
                    EggMonitor.lastHourlyEggCount = currentEggCount
                    EggMonitor.firstCheckTime = os.time()
                    EggMonitor.hasStoppedHatching = false
                elseif currentEggCount > EggMonitor.lastEggCount then
                    EggMonitor.lastEggCount = currentEggCount
                    EggMonitor.hasStoppedHatching = false
                    
                    local currentTime = os.date("*t")
                    if currentTime.min == 0 and EggMonitor.lastHourlyEggCount ~= nil then
                        local currentHour = currentTime.hour
                        
                        if EggMonitor.lastHourNotified ~= currentHour then
                            local hourTimestamp = math.floor(os.time() / 3600)
                            EggMonitor.hourlyEggHistory[hourTimestamp] = currentEggCount
                            
                            -- Clean old entries
                            for timestamp, _ in pairs(EggMonitor.hourlyEggHistory) do
                                if hourTimestamp - timestamp > 150 then
                                    EggMonitor.hourlyEggHistory[timestamp] = nil
                                end
                            end
                            
                            EggMonitor.hoursCountedSinceLastNotif = EggMonitor.hoursCountedSinceLastNotif + 1
                            
                            local intervalHours = SettingsManager.Get("eggMonitorIntervalHours") or 1
                            if EggMonitor.hoursCountedSinceLastNotif >= intervalHours then
                                local eggsInPeriod = currentEggCount - EggMonitor.lastHourlyEggCount
                                local timeInPeriod = intervalHours * 60
                                if EggMonitor.lastHourNotified == nil and EggMonitor.firstCheckTime ~= nil then
                                    timeInPeriod = math.floor((os.time() - EggMonitor.firstCheckTime) / 60)
                                end
                                
                                local FormatCommas = ModuleLoader.Get("FormatCommas")
                                local formattedTotal = FormatCommas and FormatCommas(currentEggCount) or Utils.FormatNumber(currentEggCount)
                                local formattedPeriod = FormatCommas and FormatCommas(eggsInPeriod) or Utils.FormatNumber(eggsInPeriod)
                                
                                local timeUnit = timeInPeriod >= 60 and "hours" or "minutes"
                                local timeValue = timeInPeriod >= 60 and (timeInPeriod / 60) or timeInPeriod
                                
                                local message = string.format(
                                    "%s is still hatching.\nTotal Hatched: %s\nEggs hatched in the last %d %s: %s",
                                    LocalPlayer.Name,
                                    formattedTotal,
                                    timeValue,
                                    timeUnit,
                                    formattedPeriod
                                )
                                
                                -- Add rolling totals
                                local currentHourTimestamp = math.floor(os.time() / 3600)
                                for multipleOf12 = 12, 120, 12 do
                                    if intervalHours ~= multipleOf12 then
                                        local timestampXHoursAgo = currentHourTimestamp - multipleOf12
                                        local eggCountXHoursAgo = EggMonitor.hourlyEggHistory[timestampXHoursAgo]
                                        
                                        if eggCountXHoursAgo then
                                            local eggsInLastXHours = currentEggCount - eggCountXHoursAgo
                                            local formattedXHours = FormatCommas and FormatCommas(eggsInLastXHours) or Utils.FormatNumber(eggsInLastXHours)
                                            message = message .. string.format("\nEggs hatched in the last %d hours: %s", multipleOf12, formattedXHours)
                                        end
                                    end
                                end
                                
                                HTTPClient.Queue({
                                    webhookURL = SettingsManager.Get("webhookURL"),
                                    isPlainText = true,
                                    message = message
                                })
                                
                                EggMonitor.hoursCountedSinceLastNotif = 0
                                EggMonitor.lastHourlyEggCount = currentEggCount
                            end
                            
                            EggMonitor.lastHourNotified = currentHour
                        end
                    end
                else
                    if not EggMonitor.hasStoppedHatching then
                        HTTPClient.Queue({
                            webhookURL = SettingsManager.Get("webhookURL"),
                            isPlainText = true,
                            message = string.format("%s is no longer hatching.", LocalPlayer.Name)
                        })
                        EggMonitor.hasStoppedHatching = true
                    end
                    EggMonitor.lastEggCount = currentEggCount
                end
            else
                task.wait(60)
            end
            
            ::continue::
        end
    end)
    
    print("âœ“ EggMonitor started")
end

-- ============================================================================
-- SECTION 14: PLAYER TRACKER
-- ============================================================================

local PlayerTracker = {
    initialized = false
}

function PlayerTracker.Init()
    if PlayerTracker.initialized then return end
    
    Services.Players.PlayerAdded:Connect(function(player)
        if not StateManager.scriptActive or not SettingsManager.Get("playerTrackingEnabled") or SettingsManager.Get("webhookURL") == "" then return end
        
        HTTPClient.Queue({
            webhookURL = SettingsManager.Get("webhookURL"),
            isPlainText = true,
            message = string.format("%s joined the server", player.Name)
        })
    end)
    
    Services.Players.PlayerRemoving:Connect(function(player)
        if not StateManager.scriptActive or not SettingsManager.Get("playerTrackingEnabled") or SettingsManager.Get("webhookURL") == "" then return end
        
        HTTPClient.Queue({
            webhookURL = SettingsManager.Get("webhookURL"),
            isPlainText = true,
            message = string.format("%s left the server", player.Name)
        })
    end)
    
    PlayerTracker.initialized = true
    print("âœ“ PlayerTracker initialized")
end

-- ============================================================================
-- SECTION 15: CHAT MONITOR
-- ============================================================================

local ChatMonitor = {
    initialized = false
}

function ChatMonitor.Init()
    if ChatMonitor.initialized then return end
    
    -- TextChatService (new)
    pcall(function()
        if Services.TextChatService and Services.TextChatService.MessageReceived then
            Services.TextChatService.MessageReceived:Connect(function(message)
                if not StateManager.scriptActive then return end
                
                local text = message.Text or ""
                if string.find(string.lower(text), "feeling jolly") then
                    HTTPClient.Queue({
                        webhookURL = SettingsManager.Get("webhookURL"),
                        isPlainText = true,
                        message = "A Christmas Chest Rift has spawned!",
                        shouldPing = true
                    })
                end
            end)
        end
    end)
    
    -- Legacy chat
    pcall(function()
        local player = Services.Players.LocalPlayer
        if player and player:WaitForChild("PlayerGui"):FindFirstChild("Chat") then
            local chat = player.PlayerGui.Chat
            
            local function monitorChatElement(child)
                if child:IsA("TextLabel") or child:IsA("TextBox") then
                    child:GetPropertyChangedSignal("Text"):Connect(function()
                        if not StateManager.scriptActive then return end
                        
                        local text = child.Text or ""
                        if string.find(string.lower(text), "feeling jolly") then
                            HTTPClient.Queue({
                                webhookURL = SettingsManager.Get("webhookURL"),
                                isPlainText = true,
                                message = "A Christmas Chest Rift has spawned!",
                                shouldPing = true
                            })
                        end
                    end)
                end
            end
            
            for _, child in pairs(chat:GetDescendants()) do
                monitorChatElement(child)
            end
            
            chat.DescendantAdded:Connect(monitorChatElement)
        end
    end)
    
    ChatMonitor.initialized = true
    print("âœ“ ChatMonitor initialized")
end

-- ============================================================================
-- SECTION 16: GUI MANAGER (Simplified but Complete)
-- ============================================================================

local GUIManager = {
    gui = nil,
    initialized = false
}

-- Create GUI (simplified version - full GUI would be very long)
function GUIManager.Init()
    if GUIManager.initialized then return end
    
    -- Create ScreenGui
    local g = Instance.new("ScreenGui")
    g.Name = "BubblegumAutoHatch"
    g.ResetOnSpawn = false
    g.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    g.Parent = LocalPlayer.PlayerGui
    
    -- Main frame
    local f = Instance.new("Frame")
    f.Size = UDim2.new(0, Config.GUI.WIDTH, 0, Config.GUI.HEIGHT)
    f.Position = UDim2.new(0.5, -Config.GUI.WIDTH/2, 0.5, -Config.GUI.HEIGHT/2)
    f.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    f.BorderSizePixel = 0
    f.Parent = g
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, Config.GUI.CORNER_RADIUS)
    corner.Parent = f
    
    -- Auto-hatch button
    local hatchBtn = Instance.new("TextButton")
    hatchBtn.Size = UDim2.new(0, 200, 0, 40)
    hatchBtn.Position = UDim2.new(0.5, -100, 0, 20)
    hatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    hatchBtn.Text = "Auto Hatch: OFF"
    hatchBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    hatchBtn.TextSize = 16
    hatchBtn.Font = Enum.Font.GothamBold
    hatchBtn.BorderSizePixel = 0
    hatchBtn.Parent = f
    
    hatchBtn.MouseButton1Click:Connect(function()
        AutoHatch.Toggle()
        hatchBtn.Text = StateManager.autoHatchEnabled and "Auto Hatch: ON" or "Auto Hatch: OFF"
        hatchBtn.BackgroundColor3 = StateManager.autoHatchEnabled and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    end)
    
    -- Webhook URL input
    local webhookLabel = Instance.new("TextLabel")
    webhookLabel.Size = UDim2.new(0, 180, 0, 20)
    webhookLabel.Position = UDim2.new(0.5, -90, 0, 70)
    webhookLabel.BackgroundTransparency = 1
    webhookLabel.Text = "Webhook URL:"
    webhookLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    webhookLabel.TextSize = 12
    webhookLabel.Font = Enum.Font.Gotham
    webhookLabel.TextXAlignment = Enum.TextXAlignment.Left
    webhookLabel.Parent = f
    
    local webhookInput = Instance.new("TextBox")
    webhookInput.Size = UDim2.new(0, 360, 0, 30)
    webhookInput.Position = UDim2.new(0.5, -180, 0, 90)
    webhookInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    webhookInput.Text = SettingsManager.Get("webhookURL") or ""
    webhookInput.TextColor3 = Color3.fromRGB(255, 255, 255)
    webhookInput.TextSize = 12
    webhookInput.Font = Enum.Font.Gotham
    webhookInput.PlaceholderText = "Enter Discord webhook URL"
    webhookInput.BorderSizePixel = 0
    webhookInput.Parent = f
    
    webhookInput.FocusLost:Connect(function()
        SettingsManager.Set("webhookURL", webhookInput.Text)
        SettingsManager.Save()
    end)
    
    -- Rift toggle
    local riftToggle = Instance.new("TextButton")
    riftToggle.Size = UDim2.new(0, 200, 0, 40)
    riftToggle.Position = UDim2.new(0.5, -100, 0, 130)
    riftToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    riftToggle.Text = "Rift Detection: OFF"
    riftToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
    riftToggle.TextSize = 14
    riftToggle.Font = Enum.Font.GothamBold
    riftToggle.BorderSizePixel = 0
    riftToggle.Parent = f
    
    riftToggle.MouseButton1Click:Connect(function()
        StateManager.riftAutoTeleportEnabled = not StateManager.riftAutoTeleportEnabled
        riftToggle.Text = StateManager.riftAutoTeleportEnabled and "Rift Detection: ON" or "Rift Detection: OFF"
        riftToggle.BackgroundColor3 = StateManager.riftAutoTeleportEnabled and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    end)
    
    -- Close button
    local closeBtn = Instance.new("TextButton")
    closeBtn.Size = UDim2.new(0, 100, 0, 30)
    closeBtn.Position = UDim2.new(0.5, -50, 1, -40)
    closeBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    closeBtn.Text = "Close Script"
    closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeBtn.TextSize = 14
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.BorderSizePixel = 0
    closeBtn.Parent = f
    
    closeBtn.MouseButton1Click:Connect(function()
        StateManager.scriptActive = false
        AutoHatch.Stop()
        PetDetector.Disconnect()
        g:Destroy()
    end)
    
    GUIManager.gui = g
    GUIManager.initialized = true
    print("âœ“ GUIManager initialized")
end

-- ============================================================================
-- SECTION 17: MAIN ORCHESTRATOR
-- ============================================================================

-- Initialize all systems
task.wait(1) -- Wait for modules to load

PetDetector.Init()
RiftManager.Init()
EggMonitor.Start()
PlayerTracker.Init()
ChatMonitor.Init()
GUIManager.Init()

print("========================================")
print("âœ“ All systems initialized")
print("Ready! Click 'Auto Hatch' to start")
print("========================================")

