-- BUBBLEGUM SIMULATOR - AUTO HATCH & SECRET NOTIFIER
-- Version 4.0 - Granular detection, admin abuse mode, and egg count monitoring

local P = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local VIM = game:GetService("VirtualInputManager")
local HttpService = game:GetService("HttpService")
local TextChatService = game:GetService("TextChatService")
local p = P.LocalPlayer

-- Detection Settings (moved to GUI toggle button in Extra tab)

-- Special Pets (pets that should receive special notifications)
-- Add pet names here (case insensitive, supports spaces)
local SPECIAL_PETS = {
    "Morning Star",
    "Christmas Robot",
    "Rumblecon God",
    "The Leviathan",
    "Sylently's Pet",
    "Giant Nert's Pufferfish"
    -- Add more pet names here as needed
}

-- Pre-compute lowercase special pets for faster lookup (optimization)
local SPECIAL_PETS_LOWER = {}
for _, petName in ipairs(SPECIAL_PETS) do
    SPECIAL_PETS_LOWER[string.lower(petName)] = true
end

print("========================================")
print("BUBBLEGUM AUTO HATCH & NOTIFIER")
print("Version: 4.0")
print("========================================")

-- Load required modules
local Remote = nil
local ItemUtil = nil
local PetsData = nil
local PetUtil = nil
local FormatCommas = nil
local LocalData = nil

-- Settings
local autoHatchEnabled = false
local webhookURL = ""
local discordUserID = ""
local riftDetectionEnabled = false
local playerTrackingEnabled = true -- Default to ON

-- Granular Secret Detection Settings (cascading logic)
local secretNotifyNormal = true -- Default ON
local secretNotifyShiny = false -- Default OFF
local secretNotifyMythic = false -- Default OFF
local secretNotifyShinyMythic = false -- Default OFF
local secretNotifyXL = false -- Default OFF

-- Granular Secret Ping Settings
local secretPingNormal = false -- Default OFF
local secretPingShiny = false -- Default OFF
local secretPingMythic = false -- Default OFF
local secretPingShinyMythic = false -- Default OFF
local secretPingXL = false -- Default OFF

-- Secret Rarity Filter
local secretFilterUnder1B = false -- Default OFF (notify all rarities)

-- Infinity Detection Settings
local infinityNotifyEnabled = true -- Default ON
local infinityPingEnabled = true -- Default ON

-- XL and Legendary Detection Settings (non-secret)
local xlDetectionEnabled = false -- Default OFF
local xlPingEnabled = false -- Default OFF
local legendaryDetectionEnabled = false -- Default OFF
local legendaryPingEnabled = false -- Default OFF

-- Admin Abuse Mode
local adminAbuseActive = false
local adminAbuseSecretSettings = {
	notifyNormal = true,
	notifyShiny = true,
	notifyMythic = true,
	notifyShinyMythic = true,
	notifyXL = true,
	pingNormal = false,
	pingShiny = false,
	pingMythic = false,
	pingShinyMythic = true,
	pingXL = true,
	filterUnder1B = false
}
local adminAbuseHatchedPets = {} -- Tracks all secrets/infinities during admin abuse

-- Script start time for runtime calculation
local scriptStartTime = os.time()

-- Settings file path
local SETTINGS_FILE = "bubblegum_settings.json"

-- Load settings from file (non-blocking, won't break if it fails)
local function loadSettings()
    if not readfile or not isfile or not HttpService then
        return -- File system not available, use defaults
    end
    
    local success, result = pcall(function()
        if isfile(SETTINGS_FILE) then
            local content = readfile(SETTINGS_FILE)
            if content and content ~= "" then
                local decoded = HttpService:JSONDecode(content)
                if decoded and type(decoded) == "table" then
                    if decoded.webhookURL and type(decoded.webhookURL) == "string" then
                        webhookURL = decoded.webhookURL
                    end
                    if decoded.discordUserID and type(decoded.discordUserID) == "string" then
                        discordUserID = decoded.discordUserID
                    end
                    -- Load toggle states
                    if decoded.riftDetectionEnabled ~= nil then
                        riftDetectionEnabled = decoded.riftDetectionEnabled
                    end
                    if decoded.playerTrackingEnabled ~= nil then
                        playerTrackingEnabled = decoded.playerTrackingEnabled
                    end
                    -- Load granular secret detection settings
                    if decoded.secretNotifyNormal ~= nil then
                        secretNotifyNormal = decoded.secretNotifyNormal
                    end
                    if decoded.secretNotifyShiny ~= nil then
                        secretNotifyShiny = decoded.secretNotifyShiny
                    end
                    if decoded.secretNotifyMythic ~= nil then
                        secretNotifyMythic = decoded.secretNotifyMythic
                    end
                    if decoded.secretNotifyShinyMythic ~= nil then
                        secretNotifyShinyMythic = decoded.secretNotifyShinyMythic
                    end
                    if decoded.secretNotifyXL ~= nil then
                        secretNotifyXL = decoded.secretNotifyXL
                    end
                    -- Load granular secret ping settings
                    if decoded.secretPingNormal ~= nil then
                        secretPingNormal = decoded.secretPingNormal
                    end
                    if decoded.secretPingShiny ~= nil then
                        secretPingShiny = decoded.secretPingShiny
                    end
                    if decoded.secretPingMythic ~= nil then
                        secretPingMythic = decoded.secretPingMythic
                    end
                    if decoded.secretPingShinyMythic ~= nil then
                        secretPingShinyMythic = decoded.secretPingShinyMythic
                    end
                    if decoded.secretPingXL ~= nil then
                        secretPingXL = decoded.secretPingXL
                    end
                    -- Load secret filter
                    if decoded.secretFilterUnder1B ~= nil then
                        secretFilterUnder1B = decoded.secretFilterUnder1B
                    end
                    -- Load infinity settings
                    if decoded.infinityNotifyEnabled ~= nil then
                        infinityNotifyEnabled = decoded.infinityNotifyEnabled
                    end
                    if decoded.infinityPingEnabled ~= nil then
                        infinityPingEnabled = decoded.infinityPingEnabled
                    end
                    -- Load XL and Legendary settings
                    if decoded.xlDetectionEnabled ~= nil then
                        xlDetectionEnabled = decoded.xlDetectionEnabled
                    end
                    if decoded.xlPingEnabled ~= nil then
                        xlPingEnabled = decoded.xlPingEnabled
                    end
                    if decoded.legendaryDetectionEnabled ~= nil then
                        legendaryDetectionEnabled = decoded.legendaryDetectionEnabled
                    end
                    if decoded.legendaryPingEnabled ~= nil then
                        legendaryPingEnabled = decoded.legendaryPingEnabled
                    end
                    -- Load admin abuse settings
                    if decoded.adminAbuseSecretSettings and type(decoded.adminAbuseSecretSettings) == "table" then
                        adminAbuseSecretSettings = decoded.adminAbuseSecretSettings
                    end
                    print("‚úì Settings loaded from file")
                    return true
                end
            end
        end
        return false
    end)
    
    if not success then
        -- Silently fail, use defaults
    end
end

-- Save settings to file (non-blocking, won't break if it fails)
local function saveSettings()
    if not writefile or not HttpService then
        return -- File system not available, skip saving
    end
    
    pcall(function()
        local settings = {
            webhookURL = webhookURL or "",
            discordUserID = discordUserID or "",
            -- Save toggle states
            riftDetectionEnabled = riftDetectionEnabled,
            playerTrackingEnabled = playerTrackingEnabled,
            -- Save granular secret detection settings
            secretNotifyNormal = secretNotifyNormal,
            secretNotifyShiny = secretNotifyShiny,
            secretNotifyMythic = secretNotifyMythic,
            secretNotifyShinyMythic = secretNotifyShinyMythic,
            secretNotifyXL = secretNotifyXL,
            -- Save granular secret ping settings
            secretPingNormal = secretPingNormal,
            secretPingShiny = secretPingShiny,
            secretPingMythic = secretPingMythic,
            secretPingShinyMythic = secretPingShinyMythic,
            secretPingXL = secretPingXL,
            -- Save secret filter
            secretFilterUnder1B = secretFilterUnder1B,
            -- Save infinity settings
            infinityNotifyEnabled = infinityNotifyEnabled,
            infinityPingEnabled = infinityPingEnabled,
            -- Save XL and Legendary settings
            xlDetectionEnabled = xlDetectionEnabled,
            xlPingEnabled = xlPingEnabled,
            legendaryDetectionEnabled = legendaryDetectionEnabled,
            legendaryPingEnabled = legendaryPingEnabled,
            -- Save admin abuse settings
            adminAbuseSecretSettings = adminAbuseSecretSettings
        }
        local json = HttpService:JSONEncode(settings)
        writefile(SETTINGS_FILE, json)
        print("‚úì Settings saved")
    end)
end

-- Webhook queue for rate limiting
local webhookQueue = {}
local isSendingWebhook = false
local messagesRemainingWithDelay = 0 -- Counter for messages that need 2s delay after rate limit

-- Cache for thumbnail URLs to avoid repeated HTTP requests
local thumbnailUrlCache = {}

-- Script state
local scriptActive = true
local hatchEventConnection = nil

-- Load modules
local function loadModules()
    -- Load Remote
    local success, remoteModule = pcall(function()
        return require(RS.Shared.Framework.Network.Remote)
    end)
    if success and remoteModule then
        Remote = remoteModule
        print("‚úì Loaded Remote module")
    end
    
    -- Load ItemUtil
    local success2, itemUtil = pcall(function()
        return require(RS.Shared.Utils.Stats.ItemUtil)
    end)
    if success2 and itemUtil then
        ItemUtil = itemUtil
        print("‚úì Loaded ItemUtil")
    end
    
    -- Load Pets data for images
    local success3, petsData = pcall(function()
        return require(RS.Shared.Data.Pets)
    end)
    if success3 and petsData then
        PetsData = petsData
        print("‚úì Loaded Pets data")
    end
    
    -- Load PetUtil for chance calculation
    local success4, petUtil = pcall(function()
        return require(RS.Shared.Utils.Stats.PetUtil)
    end)
    if success4 and petUtil then
        PetUtil = petUtil
        print("‚úì Loaded PetUtil")
    end
    
    -- Load FormatCommas for number formatting
    local success5, formatCommas = pcall(function()
        return require(RS.Shared.Framework.Utilities.String.FormatCommas)
    end)
    if success5 and formatCommas then
        FormatCommas = formatCommas
        print("‚úì Loaded FormatCommas")
    end
    
    -- Load LocalData for player stats
    local success6, localData = pcall(function()
        return require(RS.Client.Framework.Services.LocalData)
    end)
    if success6 and localData then
        LocalData = localData
        print("‚úì Loaded LocalData")
    end
end

loadModules()

-- Load saved settings (before GUI creation, non-blocking)
loadSettings()

-- HTTP for Delta Mobile (using the working method from testing)
local httpLib = nil
local httpLibName = nil
if request then
    httpLib = function(url, method, headers, body)
        local success, res, err = pcall(function()
            return request({Url=url, Method=method, Headers=headers or {}, Body=body})
        end)
        if success and res then
            local status = res.StatusCode or (res.Success and 200 or (res.success and 200 or 0))
            local body = res.Body or res.body or ""
            local ok = res.Success or res.success or status == 200 or status == 204
            return ok, body, status
        end
        return false, err or "Request exception", 0
    end
    httpLibName = "request"
end

-- Function to get Discord-compatible thumbnail URL from Roblox asset ID (with caching)
local function getThumbnailUrl(assetId)
    if not assetId then
        return nil
    end
    
    -- Check cache first
    if thumbnailUrlCache[assetId] then
        return thumbnailUrlCache[assetId]
    end
    
    local url = "https://thumbnails.roproxy.com/v1/assets?assetIds=" .. assetId .. "&size=420x420&format=Png&isCircular=false"
    
    local success, response, errorMsg = pcall(function()
        -- Try httpLib first (we know this works for webhooks)
        if httpLib then
            local ok, body, status = httpLib(url, "GET", {}, "")
            if ok and status == 200 then
                return body, nil
            else
                return nil, "httpLib returned status " .. tostring(status)
            end
        elseif HttpService and HttpService.GetAsync then
            return HttpService:GetAsync(url), nil
        else
            return nil, "No HTTP method available"
        end
    end)
    
    if not success then
        return nil
    end
    
    if not response then
        return nil
    end
    
    -- Try to decode JSON
    local success2, decoded = pcall(function()
        if HttpService and HttpService.JSONDecode then
            return HttpService:JSONDecode(response)
        end
        return nil
    end)
    
    if not success2 then
        return nil
    end
    
    if decoded and decoded.data and decoded.data[1] and decoded.data[1].imageUrl then
        local imageUrl = decoded.data[1].imageUrl
        -- Cache the result
        thumbnailUrlCache[assetId] = imageUrl
        return imageUrl
    end
    
    return nil
end

-- JSON encoder (properly handles nested structures)
local function jsonEncode(t)
    local function encodeValue(v, depth)
        depth = depth or 0
        if depth > 10 then return "null" end -- Prevent infinite recursion
        
        if type(v) == "string" then
            -- Escape special characters
            v = v:gsub("\\", "\\\\")
            v = v:gsub('"', '\\"')
            v = v:gsub("\n", "\\n")
            v = v:gsub("\r", "\\r")
            v = v:gsub("\t", "\\t")
            return '"' .. v .. '"'
        elseif type(v) == "number" then
            return tostring(v)
        elseif type(v) == "boolean" then
            return v and "true" or "false"
        elseif type(v) == "table" then
            -- Check if it's an array
            local isArray = false
            local maxIndex = 0
            for k in pairs(v) do
                if type(k) == "number" then
                    maxIndex = math.max(maxIndex, k)
                end
            end
            isArray = maxIndex > 0 and maxIndex == #v
            
            local parts = {}
            if isArray then
                for i = 1, maxIndex do
                    table.insert(parts, encodeValue(v[i], depth + 1))
                end
                return "[" .. table.concat(parts, ",") .. "]"
            else
                for k, val in pairs(v) do
                    if val ~= nil then
                        local key = type(k) == "string" and ('"' .. k .. '"') or tostring(k)
                        table.insert(parts, key .. ":" .. encodeValue(val, depth + 1))
                    end
                end
                return "{" .. table.concat(parts, ",") .. "}"
            end
        else
            return "null"
        end
    end
    return encodeValue(t, 0)
end

-- Helper function to get embed color based on pet attributes
local function getEmbedColor(shiny, mythic, xl, isSpecialPet)
    if isSpecialPet then
        -- Infinity pet colors
        if shiny and mythic and xl then
            return 8388608 -- Maroon #800000
        elseif mythic and xl then
            return 14745599 -- Pastel pink/purple #E0B0FF
        elseif shiny and xl then
            return 12779520 -- Bright lime green lighter #C2FF00
        elseif shiny and mythic then
            return 16738740 -- Bright hot pink #FF1493
        elseif xl then
            return 16760576 -- Orange closer to yellow #FFA700
        elseif mythic then
            return 16711935 -- Bright magenta #FF00FF
        elseif shiny then
            return 65280 -- Bright pure green #00FF00
        else
            return 65535 -- Cyan #00FFFF
        end
    else
        -- Regular pet colors
        if shiny and mythic and xl then
            return 13369344 -- Darker red #CC0000
        elseif mythic and xl then
            return 255 -- Dark bright blue #0000FF
        elseif shiny and xl then
            return 16776960 -- Pure yellow #FFFF00
        elseif shiny and mythic then
            return 16711680 -- Pure red #FF0000
        elseif xl then
            return 16744448 -- Deep bright orange #FF6600
        elseif mythic then
            return 10494192 -- Purple #A020F0
        elseif shiny then
            return 16766720 -- Slightly darker yellow but bright (Gold) #FFD700
        else
            return 12303291 -- Light grey #BBBBBB
        end
    end
end

-- Helper function to check if a pet is in the special pets list (case insensitive)
-- Optimized: uses pre-computed lowercase lookup table
local function isSpecialPet(petName)
    if not petName then return false end
    return SPECIAL_PETS_LOWER[string.lower(petName)] == true
end

-- Helper function to check if rarity is Infinity (case insensitive)
local function isInfinityRarity(rarity)
    if not rarity then return false end
    return string.lower(tostring(rarity)) == "infinity"
end

-- Function to send plain text webhook
local function sendPlainTextWebhook(message, shouldPing)
    if not httpLib or webhookURL == "" then 
        return true
    end
    
    local content = message
    if shouldPing and discordUserID ~= "" then
        content = "<@" .. discordUserID .. "> " .. message
    end
    
    local payload = {
        content = content
    }
    
    local jsonPayload = jsonEncode(payload)
    
    local success, response, status = pcall(function()
        return httpLib(webhookURL, "POST", {
            ["Content-Type"] = "application/json"
        }, jsonPayload)
    end)
    
    if success and (status == 200 or status == 204) then
        return true
    elseif success and status == 429 then
        return false -- Return false to trigger retry
    else
        return true -- Return true for other errors to not retry
    end
end

-- Function to send debug webhook (no ping, plain text)
local function sendDebugWebhook(message)
    if not httpLib or webhookURL == "" then 
        return true
    end
    
    local embed = {
        title = "üîç Debug Info",
        description = message,
        color = 8421504, -- Grey color for debug
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    local payload = {
        embeds = {embed}
        -- No content field = no ping
    }
    
    local jsonPayload = jsonEncode(payload)
    
    local success, response, status = pcall(function()
        return httpLib(webhookURL, "POST", {
            ["Content-Type"] = "application/json"
        }, jsonPayload)
    end)
    
    if success and status == 200 then
        print("‚úì Debug webhook sent successfully")
        return true
    elseif success and status == 429 then
        print("‚úó Debug webhook rate limited (429)")
        return false -- Return false to trigger retry
    else
        print("‚úó Debug webhook failed: status=" .. tostring(status))
        return true -- Return true for other errors to not retry
    end
end

-- Helper function to get total eggs hatched count
local function getTotalEggsHatched()
    if not LocalData then
        return nil
    end
    
    local success, data = pcall(function()
        return LocalData:Get() -- Use :Get() not :GetData()
    end)
    
    if not success or not data then
        return nil
    end
    
    if not data.Stats then
        return nil
    end
    
    -- Try multiple possible field names
    local hatches = data.Stats.Hatches 
        or data.Stats.TotalEggsOpened 
        or data.Stats["ü•öHatches"]
        or data.Stats["ü•ö Hatches"]
    
    return hatches
end

-- Function to send special webhook (with infinity colors and message)
local function sendSpecialDiscordNotificationInternal(petName, shiny, mythic, xl, eggName, rarity, pet, petImageUrl, isInfinity, shouldPing)
    if not httpLib or webhookURL == "" then 
        return true
    end
    
    -- Get player name
    local playerName = p.Name or "Unknown Player"
    
    -- Get total eggs hatched
    local eggsHatched = getTotalEggsHatched()
    
    -- Build pet name with prefix (XL goes AFTER shiny/mythic)
    local fullPetName = ""
    if shiny and mythic then
        fullPetName = "Shiny Mythic "
    elseif shiny then
        fullPetName = "Shiny "
    elseif mythic then
        fullPetName = "Mythic "
    end
    
    if xl then
        fullPetName = fullPetName .. "XL "
    end
    
    fullPetName = fullPetName .. petName
    
    -- Determine color
    local embedColor = getEmbedColor(shiny, mythic, xl, true)
    
    -- Build mention (for Discord ping) - only if shouldPing is true
    local mention = ""
    if shouldPing and discordUserID ~= "" then
        mention = "<@" .. discordUserID .. ">"
    end
    
    -- Calculate probability if PetUtil is available
    local probabilityText = nil
    if PetUtil and pet then
        local success, petChance = pcall(function()
            return PetUtil:GetChance(pet)
        end)
        if success and petChance and petChance > 0 then
            local denominator = math.ceil(100 / petChance)
            if FormatCommas then
                probabilityText = "1/" .. FormatCommas(denominator)
            else
                local formatted = tostring(denominator)
                formatted = formatted:reverse():gsub("(%d%d%d)", "%1,"):reverse()
                formatted = formatted:gsub("^,", "")
                probabilityText = "1/" .. formatted
            end
        end
    end
    
    -- Determine "a" or "an" for the pet name
    local article = "a"
    if not shiny and not mythic and petName then
        local firstLetter = string.lower(string.sub(petName, 1, 1))
        if firstLetter == "a" or firstLetter == "e" or firstLetter == "i" or firstLetter == "o" or firstLetter == "u" then
            article = "an"
        end
    end
    
    -- Build description (infinity message is now in title)
    local description = "**" .. playerName .. "** hatched " .. article .. " **" .. fullPetName .. "**!"
    
    -- Build fields
    local fields = {
        {
            name = "Hatched",
            value = fullPetName,
            inline = false
        }
    }
    
    -- Add probability or rarity field
    if probabilityText then
        table.insert(fields, {
            name = "Rarity",
            value = probabilityText,
            inline = true
        })
    elseif rarity then
        table.insert(fields, {
            name = "Rarity",
            value = rarity,
            inline = true
        })
    end
    
    -- Build embed
    local embed = {
        title = "üéâ Congratulations! You hatched an ***INFINITY***! üéâ",
        description = description,
        color = embedColor,
        fields = fields,
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    -- Add thumbnail if pet image URL is available
    if petImageUrl then
        embed.thumbnail = {
            url = petImageUrl
        }
    end
    
    -- Add footer with eggs hatched count (small text at bottom)
    if eggsHatched then
        local formattedCount = eggsHatched
        if FormatCommas then
            formattedCount = FormatCommas(eggsHatched)
        else
            -- Manual formatting
            formattedCount = tostring(eggsHatched):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")
        end
        embed.footer = {
            text = "Eggs hatched: " .. formattedCount
        }
    end
    
    -- Build payload
    local payload = {
        content = mention, -- Ping in content field
        embeds = {embed}
    }
    
    local jsonPayload = jsonEncode(payload)
    
    local success, response, status = pcall(function()
        return httpLib(webhookURL, "POST", {
            ["Content-Type"] = "application/json"
        }, jsonPayload)
    end)
    
    if success and status == 200 then
        print("‚úì Special Discord notification sent successfully")
        return true
    elseif success and status == 429 then
        print("‚úó Special Discord notification rate limited (429)")
        return false -- Return false to trigger retry
    else
        print("‚úó Special Discord notification failed: status=" .. tostring(status))
        return true -- Return true for other errors to not retry
    end
end

-- Function to send simple XL pet notification (light grey, simple format)
local function sendXLNotification(petName, shiny, mythic, xl, petImageUrl, shouldPing)
    if not httpLib or webhookURL == "" then 
        return true -- Return true to not retry if webhook not configured
    end
    
    -- Get player name
    local playerName = p.Name or "Unknown Player"
    
    -- Get total eggs hatched
    local eggsHatched = getTotalEggsHatched()
    
    -- Build pet name with prefix (XL goes AFTER shiny/mythic)
    local fullPetName = ""
    if shiny and mythic then
        fullPetName = "Shiny Mythic "
    elseif shiny then
        fullPetName = "Shiny "
    elseif mythic then
        fullPetName = "Mythic "
    end
    
    if xl then
        fullPetName = fullPetName .. "XL "
    end
    
    fullPetName = fullPetName .. petName
    
    -- Light grey color
    local embedColor = 11053224 -- Light grey
    
    -- Determine "a" or "an"
    local article = "a"
    if not shiny and not mythic and petName then
        local firstLetter = string.lower(string.sub(petName, 1, 1))
        if firstLetter == "a" or firstLetter == "e" or firstLetter == "i" or firstLetter == "o" or firstLetter == "u" then
            article = "an"
        end
    end
    
    -- Build description
    local description = "**" .. playerName .. "** hatched " .. article .. " **" .. fullPetName .. "**!"
    
    -- Build mention (for Discord ping)
    local mention = ""
    if shouldPing and discordUserID ~= "" then
        mention = "<@" .. discordUserID .. ">"
    end
    
    -- Build embed
    local embed = {
        title = "üéâ XL Pet Hatched!",
        description = description,
        color = embedColor,
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    -- Add thumbnail if pet image URL is available
    if petImageUrl then
        embed.thumbnail = {
            url = petImageUrl
        }
    end
    
    -- Add footer with eggs hatched count
    if eggsHatched then
        local formattedCount = eggsHatched
        if FormatCommas then
            formattedCount = FormatCommas(eggsHatched)
        else
            formattedCount = tostring(eggsHatched):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")
        end
        embed.footer = {
            text = "Eggs hatched: " .. formattedCount
        }
    end
    
    -- Build payload
    local payload = {
        content = mention ~= "" and mention or nil,
        embeds = {embed}
    }
    
    local headers = {["Content-Type"] = "application/json"}
    local json = jsonEncode(payload)
    local success, response, status = httpLib(webhookURL, "POST", headers, json)
    
    if success and (status == 200 or status == 204) then
        print("‚úì XL notification sent! Status: " .. tostring(status))
        return true
    elseif status == 429 then
        print("‚úó XL notification rate limited (429), will retry...")
        return false
    else
        print("‚úó XL notification failed! Status: " .. tostring(status))
        return true
    end
end

-- Function to send simple Legendary pet notification (light grey, simple format)
local function sendLegendaryNotification(petName, shiny, mythic, xl, petImageUrl, shouldPing)
    if not httpLib or webhookURL == "" then 
        return true -- Return true to not retry if webhook not configured
    end
    
    -- Get player name
    local playerName = p.Name or "Unknown Player"
    
    -- Get total eggs hatched
    local eggsHatched = getTotalEggsHatched()
    
    -- Build pet name with prefix (XL goes AFTER shiny/mythic)
    local fullPetName = ""
    if shiny and mythic then
        fullPetName = "Shiny Mythic "
    elseif shiny then
        fullPetName = "Shiny "
    elseif mythic then
        fullPetName = "Mythic "
    end
    
    if xl then
        fullPetName = fullPetName .. "XL "
    end
    
    fullPetName = fullPetName .. petName
    
    -- Light grey color
    local embedColor = 11053224 -- Light grey
    
    -- Determine "a" or "an"
    local article = "a"
    if not shiny and not mythic and petName then
        local firstLetter = string.lower(string.sub(petName, 1, 1))
        if firstLetter == "a" or firstLetter == "e" or firstLetter == "i" or firstLetter == "o" or firstLetter == "u" then
            article = "an"
        end
    end
    
    -- Build description
    local description = "**" .. playerName .. "** hatched " .. article .. " **" .. fullPetName .. "**!"
    
    -- Build mention (for Discord ping)
    local mention = ""
    if shouldPing and discordUserID ~= "" then
        mention = "<@" .. discordUserID .. ">"
    end
    
    -- Build embed
    local embed = {
        title = "‚ú® Legendary Pet Hatched!",
        description = description,
        color = embedColor,
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    -- Add thumbnail if pet image URL is available
    if petImageUrl then
        embed.thumbnail = {
            url = petImageUrl
        }
    end
    
    -- Add footer with eggs hatched count
    if eggsHatched then
        local formattedCount = eggsHatched
        if FormatCommas then
            formattedCount = FormatCommas(eggsHatched)
        else
            formattedCount = tostring(eggsHatched):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")
        end
        embed.footer = {
            text = "Eggs hatched: " .. formattedCount
        }
    end
    
    -- Build payload
    local payload = {
        content = mention ~= "" and mention or nil,
        embeds = {embed}
    }
    
    local headers = {["Content-Type"] = "application/json"}
    local json = jsonEncode(payload)
    local success, response, status = httpLib(webhookURL, "POST", headers, json)
    
    if success and (status == 200 or status == 204) then
        print("‚úì Legendary notification sent! Status: " .. tostring(status))
        return true
    elseif status == 429 then
        print("‚úó Legendary notification rate limited (429), will retry...")
        return false
    else
        print("‚úó Legendary notification failed! Status: " .. tostring(status))
        return true
    end
end

-- Function to send webhook (with 429 retry logic) - MUST be defined first
local function sendDiscordNotificationInternal(petName, shiny, mythic, xl, eggName, rarity, pet, petImageUrl, shouldPing)
    if not httpLib or webhookURL == "" then 
        return true -- Return true to not retry if webhook not configured
    end
    
    -- Get player name
    local playerName = p.Name or "Unknown Player"
    
    -- Get total eggs hatched
    local eggsHatched = getTotalEggsHatched()
    
    -- Build pet name with prefix (XL goes AFTER shiny/mythic)
    local fullPetName = ""
    if shiny and mythic then
        fullPetName = "Shiny Mythic "
    elseif shiny then
        fullPetName = "Shiny "
    elseif mythic then
        fullPetName = "Mythic "
    end
    
    if xl then
        fullPetName = fullPetName .. "XL "
    end
    
    fullPetName = fullPetName .. petName
    
    -- Determine color
    local embedColor = getEmbedColor(shiny, mythic, xl, false)
    
    -- Build mention (for Discord ping) - only if shouldPing is true
    local mention = ""
    if shouldPing and discordUserID ~= "" then
        mention = "<@" .. discordUserID .. ">"
    end
    
    -- Calculate probability if PetUtil is available
    local probabilityText = nil
    if PetUtil and pet then
        local success, petChance = pcall(function()
            return PetUtil:GetChance(pet)
        end)
        if success and petChance and petChance > 0 then
            local denominator = math.ceil(100 / petChance)
            if FormatCommas then
                probabilityText = "1/" .. FormatCommas(denominator)
            else
                -- Manual formatting for large numbers
                local formatted = tostring(denominator)
                -- Add commas every 3 digits from right
                formatted = formatted:reverse():gsub("(%d%d%d)", "%1,"):reverse()
                formatted = formatted:gsub("^,", "")
                probabilityText = "1/" .. formatted
            end
        end
    end
    
    -- Determine "a" or "an" for the pet name
    -- Use "a" if shiny/mythic/shiny mythic (regardless of vowel)
    -- Use "an" if pet name starts with a vowel AND is not shiny/mythic
    -- Use "a" if pet name starts with a consonant
    local article = "a"
    if not shiny and not mythic and petName then
        local firstLetter = string.lower(string.sub(petName, 1, 1))
        if firstLetter == "a" or firstLetter == "e" or firstLetter == "i" or firstLetter == "o" or firstLetter == "u" then
            article = "an"
        end
    end
    
    -- Build description
    local description = "**" .. playerName .. "** hatched " .. article .. " **" .. fullPetName .. "**!"
    
    -- Build fields (remove Egg, conditionally include Rarity/Probability)
    local fields = {
        {
            name = "Hatched",
            value = fullPetName,
            inline = false
        }
    }
    
    -- Add probability or rarity field
    if probabilityText then
        table.insert(fields, {
            name = "Rarity",
            value = probabilityText,
            inline = true
        })
    elseif rarity then
        table.insert(fields, {
            name = "Rarity",
            value = rarity,
            inline = true
        })
    end
    
    -- Build embed (always use full format, no simplification)
    local embed = {
        title = "üéâ Congratulations!",
        description = description,
        color = embedColor,
        fields = fields,
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    -- Add thumbnail if pet image URL is available
    if petImageUrl then
        embed.thumbnail = {
            url = petImageUrl
        }
    end
    
    -- Add footer with eggs hatched count (small text at bottom)
    if eggsHatched then
        local formattedCount = eggsHatched
        if FormatCommas then
            formattedCount = FormatCommas(eggsHatched)
        else
            -- Manual formatting
            formattedCount = tostring(eggsHatched):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")
        end
        embed.footer = {
            text = "Eggs hatched: " .. formattedCount
        }
    end
    
    -- Put mention in content field (required for Discord to actually ping)
    local payload = {
        content = mention ~= "" and mention or nil,
        embeds = {embed}
    }
    
    local headers = {["Content-Type"] = "application/json"}
    local json = jsonEncode(payload)
    local success, response, status = httpLib(webhookURL, "POST", headers, json)
    
    if success and (status == 200 or status == 204) then
        print("‚úì Discord notification sent! Status: " .. tostring(status))
        return true
    elseif status == 429 then
        -- Rate limited - return false to trigger retry
        print("‚úó Rate limited (429), will retry...")
        return false
    else
        print("‚úó Webhook failed!")
        print("  Status: " .. tostring(status))
        print("  Response: " .. tostring(response))
        -- For non-429 errors, return true to not retry (400 is likely permanent issue)
        return true
    end
end

-- Process webhook queue
local function processWebhookQueue()
    if isSendingWebhook or #webhookQueue == 0 or not scriptActive then
        return
    end
    
    isSendingWebhook = true
    
    spawn(function()
        while #webhookQueue > 0 and scriptActive do
            local webhookData = table.remove(webhookQueue, 1)
            
            -- Check message type
            if webhookData.isCustomEmbed then
                -- Custom embed (like admin abuse summary)
                local maxRetries = 5
                local retryCount = 0
                local success = false
                
                while retryCount < maxRetries and not success do
                    local jsonPayload = jsonEncode(webhookData.payload)
                    local ok, response, status = httpLib(webhookURL, "POST", {
                        ["Content-Type"] = "application/json"
                    }, jsonPayload)
                    
                    success = ok and (status == 200 or status == 204)
                    
                    if not success and status == 429 then
                        retryCount = retryCount + 1
                        if retryCount < maxRetries then
                            task.wait(1)
                        end
                    else
                        break
                    end
                end
                
                if not success then
                    table.insert(webhookQueue, 1, webhookData)
                    messagesRemainingWithDelay = 5
                end
            elseif webhookData.isPlainText then
                -- Plain text message
                local maxRetries = 5
                local retryCount = 0
                local success = false
                
                while retryCount < maxRetries and not success do
                    success = sendPlainTextWebhook(webhookData.message, webhookData.shouldPing or false)
                    
                    if not success then
                        retryCount = retryCount + 1
                        if retryCount < maxRetries then
                            task.wait(1)
                        end
                    end
                end
                
                if not success then
                    table.insert(webhookQueue, 1, webhookData)
                    messagesRemainingWithDelay = 5
                end
            elseif webhookData.isDebug and webhookData.debugMessage then
                -- Debug webhook
                local maxRetries = 5
                local retryCount = 0
                local success = false
                
                while retryCount < maxRetries and not success do
                    success = sendDebugWebhook(webhookData.debugMessage)
                    
                    if not success then
                        retryCount = retryCount + 1
                        if retryCount < maxRetries then
                            task.wait(1)
                        end
                    end
                end
                
                if not success then
                    table.insert(webhookQueue, 1, webhookData)
                    messagesRemainingWithDelay = 5
                end
            else
                -- Regular or special notification
                local petName = webhookData.petName
                local shiny = webhookData.shiny
                local mythic = webhookData.mythic
                local xl = webhookData.xl
                local eggName = webhookData.eggName
                local rarity = webhookData.rarity
                local pet = webhookData.pet
                -- OPTIMIZED: Fetch thumbnail URL lazily here (or use cached/pre-fetched URL)
                local petImageUrl = webhookData.petImageUrl
                if not petImageUrl and webhookData.petImageAssetId then
                    petImageUrl = getThumbnailUrl(webhookData.petImageAssetId)
                end
                local isSpecial = webhookData.isSpecial == true
                local isInfinity = webhookData.isInfinity == true
                local notificationType = webhookData.notificationType
                local shouldPing = webhookData.shouldPing or false
                
                local maxRetries = 5
                local retryCount = 0
                local success = false
                
                while retryCount < maxRetries and not success do
                    if isSpecial then
                        -- Infinity notification (with shouldPing parameter)
                        success = sendSpecialDiscordNotificationInternal(petName, shiny, mythic, xl, eggName, rarity, pet, petImageUrl, isInfinity, shouldPing)
                    elseif notificationType == "secret" then
                        -- Regular secret notification (with shouldPing parameter)
                        success = sendDiscordNotificationInternal(petName, shiny, mythic, xl, eggName, rarity, pet, petImageUrl, shouldPing)
                    elseif notificationType == "xl" then
                        -- Simple XL notification
                        success = sendXLNotification(petName, shiny, mythic, xl, petImageUrl, shouldPing)
                    elseif notificationType == "legendary" then
                        -- Simple Legendary notification
                        success = sendLegendaryNotification(petName, shiny, mythic, xl, petImageUrl, shouldPing)
                    else
                        -- Fallback to regular notification (old behavior)
                        success = sendDiscordNotificationInternal(petName, shiny, mythic, xl, eggName, rarity, pet, petImageUrl, false)
                    end
                    
                    if not success then
                        retryCount = retryCount + 1
                        if retryCount < maxRetries then
                            task.wait(1)
                        end
                    end
                end
                
                if not success then
                    table.insert(webhookQueue, 1, webhookData)
                    messagesRemainingWithDelay = 5
                end
            end
            
            -- Determine delay based on rate limit counter
            local delay = (messagesRemainingWithDelay > 0) and 2 or 1
            if messagesRemainingWithDelay > 0 then
                messagesRemainingWithDelay = messagesRemainingWithDelay - 1
            end
            
            -- Wait before sending next message in queue
            if #webhookQueue > 0 then
                task.wait(delay)
            end
        end
        
        isSendingWebhook = false
    end)
end

-- Public function to queue webhook (handles rate limiting)
-- OPTIMIZED: No longer blocks on thumbnail URL fetching
local function sendDiscordNotification(petName, shiny, mythic, xl, eggName, rarity, pet)
    -- Don't process if script is closed
    if not scriptActive then
        return
    end
    
    if webhookURL == "" then
        print("‚úó Webhook URL not set")
        return
    end
    
    if not httpLib then
        print("‚úó HTTP library not available")
        return
    end
    
    -- Get pet image asset ID (non-blocking, no HTTP call)
    local petImageAssetId = getPetImageAssetId(petName, shiny, mythic, xl)
    
    -- This function now just queues the notification with specified type and ping status
    -- The calling code (connectToEvents) determines notificationType and shouldPing
    
    -- NOTE: This function signature is now extended to accept notificationType and shouldPing
    -- But we're being called from the old signature, so we need to handle that
    -- For backward compatibility, we'll use the old logic if notificationType is not passed
    
    -- Check if this is a special pet
    local isSpecial = isSpecialPet(petName)
    local isInfinity = isInfinityRarity(rarity)
    
    -- If special pet, send special notification and debug message
    if isSpecial then
        -- Add special notification to queue
        table.insert(webhookQueue, {
            petName = petName,
            shiny = shiny,
            mythic = mythic,
            xl = xl,
            eggName = eggName,
            rarity = rarity,
            pet = pet,
            petImageAssetId = petImageAssetId, -- Store asset ID, fetch URL later
            isSpecial = true,
            isInfinity = isInfinity
        })
        
        -- Add debug message to queue (separate message, no ping)
        local debugMessage = isInfinity and 
            "The rarity of this pet is specified as Infinity" or 
            ("The rarity is not infinity. Rarity: " .. (rarity or "Unknown"))
        table.insert(webhookQueue, {
            debugMessage = debugMessage,
            isDebug = true
        })
    else
        -- Add regular notification to queue
        table.insert(webhookQueue, {
            petName = petName,
            shiny = shiny,
            mythic = mythic,
            xl = xl,
            eggName = eggName,
            rarity = rarity,
            pet = pet,
            petImageAssetId = petImageAssetId, -- Store asset ID, fetch URL later
            isSpecial = false
        })
    end
    
    -- Start processing queue if not already processing
    processWebhookQueue()
end

-- Helper function to get pet image asset ID (optimized, non-blocking)
local function getPetImageAssetId(petName, shiny, mythic, xl)
    if not PetsData or not petName then
        return nil
    end
    
    local success, petData = pcall(function()
        return PetsData[petName]
    end)
    
    if not success or not petData or not petData.Images then
        return nil
    end
    
    -- Determine image type based on shiny/mythic/xl status
    local imageType = "Normal"
    if shiny and mythic and xl then
        imageType = "MythicShinyXL"
    elseif shiny and mythic then
        imageType = "MythicShiny"
    elseif mythic and xl then
        imageType = "MythicXL"
    elseif shiny and xl then
        imageType = "ShinyXL"
    elseif shiny then
        imageType = "Shiny"
    elseif mythic then
        imageType = "Mythic"
    elseif xl then
        imageType = "XL"
    end
    
    -- Get the image asset ID with cascading fallbacks
    local petImageAsset = petData.Images[imageType]
    
    -- If exact combination not found, try simpler versions
    if not petImageAsset then
        if shiny and mythic then
            petImageAsset = petData.Images["MythicShiny"]
        elseif shiny then
            petImageAsset = petData.Images["Shiny"]
        elseif mythic then
            petImageAsset = petData.Images["Mythic"]
        end
    end
    
    -- Final fallback to Normal
    petImageAsset = petImageAsset or petData.Images["Normal"]
    
    if petImageAsset then
        -- Extract asset ID from rbxassetid:// format
        return petImageAsset:match("rbxassetid://(%d+)")
    end
    
    return nil
end

-- NEW: Unified function to send pet notifications with explicit notification type and ping control
-- OPTIMIZED: No longer blocks on thumbnail URL fetching - done lazily in queue processor
local function sendPetNotification(petName, shiny, mythic, xl, eggName, rarity, pet, notificationType, shouldPing)
    -- Don't process if script is closed
    if not scriptActive then
        return
    end
    
    if webhookURL == "" then
        print("‚úó Webhook URL not set")
        return
    end
    
    if not httpLib then
        print("‚úó HTTP library not available")
        return
    end
    
    -- Get pet image asset ID (non-blocking, no HTTP call)
    local petImageAssetId = getPetImageAssetId(petName, shiny, mythic, xl)
    
    -- Determine which notification to send based on notificationType
    if notificationType == "infinity" then
        -- Special infinity notification
        local isInfinity = isInfinityRarity(rarity)
        
        table.insert(webhookQueue, {
            petName = petName,
            shiny = shiny,
            mythic = mythic,
            xl = xl,
            eggName = eggName,
            rarity = rarity,
            pet = pet,
            petImageAssetId = petImageAssetId, -- Store asset ID, fetch URL later
            isSpecial = true,
            isInfinity = isInfinity,
            shouldPing = shouldPing
        })
        
        -- Add debug message
        local debugMessage = isInfinity and 
            "The rarity of this pet is specified as Infinity" or 
            ("The rarity is not infinity. Rarity: " .. (rarity or "Unknown"))
        table.insert(webhookQueue, {
            debugMessage = debugMessage,
            isDebug = true
        })
    elseif notificationType == "secret" then
        -- Regular secret notification
        table.insert(webhookQueue, {
            petName = petName,
            shiny = shiny,
            mythic = mythic,
            xl = xl,
            eggName = eggName,
            rarity = rarity,
            pet = pet,
            petImageAssetId = petImageAssetId, -- Store asset ID, fetch URL later
            isSpecial = false,
            notificationType = "secret",
            shouldPing = shouldPing
        })
    elseif notificationType == "xl" then
        -- XL notification (simple format)
        table.insert(webhookQueue, {
            petName = petName,
            shiny = shiny,
            mythic = mythic,
            xl = xl,
            petImageAssetId = petImageAssetId, -- Store asset ID, fetch URL later
            notificationType = "xl",
            shouldPing = shouldPing
        })
    elseif notificationType == "legendary" then
        -- Legendary notification (simple format)
        table.insert(webhookQueue, {
            petName = petName,
            shiny = shiny,
            mythic = mythic,
            xl = xl,
            petImageAssetId = petImageAssetId, -- Store asset ID, fetch URL later
            notificationType = "legendary",
            shouldPing = shouldPing
        })
    end
    
    -- Start processing queue if not already processing
    processWebhookQueue()
end

-- Helper function to calculate pet rarity number for sorting
local function getPetRarityValue(pet)
    if not PetUtil or not pet then
        return 0
    end
    
    local success, petChance = pcall(function()
        return PetUtil:GetChance(pet)
    end)
    
    if success and petChance and petChance > 0 then
        return math.ceil(100 / petChance)
    end
    
    return 0
end

-- Helper function to get variant hierarchy value
local function getVariantHierarchy(shiny, mythic, xl)
    if shiny and mythic and xl then return 8 end -- Shiny Mythic XL
    if mythic and xl then return 7 end -- Mythic XL
    if shiny and xl then return 6 end -- Shiny XL
    if xl then return 5 end -- XL
    if shiny and mythic then return 4 end -- Shiny Mythic
    if mythic then return 3 end -- Mythic
    if shiny then return 2 end -- Shiny
    return 1 -- Normal
end

-- Helper function to get variant name
local function getVariantName(shiny, mythic, xl)
    local name = ""
    if shiny and mythic then
        name = "Shiny Mythic "
    elseif shiny then
        name = "Shiny "
    elseif mythic then
        name = "Mythic "
    end
    if xl then
        name = name .. "XL "
    end
    return name
end

-- Admin Abuse Summary function
local function sendAdminAbuseSummary()
    if #adminAbuseHatchedPets == 0 then
        -- No pets hatched during admin abuse
        table.insert(webhookQueue, {
            message = "Admin Abuse mode ended. No secrets or infinities were hatched.",
            isPlainText = true,
            shouldPing = false
        })
        processWebhookQueue()
        return
    end
    
    -- Sort pets by hierarchy and rarity
    table.sort(adminAbuseHatchedPets, function(a, b)
        -- First sort by infinity (infinities first)
        if a.isInfinity and not b.isInfinity then return true end
        if not a.isInfinity and b.isInfinity then return false end
        
        -- Then sort by variant hierarchy
        local aHierarchy = getVariantHierarchy(a.shiny, a.mythic, a.xl)
        local bHierarchy = getVariantHierarchy(b.shiny, b.mythic, b.xl)
        if aHierarchy ~= bHierarchy then
            return aHierarchy > bHierarchy
        end
        
        -- Then sort by rarity (higher rarity first)
        local aRarity = getPetRarityValue(a.pet)
        local bRarity = getPetRarityValue(b.pet)
        return aRarity > bRarity
    end)
    
    -- Count pets by name and variant
    local petCounts = {}
    for _, petData in ipairs(adminAbuseHatchedPets) do
        local variantName = getVariantName(petData.shiny, petData.mythic, petData.xl)
        local fullName = variantName .. petData.name
        
        if not petCounts[fullName] then
            petCounts[fullName] = {
                count = 0,
                rarity = getPetRarityValue(petData.pet),
                hierarchy = getVariantHierarchy(petData.shiny, petData.mythic, petData.xl),
                isInfinity = petData.isInfinity,
                shiny = petData.shiny,
                mythic = petData.mythic,
                xl = petData.xl,
                name = petData.name
            }
        end
        petCounts[fullName].count = petCounts[fullName].count + 1
    end
    
    -- Build list of pets
    local petList = {}
    for fullName, data in pairs(petCounts) do
        table.insert(petList, {
            name = fullName,
            count = data.count,
            rarity = data.rarity,
            hierarchy = data.hierarchy,
            isInfinity = data.isInfinity,
            shiny = data.shiny,
            mythic = data.mythic,
            xl = data.xl,
            baseName = data.name
        })
    end
    
    -- Sort the list
    table.sort(petList, function(a, b)
        if a.isInfinity and not b.isInfinity then return true end
        if not a.isInfinity and b.isInfinity then return false end
        if a.hierarchy ~= b.hierarchy then return a.hierarchy > b.hierarchy end
        return a.rarity > b.rarity
    end)
    
    -- Build description
    local description = ""
    for _, data in ipairs(petList) do
        description = description .. data.count .. "x " .. data.name .. "\n"
    end
    
    -- Determine embed color (rarest pet's color)
    local rarestPet = petList[1]
    local embedColor = getEmbedColor(rarestPet.shiny, rarestPet.mythic, rarestPet.xl, rarestPet.isInfinity)
    
    -- Build embed
    local embed = {
        title = "üìä Admin Abuse Summary",
        description = description,
        color = embedColor,
        footer = {
            text = "Total: " .. #adminAbuseHatchedPets .. " secrets/infinities"
        },
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    local payload = {
        embeds = {embed}
    }
    
    -- Send to webhook queue
    table.insert(webhookQueue, {
        isCustomEmbed = true,
        payload = payload
    })
    processWebhookQueue()
    
    -- Clear the tracking table
    adminAbuseHatchedPets = {}
end

-- Connect to HatchEgg event
local function connectToEvents()
    if not Remote then
        print("‚úó Remote module not loaded!")
        return false
    end
    
    if not ItemUtil then
        print("‚úó ItemUtil not loaded!")
        return false
    end
    
    local success, err = pcall(function()
        hatchEventConnection = Remote.Event("HatchEgg"):Connect(function(hatchedTable)
            -- Wrap entire handler in pcall to prevent errors from breaking the connection
            pcall(function()
                -- Don't process if script is closed
                if not scriptActive then
                    return
                end
                
                if type(hatchedTable) == "table" and hatchedTable.Pets then
                    local eggName = hatchedTable.Name
                    
                    for i = 1, 20 do
                        local petData = hatchedTable.Pets[i]
                        if not petData then break end
                        
                        if type(petData) == "table" and petData.Pet then
                            local pet = petData.Pet
                            local petName = pet.Name
                            local shiny = pet.Shiny == true
                            local mythic = pet.Mythic == true
                            
                            -- XL detection with multiple fallback methods (optimized for most common case first)
                            local xl = (pet.XL == true) -- Check uppercase XL (most likely case)
                                or (pet.xl == true) -- Check lowercase xl
                                or (pet.Xl == true) -- Check mixed case Xl
                                or (type(pet.XL) == "number" and pet.XL > 0) -- Check if XL is a number value
                                or (petName and string.find(string.upper(petName), "XL", 1, true) ~= nil) -- Check if "XL" is in the pet name (optimized search)
                            
                            -- Only process if detection is enabled and pet data is available
                            if petName and ItemUtil then
                                local rarity = ItemUtil:GetRarity(pet)
                                
                                -- Check pet characteristics
                                local isSpecial = isSpecialPet(petName)
                                local isSecret = rarity == "Secret"
                                local isLegendary = rarity == "Legendary"
                                
                                -- Determine which settings to use (admin abuse or normal)
                                local activeSettings = {}
                                if adminAbuseActive then
                                    activeSettings.notifyNormal = adminAbuseSecretSettings.notifyNormal
                                    activeSettings.notifyShiny = adminAbuseSecretSettings.notifyShiny
                                    activeSettings.notifyMythic = adminAbuseSecretSettings.notifyMythic
                                    activeSettings.notifyShinyMythic = adminAbuseSecretSettings.notifyShinyMythic
                                    activeSettings.notifyXL = adminAbuseSecretSettings.notifyXL
                                    activeSettings.pingNormal = adminAbuseSecretSettings.pingNormal
                                    activeSettings.pingShiny = adminAbuseSecretSettings.pingShiny
                                    activeSettings.pingMythic = adminAbuseSecretSettings.pingMythic
                                    activeSettings.pingShinyMythic = adminAbuseSecretSettings.pingShinyMythic
                                    activeSettings.pingXL = adminAbuseSecretSettings.pingXL
                                    activeSettings.filterUnder1B = adminAbuseSecretSettings.filterUnder1B
                                    activeSettings.infinityNotify = adminAbuseSecretSettings.notifyInfinity or true
                                    activeSettings.infinityPing = adminAbuseSecretSettings.pingInfinity or true
                                else
                                    activeSettings.notifyNormal = secretNotifyNormal
                                    activeSettings.notifyShiny = secretNotifyShiny
                                    activeSettings.notifyMythic = secretNotifyMythic
                                    activeSettings.notifyShinyMythic = secretNotifyShinyMythic
                                    activeSettings.notifyXL = secretNotifyXL
                                    activeSettings.pingNormal = secretPingNormal
                                    activeSettings.pingShiny = secretPingShiny
                                    activeSettings.pingMythic = secretPingMythic
                                    activeSettings.pingShinyMythic = secretPingShinyMythic
                                    activeSettings.pingXL = secretPingXL
                                    activeSettings.filterUnder1B = secretFilterUnder1B
                                    activeSettings.infinityNotify = infinityNotifyEnabled
                                    activeSettings.infinityPing = infinityPingEnabled
                                end
                                
                                -- ===== DETECTION LOGIC =====
                                
                                -- Priority 1: Infinity pets
                                if isSpecial then
                                    if activeSettings.infinityNotify then
                                        local shouldPing = activeSettings.infinityPing
                                        
                                        -- Track for admin abuse summary
                                        if adminAbuseActive then
                                            table.insert(adminAbuseHatchedPets, {
                                                name = petName,
                                                shiny = shiny,
                                                mythic = mythic,
                                                xl = xl,
                                                rarity = rarity,
                                                isInfinity = true,
                                                pet = pet
                                            })
                                        end
                                        
                                        sendPetNotification(petName, shiny, mythic, xl, eggName, rarity, pet, "infinity", shouldPing)
                                        print(">>> INFINITY PET DETECTED! <<<")
                                    end
                                
                                -- Priority 2: Secret pets (cascading variant logic)
                                elseif isSecret then
                                    local shouldNotify = false
                                    local shouldPing = false
                                    
                                    -- Cascading detection logic
                                    -- Check exact match first, then cascade
                                    if shiny and mythic and xl then
                                        -- Shiny Mythic XL: can be triggered by any of: Shiny, Mythic, Shiny Mythic, XL
                                        shouldNotify = activeSettings.notifyShiny or activeSettings.notifyMythic or activeSettings.notifyShinyMythic or activeSettings.notifyXL
                                        if activeSettings.pingShiny or activeSettings.pingMythic or activeSettings.pingShinyMythic or activeSettings.pingXL then
                                            shouldPing = true
                                        end
                                    elseif mythic and xl then
                                        -- Mythic XL: can be triggered by Mythic or XL
                                        shouldNotify = activeSettings.notifyMythic or activeSettings.notifyXL
                                        if activeSettings.pingMythic or activeSettings.pingXL then
                                            shouldPing = true
                                        end
                                    elseif shiny and xl then
                                        -- Shiny XL: can be triggered by Shiny or XL
                                        shouldNotify = activeSettings.notifyShiny or activeSettings.notifyXL
                                        if activeSettings.pingShiny or activeSettings.pingXL then
                                            shouldPing = true
                                        end
                                    elseif shiny and mythic then
                                        -- Shiny Mythic: can be triggered by Shiny, Mythic, or Shiny Mythic
                                        shouldNotify = activeSettings.notifyShiny or activeSettings.notifyMythic or activeSettings.notifyShinyMythic
                                        if activeSettings.pingShiny or activeSettings.pingMythic or activeSettings.pingShinyMythic then
                                            shouldPing = true
                                        end
                                    elseif xl then
                                        -- XL: triggered by XL
                                        shouldNotify = activeSettings.notifyXL
                                        shouldPing = activeSettings.pingXL
                                    elseif mythic then
                                        -- Mythic: triggered by Mythic
                                        shouldNotify = activeSettings.notifyMythic
                                        shouldPing = activeSettings.pingMythic
                                    elseif shiny then
                                        -- Shiny: triggered by Shiny
                                        shouldNotify = activeSettings.notifyShiny
                                        shouldPing = activeSettings.pingShiny
                                    else
                                        -- Normal: triggered by Normal
                                        shouldNotify = activeSettings.notifyNormal
                                        shouldPing = activeSettings.pingNormal
                                    end
                                    
                                    -- Apply <1B filter
                                    if shouldNotify and activeSettings.filterUnder1B then
                                        -- Check if pet is under 1B
                                        if PetUtil and pet then
                                            local success, petChance = pcall(function()
                                                return PetUtil:GetChance(pet)
                                            end)
                                            if success and petChance and petChance > 0 then
                                                local denominator = math.ceil(100 / petChance)
                                                -- If under 1B, check if any variant is enabled that overrides the filter
                                                if denominator < 1000000000 then
                                                    local hasEnabledVariant = false
                                                    
                                                    -- Check if pet has any variant that is enabled for notifications
                                                    if xl and activeSettings.notifyXL then
                                                        hasEnabledVariant = true
                                                    elseif shiny and mythic and activeSettings.notifyShinyMythic then
                                                        hasEnabledVariant = true
                                                    elseif mythic and activeSettings.notifyMythic then
                                                        hasEnabledVariant = true
                                                    elseif shiny and activeSettings.notifyShiny then
                                                        hasEnabledVariant = true
                                                    end
                                                    
                                                    -- If no enabled variant, skip notification
                                                    if not hasEnabledVariant then
                                                        shouldNotify = false
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    
                                    -- Track for admin abuse summary (always track, even if not notifying)
                                    if adminAbuseActive then
                                        table.insert(adminAbuseHatchedPets, {
                                            name = petName,
                                            shiny = shiny,
                                            mythic = mythic,
                                            xl = xl,
                                            rarity = rarity,
                                            isInfinity = false,
                                            pet = pet
                                        })
                                    end
                                    
                                    if shouldNotify then
                                        sendPetNotification(petName, shiny, mythic, xl, eggName, rarity, pet, "secret", shouldPing)
                                        print(">>> SECRET DETECTED! <<<")
                                    end
                                
                                -- Priority 3: XL pets (non-secret)
                                elseif xl and xlDetectionEnabled then
                                    local shouldPing = xlPingEnabled
                                    sendPetNotification(petName, shiny, mythic, xl, eggName, rarity, pet, "xl", shouldPing)
                                    print(">>> XL PET DETECTED! <<<")
                                
                                -- Priority 4: Legendary pets (non-XL, non-secret)
                                elseif isLegendary and legendaryDetectionEnabled then
                                    local shouldPing = legendaryPingEnabled
                                    sendPetNotification(petName, shiny, mythic, xl, eggName, rarity, pet, "legendary", shouldPing)
                                    print(">>> LEGENDARY DETECTED! <<<")
                                end
                            end
                        end
                    end
                end
            end)
        end)
    end)
    
    if success then
        print("‚úì Connected to HatchEgg events")
        return true
    else
        print("‚úó Failed to connect: " .. tostring(err))
        return false
    end
end

-- Chat monitoring for "Feeling jolly" (Christmas Chest Rifts)
local function setupChatMonitoring()
    -- Try TextChatService (new chat system)
    local success1 = pcall(function()
        if TextChatService and TextChatService.MessageReceived then
            TextChatService.MessageReceived:Connect(function(message)
                if not scriptActive or not riftDetectionEnabled then return end
                
                local text = message.Text or ""
                if string.find(string.lower(text), "feeling jolly") then
                    print(">>> CHRISTMAS CHEST RIFT DETECTED! <<<")
                    table.insert(webhookQueue, {
                        message = "A Christmas Chest Rift has spawned!",
                        isPlainText = true,
                        shouldPing = true
                    })
                    processWebhookQueue()
                end
            end)
            print("‚úì Chat monitoring active (TextChatService)")
        end
    end)
    
    -- Try legacy chat system
    local success2 = pcall(function()
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        if player and player:WaitForChild("PlayerGui"):FindFirstChild("Chat") then
            local chat = player.PlayerGui.Chat
            
            -- Helper function to monitor chat element
            local function monitorChatElement(child)
                if child:IsA("TextLabel") or child:IsA("TextBox") then
                    child:GetPropertyChangedSignal("Text"):Connect(function()
                        if not scriptActive or not riftDetectionEnabled then return end
                        
                        local text = child.Text or ""
                        if string.find(string.lower(text), "feeling jolly") then
                            print(">>> CHRISTMAS CHEST RIFT DETECTED! <<<")
                            table.insert(webhookQueue, {
                                message = "A Christmas Chest Rift has spawned!",
                                isPlainText = true,
                                shouldPing = true
                            })
                            processWebhookQueue()
                        end
                    end)
                end
            end
            
            -- Monitor existing chat elements
            for _, child in pairs(chat:GetDescendants()) do
                monitorChatElement(child)
            end
            
            -- Monitor new chat elements as they're added
            chat.DescendantAdded:Connect(function(child)
                monitorChatElement(child)
            end)
            
            print("‚úì Chat monitoring active (Legacy Chat)")
        end
    end)
    
    if not success1 and not success2 then
        print("‚ö† Chat monitoring not available")
    end
end

-- Egg count monitoring system (checks every 10 minutes at :X0)
local lastEggCount = nil
local lastHourlyNotification = 0
local hasStoppedHatching = false -- Track if we've already sent "stopped hatching" message
local function startEggCountMonitoring()
    spawn(function()
        while scriptActive do
            if webhookURL ~= "" then
                -- Calculate time until next :X0 minute
                local currentTime = os.date("*t")
                local minutesUntilNextCheck = 10 - (currentTime.min % 10)
                if minutesUntilNextCheck == 10 then
                    minutesUntilNextCheck = 0
                end
                local secondsUntilNextCheck = (minutesUntilNextCheck * 60) - currentTime.sec
                
                -- Wait until next check time
                if secondsUntilNextCheck > 0 then
                    task.wait(secondsUntilNextCheck)
                end
                
                -- Get current egg count
                local currentEggCount = getTotalEggsHatched()
                
                if currentEggCount == nil then
                    -- Failed to get egg count - treat as not hatching
                    if lastEggCount ~= nil and not hasStoppedHatching then
                        table.insert(webhookQueue, {
                            message = string.format("%s is no longer hatching.", p.Name),
                            isPlainText = true,
                            shouldPing = false
                        })
                        processWebhookQueue()
                        hasStoppedHatching = true
                    end
                    lastEggCount = nil
                elseif lastEggCount == nil then
                    -- First check - just record the count
                    lastEggCount = currentEggCount
                    lastHourlyNotification = os.time()
                    hasStoppedHatching = false
                elseif currentEggCount > lastEggCount then
                    -- Eggs increased - player is still hatching
                    lastEggCount = currentEggCount
                    hasStoppedHatching = false -- Reset flag since they're hatching again
                    
                    -- Check if it's been at least 1 hour since last "still hatching" message
                    local timeSinceLastNotif = os.time() - lastHourlyNotification
                    if timeSinceLastNotif >= 3600 then
                        -- Format egg count
                        local formattedCount = currentEggCount
                        if FormatCommas then
                            formattedCount = FormatCommas(currentEggCount)
                        else
                            formattedCount = tostring(currentEggCount):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")
                        end
                        
                        table.insert(webhookQueue, {
                            message = string.format("%s is still hatching. Eggs Hatched: %s", p.Name, formattedCount),
                            isPlainText = true,
                            shouldPing = false
                        })
                        processWebhookQueue()
                        lastHourlyNotification = os.time()
                    end
                else
                    -- Eggs did not increase - player is no longer hatching
                    if not hasStoppedHatching then
                        table.insert(webhookQueue, {
                            message = string.format("%s is no longer hatching.", p.Name),
                            isPlainText = true,
                            shouldPing = false
                        })
                        processWebhookQueue()
                        hasStoppedHatching = true
                    end
                    lastEggCount = currentEggCount -- Update count
                end
            else
                task.wait(60) -- Check every minute if webhook not configured
            end
        end
    end)
end

-- Player join/leave tracking
local function setupPlayerTracking()
    P.PlayerAdded:Connect(function(player)
        if not scriptActive or not playerTrackingEnabled or webhookURL == "" then return end
        
        table.insert(webhookQueue, {
            message = string.format("%s joined the server", player.Name),
            isPlainText = true,
            shouldPing = false
        })
        processWebhookQueue()
    end)
    
    P.PlayerRemoving:Connect(function(player)
        if not scriptActive or not playerTrackingEnabled or webhookURL == "" then return end
        
        table.insert(webhookQueue, {
            message = string.format("%s left the server", player.Name),
            isPlainText = true,
            shouldPing = false
        })
        processWebhookQueue()
    end)
    
    print("‚úì Player tracking setup complete")
end

-- Connect after modules load
task.wait(1)
connectToEvents()
setupChatMonitoring()
setupPlayerTracking()
startEggCountMonitoring()

-- GUI with tab system
local g = Instance.new("ScreenGui")
g.Name = "BubblegumAutoHatch"
g.ResetOnSpawn = false
g.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
g.Parent = p.PlayerGui

-- Main frame (slightly wider for tab system)
local f = Instance.new("Frame")
f.Size = UDim2.new(0, 450, 0, 240)
f.Position = UDim2.new(0.5, -225, 0.5, -120)
f.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
f.BorderSizePixel = 0
f.Parent = g

-- Tab container (left side)
local tabContainer = Instance.new("Frame")
tabContainer.Size = UDim2.new(0, 90, 1, 0)
tabContainer.Position = UDim2.new(0, 0, 0, 0)
tabContainer.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
tabContainer.BorderSizePixel = 0
tabContainer.Parent = f

-- Content container (right side)
local contentContainer = Instance.new("Frame")
contentContainer.Size = UDim2.new(0, 360, 1, 0)
contentContainer.Position = UDim2.new(0, 90, 0, 0)
contentContainer.BackgroundTransparency = 1
contentContainer.BorderSizePixel = 0
contentContainer.Parent = f

-- Hatching tab button
local hatchingTab = Instance.new("TextButton")
hatchingTab.Size = UDim2.new(1, 0, 0, 50)
hatchingTab.Position = UDim2.new(0, 0, 0, 0)
hatchingTab.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
hatchingTab.Text = "Hatching"
hatchingTab.TextColor3 = Color3.fromRGB(255, 255, 255)
hatchingTab.TextSize = 14
hatchingTab.Font = Enum.Font.GothamBold
hatchingTab.BorderSizePixel = 0
hatchingTab.Parent = tabContainer

-- Pet Detection tab button (new)
local detectionTab = Instance.new("TextButton")
detectionTab.Size = UDim2.new(1, 0, 0, 50)
detectionTab.Position = UDim2.new(0, 0, 0, 50)
detectionTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
detectionTab.Text = "Pet Detection"
detectionTab.TextColor3 = Color3.fromRGB(255, 255, 255)
detectionTab.TextSize = 12
detectionTab.Font = Enum.Font.GothamBold
detectionTab.BorderSizePixel = 0
detectionTab.Parent = tabContainer

-- Admin Abuse tab button (new)
local adminAbuseTab = Instance.new("TextButton")
adminAbuseTab.Size = UDim2.new(1, 0, 0, 50)
adminAbuseTab.Position = UDim2.new(0, 0, 0, 100)
adminAbuseTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
adminAbuseTab.Text = "Admin Abuse"
adminAbuseTab.TextColor3 = Color3.fromRGB(255, 255, 255)
adminAbuseTab.TextSize = 12
adminAbuseTab.Font = Enum.Font.GothamBold
adminAbuseTab.BorderSizePixel = 0
adminAbuseTab.Parent = tabContainer

-- Extra tab button
local extraTab = Instance.new("TextButton")
extraTab.Size = UDim2.new(1, 0, 0, 50)
extraTab.Position = UDim2.new(0, 0, 0, 150)
extraTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
extraTab.Text = "Extra"
extraTab.TextColor3 = Color3.fromRGB(255, 255, 255)
extraTab.TextSize = 14
extraTab.Font = Enum.Font.GothamBold
extraTab.BorderSizePixel = 0
extraTab.Parent = tabContainer

-- Hatching content frame
local hatchingContent = Instance.new("Frame")
hatchingContent.Size = UDim2.new(1, 0, 1, 0)
hatchingContent.BackgroundTransparency = 1
hatchingContent.Visible = true
hatchingContent.Parent = contentContainer

-- Pet Detection content frame (new)
local detectionContent = Instance.new("Frame")
detectionContent.Size = UDim2.new(1, 0, 1, 0)
detectionContent.BackgroundTransparency = 1
detectionContent.Visible = false
detectionContent.Parent = contentContainer

-- Admin Abuse content frame
local adminAbuseContent = Instance.new("Frame")
adminAbuseContent.Size = UDim2.new(1, 0, 1, 0)
adminAbuseContent.BackgroundTransparency = 1
adminAbuseContent.Visible = false
adminAbuseContent.Parent = contentContainer

-- Extra content frame
local extraContent = Instance.new("Frame")
extraContent.Size = UDim2.new(1, 0, 1, 0)
extraContent.BackgroundTransparency = 1
extraContent.Visible = false
extraContent.Parent = contentContainer

-- Secret Detection Settings sub-menu frame (overlay)
local secretSettingsMenu = Instance.new("Frame")
secretSettingsMenu.Size = UDim2.new(1, 0, 1, 0)
secretSettingsMenu.BackgroundTransparency = 1
secretSettingsMenu.Visible = false
secretSettingsMenu.ZIndex = 5
secretSettingsMenu.Parent = contentContainer

-- Admin Abuse Secret Settings sub-menu frame (overlay)
local adminSecretSettingsMenu = Instance.new("Frame")
adminSecretSettingsMenu.Size = UDim2.new(1, 0, 1, 0)
adminSecretSettingsMenu.BackgroundTransparency = 1
adminSecretSettingsMenu.Visible = false
adminSecretSettingsMenu.ZIndex = 5
adminSecretSettingsMenu.Parent = contentContainer

-- ==================== PET DETECTION TAB CONTENT ====================

-- Detection title
local detectionTitle = Instance.new("TextLabel")
detectionTitle.Size = UDim2.new(1, 0, 0, 40)
detectionTitle.Position = UDim2.new(0, 0, 0, 0)
detectionTitle.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
detectionTitle.Text = "Pet Detection Settings"
detectionTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
detectionTitle.TextSize = 16
detectionTitle.Font = Enum.Font.GothamBold
detectionTitle.BorderSizePixel = 0
detectionTitle.Parent = detectionContent

-- Row 1: Secret Detection Settings button (full width)
local secretSettingsBtn = Instance.new("TextButton")
secretSettingsBtn.Size = UDim2.new(0, 330, 0, 45)
secretSettingsBtn.Position = UDim2.new(0, 15, 0, 50)
secretSettingsBtn.BackgroundColor3 = Color3.fromRGB(100, 150, 255)
secretSettingsBtn.Text = "‚öô Secret Detection Settings"
secretSettingsBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
secretSettingsBtn.TextSize = 13
secretSettingsBtn.Font = Enum.Font.GothamBold
secretSettingsBtn.BorderSizePixel = 0
secretSettingsBtn.Parent = detectionContent

local secretSettingsDesc = Instance.new("TextLabel")
secretSettingsDesc.Size = UDim2.new(0, 330, 0, 22)
secretSettingsDesc.Position = UDim2.new(0, 15, 0, 100)
secretSettingsDesc.BackgroundTransparency = 1
secretSettingsDesc.Text = "Configure granular secret detection and ping settings"
secretSettingsDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
secretSettingsDesc.TextSize = 9
secretSettingsDesc.Font = Enum.Font.Gotham
secretSettingsDesc.TextXAlignment = Enum.TextXAlignment.Center
secretSettingsDesc.TextYAlignment = Enum.TextYAlignment.Top
secretSettingsDesc.TextWrapped = true
secretSettingsDesc.Parent = detectionContent

-- Row 2: XL Detection (left) and XL Ping (right)
-- XL Detection button (middle-left)
local xlBtn = Instance.new("TextButton")
xlBtn.Size = UDim2.new(0, 155, 0, 28)
xlBtn.Position = UDim2.new(0, 15, 0, 130)
xlBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60) -- Default OFF
xlBtn.Text = "Detect XL Pets: OFF"
xlBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
xlBtn.TextSize = 11
xlBtn.Font = Enum.Font.GothamBold
xlBtn.BorderSizePixel = 0
xlBtn.Parent = detectionContent

local xlDesc = Instance.new("TextLabel")
xlDesc.Size = UDim2.new(0, 155, 0, 22)
xlDesc.Position = UDim2.new(0, 15, 0, 162)
xlDesc.BackgroundTransparency = 1
xlDesc.Text = "Toggle XL pet notifications (non-secrets)"
xlDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
xlDesc.TextSize = 8
xlDesc.Font = Enum.Font.Gotham
xlDesc.TextXAlignment = Enum.TextXAlignment.Left
xlDesc.TextYAlignment = Enum.TextYAlignment.Top
xlDesc.TextWrapped = true
xlDesc.Parent = detectionContent

-- XL Ping button (middle-right)
local xlPingBtn = Instance.new("TextButton")
xlPingBtn.Size = UDim2.new(0, 155, 0, 28)
xlPingBtn.Position = UDim2.new(0, 180, 0, 130)
xlPingBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60) -- Default OFF
xlPingBtn.Text = "XL Pings: OFF"
xlPingBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
xlPingBtn.TextSize = 11
xlPingBtn.Font = Enum.Font.GothamBold
xlPingBtn.BorderSizePixel = 0
xlPingBtn.Parent = detectionContent

local xlPingDesc = Instance.new("TextLabel")
xlPingDesc.Size = UDim2.new(0, 155, 0, 22)
xlPingDesc.Position = UDim2.new(0, 180, 0, 162)
xlPingDesc.BackgroundTransparency = 1
xlPingDesc.Text = "Ping when XL pets hatch"
xlPingDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
xlPingDesc.TextSize = 8
xlPingDesc.Font = Enum.Font.Gotham
xlPingDesc.TextXAlignment = Enum.TextXAlignment.Left
xlPingDesc.TextYAlignment = Enum.TextYAlignment.Top
xlPingDesc.TextWrapped = true
xlPingDesc.Parent = detectionContent

-- Row 3: Legendary Detection (left) and Legendary Ping (right)
-- Legendary Detection button (bottom-left)
local legendaryBtn = Instance.new("TextButton")
legendaryBtn.Size = UDim2.new(0, 155, 0, 28)
legendaryBtn.Position = UDim2.new(0, 15, 0, 190)
legendaryBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60) -- Default OFF
legendaryBtn.Text = "Legendary Detection: OFF"
legendaryBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
legendaryBtn.TextSize = 10
legendaryBtn.Font = Enum.Font.GothamBold
legendaryBtn.BorderSizePixel = 0
legendaryBtn.Parent = detectionContent

local legendaryDesc = Instance.new("TextLabel")
legendaryDesc.Size = UDim2.new(0, 155, 0, 22)
legendaryDesc.Position = UDim2.new(0, 15, 0, 222)
legendaryDesc.BackgroundTransparency = 1
legendaryDesc.Text = "Toggle legendary detection (testing)"
legendaryDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
legendaryDesc.TextSize = 8
legendaryDesc.Font = Enum.Font.Gotham
legendaryDesc.TextXAlignment = Enum.TextXAlignment.Left
legendaryDesc.TextYAlignment = Enum.TextYAlignment.Top
legendaryDesc.TextWrapped = true
legendaryDesc.Parent = detectionContent

-- Legendary Ping button (bottom-right)
local legendaryPingBtn = Instance.new("TextButton")
legendaryPingBtn.Size = UDim2.new(0, 155, 0, 28)
legendaryPingBtn.Position = UDim2.new(0, 180, 0, 190)
legendaryPingBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60) -- Default OFF
legendaryPingBtn.Text = "Legendary Pings: OFF"
legendaryPingBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
legendaryPingBtn.TextSize = 10
legendaryPingBtn.Font = Enum.Font.GothamBold
legendaryPingBtn.BorderSizePixel = 0
legendaryPingBtn.Parent = detectionContent

local legendaryPingDesc = Instance.new("TextLabel")
legendaryPingDesc.Size = UDim2.new(0, 155, 0, 22)
legendaryPingDesc.Position = UDim2.new(0, 180, 0, 222)
legendaryPingDesc.BackgroundTransparency = 1
legendaryPingDesc.Text = "Ping when legendary pets hatch"
legendaryPingDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
legendaryPingDesc.TextSize = 8
legendaryPingDesc.Font = Enum.Font.Gotham
legendaryPingDesc.TextXAlignment = Enum.TextXAlignment.Left
legendaryPingDesc.TextYAlignment = Enum.TextYAlignment.Top
legendaryPingDesc.TextWrapped = true
legendaryPingDesc.Parent = detectionContent

-- ==================== ADMIN ABUSE TAB CONTENT ====================

-- Admin Abuse title
local adminAbuseTitle = Instance.new("TextLabel")
adminAbuseTitle.Size = UDim2.new(1, 0, 0, 40)
adminAbuseTitle.Position = UDim2.new(0, 0, 0, 0)
adminAbuseTitle.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
adminAbuseTitle.Text = "Admin Abuse Mode"
adminAbuseTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
adminAbuseTitle.TextSize = 16
adminAbuseTitle.Font = Enum.Font.GothamBold
adminAbuseTitle.BorderSizePixel = 0
adminAbuseTitle.Parent = adminAbuseContent

-- Admin Abuse toggle button
local adminAbuseToggleBtn = Instance.new("TextButton")
adminAbuseToggleBtn.Size = UDim2.new(0, 330, 0, 50)
adminAbuseToggleBtn.Position = UDim2.new(0, 15, 0, 55)
adminAbuseToggleBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
adminAbuseToggleBtn.Text = "Admin Abuse Mode: OFF"
adminAbuseToggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
adminAbuseToggleBtn.TextSize = 14
adminAbuseToggleBtn.Font = Enum.Font.GothamBold
adminAbuseToggleBtn.BorderSizePixel = 0
adminAbuseToggleBtn.Parent = adminAbuseContent

local adminAbuseToggleDesc = Instance.new("TextLabel")
adminAbuseToggleDesc.Size = UDim2.new(0, 330, 0, 30)
adminAbuseToggleDesc.Position = UDim2.new(0, 15, 0, 110)
adminAbuseToggleDesc.BackgroundTransparency = 1
adminAbuseToggleDesc.Text = "Use separate detection settings for admin abuse events.\nTracks all secrets/infinities for summary report."
adminAbuseToggleDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
adminAbuseToggleDesc.TextSize = 9
adminAbuseToggleDesc.Font = Enum.Font.Gotham
adminAbuseToggleDesc.TextXAlignment = Enum.TextXAlignment.Center
adminAbuseToggleDesc.TextYAlignment = Enum.TextYAlignment.Top
adminAbuseToggleDesc.TextWrapped = true
adminAbuseToggleDesc.Parent = adminAbuseContent

-- Admin Abuse settings button
local adminAbuseSettingsBtn = Instance.new("TextButton")
adminAbuseSettingsBtn.Size = UDim2.new(0, 330, 0, 45)
adminAbuseSettingsBtn.Position = UDim2.new(0, 15, 0, 150)
adminAbuseSettingsBtn.BackgroundColor3 = Color3.fromRGB(100, 150, 255)
adminAbuseSettingsBtn.Text = "‚öô Configure Admin Abuse Settings"
adminAbuseSettingsBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
adminAbuseSettingsBtn.TextSize = 13
adminAbuseSettingsBtn.Font = Enum.Font.GothamBold
adminAbuseSettingsBtn.BorderSizePixel = 0
adminAbuseSettingsBtn.Parent = adminAbuseContent

local adminAbuseSettingsDesc = Instance.new("TextLabel")
adminAbuseSettingsDesc.Size = UDim2.new(0, 330, 0, 22)
adminAbuseSettingsDesc.Position = UDim2.new(0, 15, 0, 200)
adminAbuseSettingsDesc.BackgroundTransparency = 1
adminAbuseSettingsDesc.Text = "Configure which secrets to notify/ping during admin abuse"
adminAbuseSettingsDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
adminAbuseSettingsDesc.TextSize = 9
adminAbuseSettingsDesc.Font = Enum.Font.Gotham
adminAbuseSettingsDesc.TextXAlignment = Enum.TextXAlignment.Center
adminAbuseSettingsDesc.TextYAlignment = Enum.TextYAlignment.Top
adminAbuseSettingsDesc.TextWrapped = true
adminAbuseSettingsDesc.Parent = adminAbuseContent

-- ==================== HATCHING TAB CONTENT ====================

-- Title bar (in hatching content)
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 40)
title.Position = UDim2.new(0, 0, 0, 0)
title.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
title.Text = "Auto Hatch & Notifier"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextSize = 16
title.Font = Enum.Font.GothamBold
title.BorderSizePixel = 0
title.Parent = hatchingContent

-- Auto Hatch button
local autoHatchBtn = Instance.new("TextButton")
autoHatchBtn.Size = UDim2.new(0, 330, 0, 45)
autoHatchBtn.Position = UDim2.new(0, 15, 0, 55)
autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
autoHatchBtn.Text = "Auto Hatch: OFF"
autoHatchBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
autoHatchBtn.TextSize = 14
autoHatchBtn.Font = Enum.Font.GothamBold
autoHatchBtn.BorderSizePixel = 0
autoHatchBtn.Parent = hatchingContent

-- Webhook URL label
local webhookLabel = Instance.new("TextLabel")
webhookLabel.Size = UDim2.new(0, 330, 0, 20)
webhookLabel.Position = UDim2.new(0, 15, 0, 110)
webhookLabel.BackgroundTransparency = 1
webhookLabel.Text = "Discord Webhook URL:"
webhookLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
webhookLabel.TextSize = 11
webhookLabel.Font = Enum.Font.Gotham
webhookLabel.TextXAlignment = Enum.TextXAlignment.Left
webhookLabel.Parent = hatchingContent

-- Webhook URL input
local webhookInput = Instance.new("TextBox")
webhookInput.Size = UDim2.new(0, 330, 0, 30)
webhookInput.Position = UDim2.new(0, 15, 0, 130)
webhookInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
webhookInput.TextColor3 = Color3.fromRGB(255, 255, 255)
webhookInput.Text = webhookURL or ""
webhookInput.PlaceholderText = "https://discord.com/api/webhooks/..."
webhookInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
webhookInput.TextSize = 10
webhookInput.Font = Enum.Font.Gotham
webhookInput.BorderSizePixel = 0
webhookInput.TextTruncate = Enum.TextTruncate.AtEnd
webhookInput.Parent = hatchingContent

-- Discord User ID label
local userIDLabel = Instance.new("TextLabel")
userIDLabel.Size = UDim2.new(0, 330, 0, 20)
userIDLabel.Position = UDim2.new(0, 15, 0, 170)
userIDLabel.BackgroundTransparency = 1
userIDLabel.Text = "Discord User ID (optional):"
userIDLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
userIDLabel.TextSize = 11
userIDLabel.Font = Enum.Font.Gotham
userIDLabel.TextXAlignment = Enum.TextXAlignment.Left
userIDLabel.Parent = hatchingContent

-- Discord User ID input
local userIDInput = Instance.new("TextBox")
userIDInput.Size = UDim2.new(0, 330, 0, 30)
userIDInput.Position = UDim2.new(0, 15, 0, 190)
userIDInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
userIDInput.TextColor3 = Color3.fromRGB(255, 255, 255)
userIDInput.Text = discordUserID or ""
userIDInput.PlaceholderText = "123456789012345678"
userIDInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
userIDInput.TextSize = 11
userIDInput.Font = Enum.Font.Gotham
userIDInput.BorderSizePixel = 0
userIDInput.Parent = hatchingContent

-- X button on main GUI (top right of frame) - hides GUI
local hideXBtn = Instance.new("TextButton")
hideXBtn.Size = UDim2.new(0, 30, 0, 30)
hideXBtn.Position = UDim2.new(1, -35, 0, 5)
hideXBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
hideXBtn.Text = "X"
hideXBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
hideXBtn.TextSize = 18
hideXBtn.Font = Enum.Font.GothamBold
hideXBtn.BorderSizePixel = 0
hideXBtn.ZIndex = 2
hideXBtn.Parent = f

-- Toggle button (top right of screen - always visible)
local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0, 50, 0, 50)
toggleBtn.Position = UDim2.new(1, -60, 0, 10)
toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
toggleBtn.Text = "GUI"
toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleBtn.TextSize = 12
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.BorderSizePixel = 0
toggleBtn.Parent = g

-- Extra content title bar
local extraTitle = Instance.new("TextLabel")
extraTitle.Size = UDim2.new(1, 0, 0, 40)
extraTitle.Position = UDim2.new(0, 0, 0, 0)
extraTitle.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
extraTitle.Text = "Extra Features"
extraTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
extraTitle.TextSize = 16
extraTitle.Font = Enum.Font.GothamBold
extraTitle.BorderSizePixel = 0
extraTitle.Parent = extraContent

-- 2x2 Button grid in Extra tab
-- Row 1: Rift Detection (left) and Hourly Status (right)
-- Row 2: Player Tracking (left) and Close Script (right)

-- Row 1: Rift Detection (left) and Hourly Status (right)
-- Rift detection button (top-left)
local riftBtn = Instance.new("TextButton")
riftBtn.Size = UDim2.new(0, 155, 0, 28)
riftBtn.Position = UDim2.new(0, 15, 0, 50)
riftBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
riftBtn.Text = "Rift Detection: OFF"
riftBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
riftBtn.TextSize = 11
riftBtn.Font = Enum.Font.GothamBold
riftBtn.BorderSizePixel = 0
riftBtn.Parent = extraContent

local riftDesc = Instance.new("TextLabel")
riftDesc.Size = UDim2.new(0, 155, 0, 22)
riftDesc.Position = UDim2.new(0, 15, 0, 82)
riftDesc.BackgroundTransparency = 1
riftDesc.Text = "Detects Christmas Chest Rifts and pings you"
riftDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
riftDesc.TextSize = 8
riftDesc.Font = Enum.Font.Gotham
riftDesc.TextXAlignment = Enum.TextXAlignment.Left
riftDesc.TextYAlignment = Enum.TextYAlignment.Top
riftDesc.TextWrapped = true
riftDesc.Parent = extraContent


-- Row 2: Player Tracking (left) and Close Script (right)
-- Player tracking button (bottom-left)
local playerBtn = Instance.new("TextButton")
playerBtn.Size = UDim2.new(0, 155, 0, 28)
playerBtn.Position = UDim2.new(0, 15, 0, 110)
playerBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
playerBtn.Text = "Player Track: ON"
playerBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
playerBtn.TextSize = 11
playerBtn.Font = Enum.Font.GothamBold
playerBtn.BorderSizePixel = 0
playerBtn.Parent = extraContent

local playerDesc = Instance.new("TextLabel")
playerDesc.Size = UDim2.new(0, 155, 0, 22)
playerDesc.Position = UDim2.new(0, 15, 0, 142)
playerDesc.BackgroundTransparency = 1
playerDesc.Text = "Notifies when players join or leave (no ping)"
playerDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
playerDesc.TextSize = 8
playerDesc.Font = Enum.Font.Gotham
playerDesc.TextXAlignment = Enum.TextXAlignment.Left
playerDesc.TextYAlignment = Enum.TextYAlignment.Top
playerDesc.TextWrapped = true
playerDesc.Parent = extraContent

-- Close Script button (bottom-right)
local closeScriptBtn = Instance.new("TextButton")
closeScriptBtn.Size = UDim2.new(0, 155, 0, 28)
closeScriptBtn.Position = UDim2.new(0, 180, 0, 110)
closeScriptBtn.BackgroundColor3 = Color3.fromRGB(80, 40, 40)
closeScriptBtn.Text = "Close Script"
closeScriptBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeScriptBtn.TextSize = 11
closeScriptBtn.Font = Enum.Font.GothamBold
closeScriptBtn.BorderSizePixel = 0
closeScriptBtn.Parent = extraContent

local closeScriptDesc = Instance.new("TextLabel")
closeScriptDesc.Size = UDim2.new(0, 155, 0, 22)
closeScriptDesc.Position = UDim2.new(0, 180, 0, 142)
closeScriptDesc.BackgroundTransparency = 1
closeScriptDesc.Text = "Stop all script functionality"
closeScriptDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
closeScriptDesc.TextSize = 8
closeScriptDesc.Font = Enum.Font.Gotham
closeScriptDesc.TextXAlignment = Enum.TextXAlignment.Left
closeScriptDesc.TextYAlignment = Enum.TextYAlignment.Top
closeScriptDesc.TextWrapped = true
closeScriptDesc.Parent = extraContent

-- Confirmation dialog
local confirmFrame = Instance.new("Frame")
confirmFrame.Size = UDim2.new(0, 300, 0, 150)
confirmFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
confirmFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
confirmFrame.BorderSizePixel = 2
confirmFrame.BorderColor3 = Color3.fromRGB(200, 50, 50)
confirmFrame.Visible = false
confirmFrame.ZIndex = 10
confirmFrame.Parent = g

local confirmTitle = Instance.new("TextLabel")
confirmTitle.Size = UDim2.new(1, 0, 0, 40)
confirmTitle.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
confirmTitle.Text = "Close Script?"
confirmTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmTitle.TextSize = 16
confirmTitle.Font = Enum.Font.GothamBold
confirmTitle.BorderSizePixel = 0
confirmTitle.ZIndex = 11
confirmTitle.Parent = confirmFrame

local confirmText = Instance.new("TextLabel")
confirmText.Size = UDim2.new(0, 280, 0, 50)
confirmText.Position = UDim2.new(0, 10, 0, 45)
confirmText.BackgroundTransparency = 1
confirmText.Text = "Are you sure you want to close the script?\nAll functionality will stop."
confirmText.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmText.TextSize = 12
confirmText.Font = Enum.Font.Gotham
confirmText.TextWrapped = true
confirmText.ZIndex = 11
confirmText.Parent = confirmFrame

local yesBtn = Instance.new("TextButton")
yesBtn.Size = UDim2.new(0, 120, 0, 35)
yesBtn.Position = UDim2.new(0, 20, 1, -50)
yesBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
yesBtn.Text = "Yes, Close"
yesBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
yesBtn.TextSize = 12
yesBtn.Font = Enum.Font.GothamBold
yesBtn.BorderSizePixel = 0
yesBtn.ZIndex = 11
yesBtn.Parent = confirmFrame

local noBtn = Instance.new("TextButton")
noBtn.Size = UDim2.new(0, 120, 0, 35)
noBtn.Position = UDim2.new(1, -140, 1, -50)
noBtn.BackgroundColor3 = Color3.fromRGB(80, 140, 80)
noBtn.Text = "No, Cancel"
noBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
noBtn.TextSize = 12
noBtn.Font = Enum.Font.GothamBold
noBtn.BorderSizePixel = 0
noBtn.ZIndex = 11
noBtn.Parent = confirmFrame

-- ==================== SECRET DETECTION SETTINGS SUB-MENU ====================

-- Helper function to create secret settings menu content (reusable for both main and admin abuse)
local function createSecretSettingsMenu(parentFrame, isAdminAbuse)
    -- Background
    local bg = Instance.new("Frame")
    bg.Size = UDim2.new(1, 0, 1, 0)
    bg.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    bg.BorderSizePixel = 0
    bg.ZIndex = 6
    bg.Parent = parentFrame
    
    -- Title
    local menuTitle = Instance.new("TextLabel")
    menuTitle.Size = UDim2.new(1, 0, 0, 40)
    menuTitle.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
    menuTitle.Text = isAdminAbuse and "Admin Abuse Secret Settings" or "Secret Detection Settings"
    menuTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    menuTitle.TextSize = 14
    menuTitle.Font = Enum.Font.GothamBold
    menuTitle.BorderSizePixel = 0
    menuTitle.ZIndex = 7
    menuTitle.Parent = bg
    
    -- Back button
    local backBtn = Instance.new("TextButton")
    backBtn.Size = UDim2.new(0, 60, 0, 30)
    backBtn.Position = UDim2.new(0, 5, 0, 5)
    backBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    backBtn.Text = "‚Üê Back"
    backBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    backBtn.TextSize = 11
    backBtn.Font = Enum.Font.GothamBold
    backBtn.BorderSizePixel = 0
    backBtn.ZIndex = 8
    backBtn.Parent = bg
    
    -- Section labels
    local notifyLabel = Instance.new("TextLabel")
    notifyLabel.Size = UDim2.new(0, 150, 0, 20)
    notifyLabel.Position = UDim2.new(0, 15, 0, 45)
    notifyLabel.BackgroundTransparency = 1
    notifyLabel.Text = "Notifications"
    notifyLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
    notifyLabel.TextSize = 11
    notifyLabel.Font = Enum.Font.GothamBold
    notifyLabel.TextXAlignment = Enum.TextXAlignment.Left
    notifyLabel.ZIndex = 7
    notifyLabel.Parent = bg
    
    local pingLabel = Instance.new("TextLabel")
    pingLabel.Size = UDim2.new(0, 150, 0, 20)
    pingLabel.Position = UDim2.new(0, 185, 0, 45)
    pingLabel.BackgroundTransparency = 1
    pingLabel.Text = "Pings"
    pingLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
    pingLabel.TextSize = 11
    pingLabel.Font = Enum.Font.GothamBold
    pingLabel.TextXAlignment = Enum.TextXAlignment.Left
    pingLabel.ZIndex = 7
    pingLabel.Parent = bg
    
    -- Storage for buttons (returned to caller)
    local buttons = {}
    
    -- Create rows for: Normal, Shiny, Mythic, Shiny Mythic, XL, Infinities, <1B Filter
    local rows = {
        {name = "Normal", key = "Normal", yPos = 70},
        {name = "Shiny", key = "Shiny", yPos = 95},
        {name = "Mythic", key = "Mythic", yPos = 120},
        {name = "Shiny Mythic", key = "ShinyMythic", yPos = 145},
        {name = "XL", key = "XL", yPos = 170},
        {name = "Infinities", key = "Infinity", yPos = 195, special = true}
    }
    
    for _, row in ipairs(rows) do
        -- Notify button (left)
        local notifyBtn = Instance.new("TextButton")
        notifyBtn.Size = UDim2.new(0, 150, 0, 22)
        notifyBtn.Position = UDim2.new(0, 15, 0, row.yPos)
        notifyBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        notifyBtn.Text = row.name .. ": OFF"
        notifyBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        notifyBtn.TextSize = 9
        notifyBtn.Font = Enum.Font.GothamBold
        notifyBtn.BorderSizePixel = 0
        notifyBtn.ZIndex = 7
        notifyBtn.Parent = bg
        buttons["notify" .. row.key] = notifyBtn
        
        -- Ping button (right)
        local pingBtn = Instance.new("TextButton")
        pingBtn.Size = UDim2.new(0, 150, 0, 22)
        pingBtn.Position = UDim2.new(0, 185, 0, row.yPos)
        pingBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        pingBtn.Text = "Ping: OFF"
        pingBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        pingBtn.TextSize = 9
        pingBtn.Font = Enum.Font.GothamBold
        pingBtn.BorderSizePixel = 0
        pingBtn.ZIndex = 7
        pingBtn.Parent = bg
        buttons["ping" .. row.key] = pingBtn
    end
    
    -- <1B Filter button (full width)
    local filterBtn = Instance.new("TextButton")
    filterBtn.Size = UDim2.new(0, 320, 0, 22)
    filterBtn.Position = UDim2.new(0, 15, 0, 220)
    filterBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    filterBtn.Text = "Filter <1B Secrets: OFF"
    filterBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    filterBtn.TextSize = 9
    filterBtn.Font = Enum.Font.GothamBold
    filterBtn.BorderSizePixel = 0
    filterBtn.ZIndex = 7
    filterBtn.Parent = bg
    buttons["filter"] = filterBtn
    
    return buttons, backBtn
end

-- Create main secret settings menu
local mainSecretButtons, mainSecretBackBtn = createSecretSettingsMenu(secretSettingsMenu, false)

-- Create admin abuse secret settings menu
local adminSecretButtons, adminSecretBackBtn = createSecretSettingsMenu(adminSecretSettingsMenu, true)

-- Tab switching logic
hatchingTab.Activated:Connect(function()
    hatchingContent.Visible = true
    detectionContent.Visible = false
    adminAbuseContent.Visible = false
    extraContent.Visible = false
    secretSettingsMenu.Visible = false
    adminSecretSettingsMenu.Visible = false
    hatchingTab.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
    detectionTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    adminAbuseTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    extraTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
end)

detectionTab.Activated:Connect(function()
    hatchingContent.Visible = false
    detectionContent.Visible = true
    adminAbuseContent.Visible = false
    extraContent.Visible = false
    secretSettingsMenu.Visible = false
    adminSecretSettingsMenu.Visible = false
    hatchingTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    detectionTab.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
    adminAbuseTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    extraTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
end)

adminAbuseTab.Activated:Connect(function()
    hatchingContent.Visible = false
    detectionContent.Visible = false
    adminAbuseContent.Visible = true
    extraContent.Visible = false
    secretSettingsMenu.Visible = false
    adminSecretSettingsMenu.Visible = false
    hatchingTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    detectionTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    adminAbuseTab.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
    extraTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
end)

extraTab.Activated:Connect(function()
    hatchingContent.Visible = false
    detectionContent.Visible = false
    adminAbuseContent.Visible = false
    extraContent.Visible = true
    secretSettingsMenu.Visible = false
    adminSecretSettingsMenu.Visible = false
    hatchingTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    detectionTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    adminAbuseTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    extraTab.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
end)

-- Auto Hatch functionality (changed to 0.4s intervals)
autoHatchBtn.Activated:Connect(function()
    if not scriptActive then
        return
    end
    
    autoHatchEnabled = not autoHatchEnabled
    
    if autoHatchEnabled then
        autoHatchBtn.Text = "Auto Hatch: ON"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
        
        -- Start E key spam (0.4s intervals)
        spawn(function()
            while autoHatchEnabled and scriptActive do
                VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                task.wait(0.05)
                VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                task.wait(0.35) -- 0.05 + 0.35 = 0.4s total
            end
        end)
    else
        autoHatchBtn.Text = "Auto Hatch: OFF"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
end)

-- Rift detection toggle
riftBtn.Activated:Connect(function()
    if not scriptActive then return end
    
    riftDetectionEnabled = not riftDetectionEnabled
    
    if riftDetectionEnabled then
        riftBtn.Text = "Rift Detection: ON"
        riftBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        riftBtn.Text = "Rift Detection: OFF"
        riftBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
    
    saveSettings()
end)


-- Player tracking toggle
playerBtn.Activated:Connect(function()
    if not scriptActive then return end
    
    playerTrackingEnabled = not playerTrackingEnabled
    
    if playerTrackingEnabled then
        playerBtn.Text = "Player Track: ON"
        playerBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        playerBtn.Text = "Player Track: OFF"
        playerBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
    
    saveSettings()
end)

-- Admin Abuse Tab Button Handlers

-- Admin Abuse Settings button - opens sub-menu
adminAbuseSettingsBtn.Activated:Connect(function()
    if not scriptActive then return end
    adminSecretSettingsMenu.Visible = true
end)

-- Admin Secret Settings Back button
adminSecretBackBtn.Activated:Connect(function()
    adminSecretSettingsMenu.Visible = false
    saveSettings()
end)

-- Admin Secret Settings Handlers (similar to main, but updates adminAbuseSecretSettings table)
adminSecretButtons.notifyNormal.Activated:Connect(function()
    if not scriptActive then return end
    adminAbuseSecretSettings.notifyNormal = not adminAbuseSecretSettings.notifyNormal
    adminSecretButtons.notifyNormal.Text = adminAbuseSecretSettings.notifyNormal and "Normal: ON" or "Normal: OFF"
    adminSecretButtons.notifyNormal.BackgroundColor3 = adminAbuseSecretSettings.notifyNormal and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

adminSecretButtons.notifyShiny.Activated:Connect(function()
    if not scriptActive then return end
    adminAbuseSecretSettings.notifyShiny = not adminAbuseSecretSettings.notifyShiny
    adminSecretButtons.notifyShiny.Text = adminAbuseSecretSettings.notifyShiny and "Shiny: ON" or "Shiny: OFF"
    adminSecretButtons.notifyShiny.BackgroundColor3 = adminAbuseSecretSettings.notifyShiny and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

adminSecretButtons.notifyMythic.Activated:Connect(function()
    if not scriptActive then return end
    adminAbuseSecretSettings.notifyMythic = not adminAbuseSecretSettings.notifyMythic
    adminSecretButtons.notifyMythic.Text = adminAbuseSecretSettings.notifyMythic and "Mythic: ON" or "Mythic: OFF"
    adminSecretButtons.notifyMythic.BackgroundColor3 = adminAbuseSecretSettings.notifyMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

adminSecretButtons.notifyShinyMythic.Activated:Connect(function()
    if not scriptActive then return end
    adminAbuseSecretSettings.notifyShinyMythic = not adminAbuseSecretSettings.notifyShinyMythic
    adminSecretButtons.notifyShinyMythic.Text = adminAbuseSecretSettings.notifyShinyMythic and "Shiny Mythic: ON" or "Shiny Mythic: OFF"
    adminSecretButtons.notifyShinyMythic.BackgroundColor3 = adminAbuseSecretSettings.notifyShinyMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

adminSecretButtons.notifyXL.Activated:Connect(function()
    if not scriptActive then return end
    adminAbuseSecretSettings.notifyXL = not adminAbuseSecretSettings.notifyXL
    adminSecretButtons.notifyXL.Text = adminAbuseSecretSettings.notifyXL and "XL: ON" or "XL: OFF"
    adminSecretButtons.notifyXL.BackgroundColor3 = adminAbuseSecretSettings.notifyXL and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

adminSecretButtons.notifyInfinity.Activated:Connect(function()
    if not scriptActive then return end
    local current = adminAbuseSecretSettings.notifyInfinity
    if current == nil then current = true end
    adminAbuseSecretSettings.notifyInfinity = not current
    adminSecretButtons.notifyInfinity.Text = adminAbuseSecretSettings.notifyInfinity and "Infinities: ON" or "Infinities: OFF"
    adminSecretButtons.notifyInfinity.BackgroundColor3 = adminAbuseSecretSettings.notifyInfinity and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

adminSecretButtons.pingNormal.Activated:Connect(function()
    if not scriptActive then return end
    adminAbuseSecretSettings.pingNormal = not adminAbuseSecretSettings.pingNormal
    adminSecretButtons.pingNormal.Text = adminAbuseSecretSettings.pingNormal and "Ping: ON" or "Ping: OFF"
    adminSecretButtons.pingNormal.BackgroundColor3 = adminAbuseSecretSettings.pingNormal and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

adminSecretButtons.pingShiny.Activated:Connect(function()
    if not scriptActive then return end
    adminAbuseSecretSettings.pingShiny = not adminAbuseSecretSettings.pingShiny
    adminSecretButtons.pingShiny.Text = adminAbuseSecretSettings.pingShiny and "Ping: ON" or "Ping: OFF"
    adminSecretButtons.pingShiny.BackgroundColor3 = adminAbuseSecretSettings.pingShiny and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

adminSecretButtons.pingMythic.Activated:Connect(function()
    if not scriptActive then return end
    adminAbuseSecretSettings.pingMythic = not adminAbuseSecretSettings.pingMythic
    adminSecretButtons.pingMythic.Text = adminAbuseSecretSettings.pingMythic and "Ping: ON" or "Ping: OFF"
    adminSecretButtons.pingMythic.BackgroundColor3 = adminAbuseSecretSettings.pingMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

adminSecretButtons.pingShinyMythic.Activated:Connect(function()
    if not scriptActive then return end
    adminAbuseSecretSettings.pingShinyMythic = not adminAbuseSecretSettings.pingShinyMythic
    adminSecretButtons.pingShinyMythic.Text = adminAbuseSecretSettings.pingShinyMythic and "Ping: ON" or "Ping: OFF"
    adminSecretButtons.pingShinyMythic.BackgroundColor3 = adminAbuseSecretSettings.pingShinyMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

adminSecretButtons.pingXL.Activated:Connect(function()
    if not scriptActive then return end
    adminAbuseSecretSettings.pingXL = not adminAbuseSecretSettings.pingXL
    adminSecretButtons.pingXL.Text = adminAbuseSecretSettings.pingXL and "Ping: ON" or "Ping: OFF"
    adminSecretButtons.pingXL.BackgroundColor3 = adminAbuseSecretSettings.pingXL and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

adminSecretButtons.pingInfinity.Activated:Connect(function()
    if not scriptActive then return end
    local current = adminAbuseSecretSettings.pingInfinity
    if current == nil then current = true end
    adminAbuseSecretSettings.pingInfinity = not current
    adminSecretButtons.pingInfinity.Text = adminAbuseSecretSettings.pingInfinity and "Ping: ON" or "Ping: OFF"
    adminSecretButtons.pingInfinity.BackgroundColor3 = adminAbuseSecretSettings.pingInfinity and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

adminSecretButtons.filter.Activated:Connect(function()
    if not scriptActive then return end
    adminAbuseSecretSettings.filterUnder1B = not adminAbuseSecretSettings.filterUnder1B
    adminSecretButtons.filter.Text = adminAbuseSecretSettings.filterUnder1B and "Filter <1B Secrets: ON" or "Filter <1B Secrets: OFF"
    adminSecretButtons.filter.BackgroundColor3 = adminAbuseSecretSettings.filterUnder1B and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

-- Admin Abuse Toggle button (with confirmation on deactivation)
-- Confirmation dialog for admin abuse deactivation
local adminAbuseConfirmFrame = Instance.new("Frame")
adminAbuseConfirmFrame.Size = UDim2.new(0, 320, 0, 170)
adminAbuseConfirmFrame.Position = UDim2.new(0.5, -160, 0.5, -85)
adminAbuseConfirmFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
adminAbuseConfirmFrame.BorderSizePixel = 2
adminAbuseConfirmFrame.BorderColor3 = Color3.fromRGB(200, 150, 50)
adminAbuseConfirmFrame.Visible = false
adminAbuseConfirmFrame.ZIndex = 10
adminAbuseConfirmFrame.Parent = g

local adminAbuseConfirmTitle = Instance.new("TextLabel")
adminAbuseConfirmTitle.Size = UDim2.new(1, 0, 0, 40)
adminAbuseConfirmTitle.BackgroundColor3 = Color3.fromRGB(200, 150, 50)
adminAbuseConfirmTitle.Text = "Stop Admin Abuse Mode?"
adminAbuseConfirmTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
adminAbuseConfirmTitle.TextSize = 14
adminAbuseConfirmTitle.Font = Enum.Font.GothamBold
adminAbuseConfirmTitle.BorderSizePixel = 0
adminAbuseConfirmTitle.ZIndex = 11
adminAbuseConfirmTitle.Parent = adminAbuseConfirmFrame

local adminAbuseConfirmText = Instance.new("TextLabel")
adminAbuseConfirmText.Size = UDim2.new(0, 300, 0, 70)
adminAbuseConfirmText.Position = UDim2.new(0, 10, 0, 45)
adminAbuseConfirmText.BackgroundTransparency = 1
adminAbuseConfirmText.Text = "A summary of all secrets/infinities hatched during admin abuse will be sent to your webhook."
adminAbuseConfirmText.TextColor3 = Color3.fromRGB(255, 255, 255)
adminAbuseConfirmText.TextSize = 11
adminAbuseConfirmText.Font = Enum.Font.Gotham
adminAbuseConfirmText.TextWrapped = true
adminAbuseConfirmText.ZIndex = 11
adminAbuseConfirmText.Parent = adminAbuseConfirmFrame

local adminAbuseYesBtn = Instance.new("TextButton")
adminAbuseYesBtn.Size = UDim2.new(0, 130, 0, 35)
adminAbuseYesBtn.Position = UDim2.new(0, 15, 1, -50)
adminAbuseYesBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
adminAbuseYesBtn.Text = "Yes, Stop & Send"
adminAbuseYesBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
adminAbuseYesBtn.TextSize = 11
adminAbuseYesBtn.Font = Enum.Font.GothamBold
adminAbuseYesBtn.BorderSizePixel = 0
adminAbuseYesBtn.ZIndex = 11
adminAbuseYesBtn.Parent = adminAbuseConfirmFrame

local adminAbuseNoBtn = Instance.new("TextButton")
adminAbuseNoBtn.Size = UDim2.new(0, 130, 0, 35)
adminAbuseNoBtn.Position = UDim2.new(1, -145, 1, -50)
adminAbuseNoBtn.BackgroundColor3 = Color3.fromRGB(80, 140, 80)
adminAbuseNoBtn.Text = "Cancel"
adminAbuseNoBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
adminAbuseNoBtn.TextSize = 11
adminAbuseNoBtn.Font = Enum.Font.GothamBold
adminAbuseNoBtn.BorderSizePixel = 0
adminAbuseNoBtn.ZIndex = 11
adminAbuseNoBtn.Parent = adminAbuseConfirmFrame

adminAbuseToggleBtn.Activated:Connect(function()
    if not scriptActive then return end
    
    if adminAbuseActive then
        -- Show confirmation dialog
        adminAbuseConfirmFrame.Visible = true
    else
        -- Turn ON admin abuse mode
        adminAbuseActive = true
        adminAbuseHatchedPets = {} -- Reset tracking
        adminAbuseToggleBtn.Text = "Admin Abuse Mode: ON"
        adminAbuseToggleBtn.BackgroundColor3 = Color3.fromRGB(255, 200, 50)
        print(">>> ADMIN ABUSE MODE ACTIVATED <<<")
    end
end)

adminAbuseYesBtn.Activated:Connect(function()
    -- Turn OFF admin abuse mode and send summary
    adminAbuseActive = false
    adminAbuseToggleBtn.Text = "Admin Abuse Mode: OFF"
    adminAbuseToggleBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    adminAbuseConfirmFrame.Visible = false
    
    -- Generate and send summary (function defined later)
    sendAdminAbuseSummary()
    
    print(">>> ADMIN ABUSE MODE DEACTIVATED <<<")
end)

adminAbuseNoBtn.Activated:Connect(function()
    adminAbuseConfirmFrame.Visible = false
end)

-- Close Script button - opens confirmation dialog
closeScriptBtn.Activated:Connect(function()
    confirmFrame.Visible = true
end)

-- Pet Detection Tab Button Handlers

-- Secret Settings button - opens sub-menu
secretSettingsBtn.Activated:Connect(function()
    if not scriptActive then return end
    secretSettingsMenu.Visible = true
end)

-- Main Secret Settings Back button
mainSecretBackBtn.Activated:Connect(function()
    secretSettingsMenu.Visible = false
    saveSettings()
end)

-- Main Secret Settings Handlers
mainSecretButtons.notifyNormal.Activated:Connect(function()
    if not scriptActive then return end
    secretNotifyNormal = not secretNotifyNormal
    mainSecretButtons.notifyNormal.Text = secretNotifyNormal and "Normal: ON" or "Normal: OFF"
    mainSecretButtons.notifyNormal.BackgroundColor3 = secretNotifyNormal and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

mainSecretButtons.notifyShiny.Activated:Connect(function()
    if not scriptActive then return end
    secretNotifyShiny = not secretNotifyShiny
    mainSecretButtons.notifyShiny.Text = secretNotifyShiny and "Shiny: ON" or "Shiny: OFF"
    mainSecretButtons.notifyShiny.BackgroundColor3 = secretNotifyShiny and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

mainSecretButtons.notifyMythic.Activated:Connect(function()
    if not scriptActive then return end
    secretNotifyMythic = not secretNotifyMythic
    mainSecretButtons.notifyMythic.Text = secretNotifyMythic and "Mythic: ON" or "Mythic: OFF"
    mainSecretButtons.notifyMythic.BackgroundColor3 = secretNotifyMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

mainSecretButtons.notifyShinyMythic.Activated:Connect(function()
    if not scriptActive then return end
    secretNotifyShinyMythic = not secretNotifyShinyMythic
    mainSecretButtons.notifyShinyMythic.Text = secretNotifyShinyMythic and "Shiny Mythic: ON" or "Shiny Mythic: OFF"
    mainSecretButtons.notifyShinyMythic.BackgroundColor3 = secretNotifyShinyMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

mainSecretButtons.notifyXL.Activated:Connect(function()
    if not scriptActive then return end
    secretNotifyXL = not secretNotifyXL
    mainSecretButtons.notifyXL.Text = secretNotifyXL and "XL: ON" or "XL: OFF"
    mainSecretButtons.notifyXL.BackgroundColor3 = secretNotifyXL and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

mainSecretButtons.notifyInfinity.Activated:Connect(function()
    if not scriptActive then return end
    infinityNotifyEnabled = not infinityNotifyEnabled
    mainSecretButtons.notifyInfinity.Text = infinityNotifyEnabled and "Infinities: ON" or "Infinities: OFF"
    mainSecretButtons.notifyInfinity.BackgroundColor3 = infinityNotifyEnabled and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

mainSecretButtons.pingNormal.Activated:Connect(function()
    if not scriptActive then return end
    secretPingNormal = not secretPingNormal
    mainSecretButtons.pingNormal.Text = secretPingNormal and "Ping: ON" or "Ping: OFF"
    mainSecretButtons.pingNormal.BackgroundColor3 = secretPingNormal and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

mainSecretButtons.pingShiny.Activated:Connect(function()
    if not scriptActive then return end
    secretPingShiny = not secretPingShiny
    mainSecretButtons.pingShiny.Text = secretPingShiny and "Ping: ON" or "Ping: OFF"
    mainSecretButtons.pingShiny.BackgroundColor3 = secretPingShiny and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

mainSecretButtons.pingMythic.Activated:Connect(function()
    if not scriptActive then return end
    secretPingMythic = not secretPingMythic
    mainSecretButtons.pingMythic.Text = secretPingMythic and "Ping: ON" or "Ping: OFF"
    mainSecretButtons.pingMythic.BackgroundColor3 = secretPingMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

mainSecretButtons.pingShinyMythic.Activated:Connect(function()
    if not scriptActive then return end
    secretPingShinyMythic = not secretPingShinyMythic
    mainSecretButtons.pingShinyMythic.Text = secretPingShinyMythic and "Ping: ON" or "Ping: OFF"
    mainSecretButtons.pingShinyMythic.BackgroundColor3 = secretPingShinyMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

mainSecretButtons.pingXL.Activated:Connect(function()
    if not scriptActive then return end
    secretPingXL = not secretPingXL
    mainSecretButtons.pingXL.Text = secretPingXL and "Ping: ON" or "Ping: OFF"
    mainSecretButtons.pingXL.BackgroundColor3 = secretPingXL and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

mainSecretButtons.pingInfinity.Activated:Connect(function()
    if not scriptActive then return end
    infinityPingEnabled = not infinityPingEnabled
    mainSecretButtons.pingInfinity.Text = infinityPingEnabled and "Ping: ON" or "Ping: OFF"
    mainSecretButtons.pingInfinity.BackgroundColor3 = infinityPingEnabled and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

mainSecretButtons.filter.Activated:Connect(function()
    if not scriptActive then return end
    secretFilterUnder1B = not secretFilterUnder1B
    mainSecretButtons.filter.Text = secretFilterUnder1B and "Filter <1B Secrets: ON" or "Filter <1B Secrets: OFF"
    mainSecretButtons.filter.BackgroundColor3 = secretFilterUnder1B and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    saveSettings()
end)

-- XL Detection toggle
xlBtn.Activated:Connect(function()
    if not scriptActive then return end
    
    xlDetectionEnabled = not xlDetectionEnabled
    
    if xlDetectionEnabled then
        xlBtn.Text = "Detect XL Pets: ON"
        xlBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        xlBtn.Text = "Detect XL Pets: OFF"
        xlBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
    
    saveSettings()
end)

-- XL Ping toggle
xlPingBtn.Activated:Connect(function()
    if not scriptActive then return end
    
    xlPingEnabled = not xlPingEnabled
    
    if xlPingEnabled then
        xlPingBtn.Text = "XL Pings: ON"
        xlPingBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        xlPingBtn.Text = "XL Pings: OFF"
        xlPingBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
    
    saveSettings()
end)

-- Legendary Detection toggle
legendaryBtn.Activated:Connect(function()
    if not scriptActive then return end
    
    legendaryDetectionEnabled = not legendaryDetectionEnabled
    
    if legendaryDetectionEnabled then
        legendaryBtn.Text = "Legendary Detection: ON"
        legendaryBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        legendaryBtn.Text = "Legendary Detection: OFF"
        legendaryBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
    
    saveSettings()
end)

-- Legendary Ping toggle
legendaryPingBtn.Activated:Connect(function()
    if not scriptActive then return end
    
    legendaryPingEnabled = not legendaryPingEnabled
    
    if legendaryPingEnabled then
        legendaryPingBtn.Text = "Legendary Pings: ON"
        legendaryPingBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        legendaryPingBtn.Text = "Legendary Pings: OFF"
        legendaryPingBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
    
    saveSettings()
end)

-- Hide X button - hides main GUI
hideXBtn.Activated:Connect(function()
    f.Visible = false
    toggleBtn.Text = ">>>"
    toggleBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
end)

-- Toggle button - shows/hides main GUI
toggleBtn.Activated:Connect(function()
    f.Visible = not f.Visible
    if f.Visible then
        toggleBtn.Text = "GUI"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
    else
        toggleBtn.Text = ">>>"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    end
end)

-- Webhook URL input handler
webhookInput.FocusLost:Connect(function(enterPressed)
    local url = webhookInput.Text:gsub("^%s*(.-)%s*$", "%1")
    webhookURL = url
    print("Webhook URL saved: " .. (url ~= "" and "SET (" .. string.sub(url, 1, 50) .. "...)" or "EMPTY"))
    saveSettings()
end)

-- Discord User ID input handler
userIDInput.FocusLost:Connect(function(enterPressed)
    local id = userIDInput.Text:gsub("^%s*(.-)%s*$", "%1")
    discordUserID = id
    print("Discord User ID saved: " .. (id ~= "" and id or "EMPTY"))
    saveSettings()
end)

-- Yes button - closes everything
yesBtn.Activated:Connect(function()
    print("Closing script...")
    
    -- Mark script as inactive
    scriptActive = false
    
    -- Stop auto hatch
    autoHatchEnabled = false
    
    -- Disconnect event connection
    if hatchEventConnection then
        hatchEventConnection:Disconnect()
        hatchEventConnection = nil
        print("‚úì Event connection disconnected")
    end
    
    -- Clear webhook queue
    webhookQueue = {}
    isSendingWebhook = false
    print("‚úì Webhook queue cleared")
    
    -- Destroy GUI
    g:Destroy()
    print("‚úì GUI destroyed")
    
    print("Script closed by user - all functionality stopped")
    error("Script closed")
end)

-- No button - closes confirmation dialog
noBtn.Activated:Connect(function()
    confirmFrame.Visible = false
end)

print("‚úì GUI created")

-- Update button states to reflect loaded settings
task.wait(0.1) -- Small delay to ensure all GUI elements are fully created
spawn(function()
    -- Update rift detection button
    if riftDetectionEnabled then
        riftBtn.Text = "Rift Detection: ON"
        riftBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        riftBtn.Text = "Rift Detection: OFF"
        riftBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
    
    -- Update player tracking button
    if playerTrackingEnabled then
        playerBtn.Text = "Player Track: ON"
        playerBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        playerBtn.Text = "Player Track: OFF"
        playerBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
    
    -- Update XL detection buttons
    if xlDetectionEnabled then
        xlBtn.Text = "Detect XL Pets: ON"
        xlBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        xlBtn.Text = "Detect XL Pets: OFF"
        xlBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
    
    if xlPingEnabled then
        xlPingBtn.Text = "XL Pings: ON"
        xlPingBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        xlPingBtn.Text = "XL Pings: OFF"
        xlPingBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
    
    -- Update legendary detection buttons
    if legendaryDetectionEnabled then
        legendaryBtn.Text = "Legendary Detection: ON"
        legendaryBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        legendaryBtn.Text = "Legendary Detection: OFF"
        legendaryBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
    
    if legendaryPingEnabled then
        legendaryPingBtn.Text = "Legendary Pings: ON"
        legendaryPingBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        legendaryPingBtn.Text = "Legendary Pings: OFF"
        legendaryPingBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
    
    -- Update main secret settings buttons
    mainSecretButtons.notifyNormal.Text = secretNotifyNormal and "Normal: ON" or "Normal: OFF"
    mainSecretButtons.notifyNormal.BackgroundColor3 = secretNotifyNormal and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    mainSecretButtons.notifyShiny.Text = secretNotifyShiny and "Shiny: ON" or "Shiny: OFF"
    mainSecretButtons.notifyShiny.BackgroundColor3 = secretNotifyShiny and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    mainSecretButtons.notifyMythic.Text = secretNotifyMythic and "Mythic: ON" or "Mythic: OFF"
    mainSecretButtons.notifyMythic.BackgroundColor3 = secretNotifyMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    mainSecretButtons.notifyShinyMythic.Text = secretNotifyShinyMythic and "Shiny Mythic: ON" or "Shiny Mythic: OFF"
    mainSecretButtons.notifyShinyMythic.BackgroundColor3 = secretNotifyShinyMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    mainSecretButtons.notifyXL.Text = secretNotifyXL and "XL: ON" or "XL: OFF"
    mainSecretButtons.notifyXL.BackgroundColor3 = secretNotifyXL and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    mainSecretButtons.notifyInfinity.Text = infinityNotifyEnabled and "Infinities: ON" or "Infinities: OFF"
    mainSecretButtons.notifyInfinity.BackgroundColor3 = infinityNotifyEnabled and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    mainSecretButtons.pingNormal.Text = secretPingNormal and "Ping: ON" or "Ping: OFF"
    mainSecretButtons.pingNormal.BackgroundColor3 = secretPingNormal and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    mainSecretButtons.pingShiny.Text = secretPingShiny and "Ping: ON" or "Ping: OFF"
    mainSecretButtons.pingShiny.BackgroundColor3 = secretPingShiny and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    mainSecretButtons.pingMythic.Text = secretPingMythic and "Ping: ON" or "Ping: OFF"
    mainSecretButtons.pingMythic.BackgroundColor3 = secretPingMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    mainSecretButtons.pingShinyMythic.Text = secretPingShinyMythic and "Ping: ON" or "Ping: OFF"
    mainSecretButtons.pingShinyMythic.BackgroundColor3 = secretPingShinyMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    mainSecretButtons.pingXL.Text = secretPingXL and "Ping: ON" or "Ping: OFF"
    mainSecretButtons.pingXL.BackgroundColor3 = secretPingXL and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    mainSecretButtons.pingInfinity.Text = infinityPingEnabled and "Ping: ON" or "Ping: OFF"
    mainSecretButtons.pingInfinity.BackgroundColor3 = infinityPingEnabled and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    mainSecretButtons.filter.Text = secretFilterUnder1B and "Filter <1B Secrets: ON" or "Filter <1B Secrets: OFF"
    mainSecretButtons.filter.BackgroundColor3 = secretFilterUnder1B and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    -- Update admin secret settings buttons
    adminSecretButtons.notifyNormal.Text = adminAbuseSecretSettings.notifyNormal and "Normal: ON" or "Normal: OFF"
    adminSecretButtons.notifyNormal.BackgroundColor3 = adminAbuseSecretSettings.notifyNormal and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    adminSecretButtons.notifyShiny.Text = adminAbuseSecretSettings.notifyShiny and "Shiny: ON" or "Shiny: OFF"
    adminSecretButtons.notifyShiny.BackgroundColor3 = adminAbuseSecretSettings.notifyShiny and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    adminSecretButtons.notifyMythic.Text = adminAbuseSecretSettings.notifyMythic and "Mythic: ON" or "Mythic: OFF"
    adminSecretButtons.notifyMythic.BackgroundColor3 = adminAbuseSecretSettings.notifyMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    adminSecretButtons.notifyShinyMythic.Text = adminAbuseSecretSettings.notifyShinyMythic and "Shiny Mythic: ON" or "Shiny Mythic: OFF"
    adminSecretButtons.notifyShinyMythic.BackgroundColor3 = adminAbuseSecretSettings.notifyShinyMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    adminSecretButtons.notifyXL.Text = adminAbuseSecretSettings.notifyXL and "XL: ON" or "XL: OFF"
    adminSecretButtons.notifyXL.BackgroundColor3 = adminAbuseSecretSettings.notifyXL and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    local adminInfinityNotify = adminAbuseSecretSettings.notifyInfinity
    if adminInfinityNotify == nil then adminInfinityNotify = true end
    adminSecretButtons.notifyInfinity.Text = adminInfinityNotify and "Infinities: ON" or "Infinities: OFF"
    adminSecretButtons.notifyInfinity.BackgroundColor3 = adminInfinityNotify and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    adminSecretButtons.pingNormal.Text = adminAbuseSecretSettings.pingNormal and "Ping: ON" or "Ping: OFF"
    adminSecretButtons.pingNormal.BackgroundColor3 = adminAbuseSecretSettings.pingNormal and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    adminSecretButtons.pingShiny.Text = adminAbuseSecretSettings.pingShiny and "Ping: ON" or "Ping: OFF"
    adminSecretButtons.pingShiny.BackgroundColor3 = adminAbuseSecretSettings.pingShiny and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    adminSecretButtons.pingMythic.Text = adminAbuseSecretSettings.pingMythic and "Ping: ON" or "Ping: OFF"
    adminSecretButtons.pingMythic.BackgroundColor3 = adminAbuseSecretSettings.pingMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    adminSecretButtons.pingShinyMythic.Text = adminAbuseSecretSettings.pingShinyMythic and "Ping: ON" or "Ping: OFF"
    adminSecretButtons.pingShinyMythic.BackgroundColor3 = adminAbuseSecretSettings.pingShinyMythic and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    adminSecretButtons.pingXL.Text = adminAbuseSecretSettings.pingXL and "Ping: ON" or "Ping: OFF"
    adminSecretButtons.pingXL.BackgroundColor3 = adminAbuseSecretSettings.pingXL and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    local adminInfinityPing = adminAbuseSecretSettings.pingInfinity
    if adminInfinityPing == nil then adminInfinityPing = true end
    adminSecretButtons.pingInfinity.Text = adminInfinityPing and "Ping: ON" or "Ping: OFF"
    adminSecretButtons.pingInfinity.BackgroundColor3 = adminInfinityPing and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    adminSecretButtons.filter.Text = adminAbuseSecretSettings.filterUnder1B and "Filter <1B Secrets: ON" or "Filter <1B Secrets: OFF"
    adminSecretButtons.filter.BackgroundColor3 = adminAbuseSecretSettings.filterUnder1B and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(60, 60, 60)
    
    print("‚úì Button states updated from loaded settings")
end)

print("Ready! Click 'Auto Hatch' to start hatching")

-- Monitor GUI to detect if it gets destroyed unexpectedly
g.AncestryChanged:Connect(function(child, parent)
    if not parent and scriptActive then
        warn("WARNING: GUI was destroyed or removed!")
    end
end)
