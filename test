-- BUBBLEGUM SIMULATOR - AUTO HATCH & SECRET NOTIFIER
-- Version 3.0 with XL support, tab system, and extra features

local P = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local VIM = game:GetService("VirtualInputManager")
local HttpService = game:GetService("HttpService")
local TextChatService = game:GetService("TextChatService")
local p = P.LocalPlayer

-- Detection Settings (moved to GUI toggle button in Extra tab)

-- Special Pets (pets that should receive special notifications)
-- Add pet names here (case insensitive, supports spaces)
local SPECIAL_PETS = {
    "Neon Elemental",
    "Inferno Dragon",
    "Morning Star",
    "Christmas Robot",
    "Rumblecon God",
    "Leviathan",
    "Sylently's Pet"
    -- Add more pet names here as needed
}

-- Pre-compute lowercase special pets for faster lookup (optimization)
local SPECIAL_PETS_LOWER = {}
for _, petName in ipairs(SPECIAL_PETS) do
    SPECIAL_PETS_LOWER[string.lower(petName)] = true
end

print("========================================")
print("BUBBLEGUM AUTO HATCH & NOTIFIER")
print("Version: 3.0")
print("========================================")

-- Load required modules
local Remote = nil
local ItemUtil = nil
local PetsData = nil
local PetUtil = nil
local FormatCommas = nil
local LocalData = nil

-- Settings
local autoHatchEnabled = false
local webhookURL = ""
local discordUserID = ""
local riftDetectionEnabled = false
local hourlyStatusEnabled = true -- Default to ON
local playerTrackingEnabled = true -- Default to ON
local legendaryDetectionEnabled = false -- Default to OFF (for testing)

-- Script start time for runtime calculation
local scriptStartTime = os.time()

-- Settings file path
local SETTINGS_FILE = "bubblegum_settings.json"

-- Load settings from file (non-blocking, won't break if it fails)
local function loadSettings()
    if not readfile or not isfile or not HttpService then
        return -- File system not available, use defaults
    end
    
    local success, result = pcall(function()
        if isfile(SETTINGS_FILE) then
            local content = readfile(SETTINGS_FILE)
            if content and content ~= "" then
                local decoded = HttpService:JSONDecode(content)
                if decoded and type(decoded) == "table" then
                    if decoded.webhookURL and type(decoded.webhookURL) == "string" then
                        webhookURL = decoded.webhookURL
                    end
                    if decoded.discordUserID and type(decoded.discordUserID) == "string" then
                        discordUserID = decoded.discordUserID
                    end
                    print("‚úì Settings loaded from file")
                    return true
                end
            end
        end
        return false
    end)
    
    if not success then
        -- Silently fail, use defaults
    end
end

-- Save settings to file (non-blocking, won't break if it fails)
local function saveSettings()
    if not writefile or not HttpService then
        return -- File system not available, skip saving
    end
    
    pcall(function()
        local settings = {
            webhookURL = webhookURL or "",
            discordUserID = discordUserID or ""
        }
        local json = HttpService:JSONEncode(settings)
        writefile(SETTINGS_FILE, json)
        print("‚úì Settings saved")
    end)
end

-- Webhook queue for rate limiting
local webhookQueue = {}
local isSendingWebhook = false
local messagesRemainingWithDelay = 0 -- Counter for messages that need 2s delay after rate limit

-- Script state
local scriptActive = true
local hatchEventConnection = nil

-- Load modules
local function loadModules()
    -- Load Remote
    local success, remoteModule = pcall(function()
        return require(RS.Shared.Framework.Network.Remote)
    end)
    if success and remoteModule then
        Remote = remoteModule
        print("‚úì Loaded Remote module")
    end
    
    -- Load ItemUtil
    local success2, itemUtil = pcall(function()
        return require(RS.Shared.Utils.Stats.ItemUtil)
    end)
    if success2 and itemUtil then
        ItemUtil = itemUtil
        print("‚úì Loaded ItemUtil")
    end
    
    -- Load Pets data for images
    local success3, petsData = pcall(function()
        return require(RS.Shared.Data.Pets)
    end)
    if success3 and petsData then
        PetsData = petsData
        print("‚úì Loaded Pets data")
    end
    
    -- Load PetUtil for chance calculation
    local success4, petUtil = pcall(function()
        return require(RS.Shared.Utils.Stats.PetUtil)
    end)
    if success4 and petUtil then
        PetUtil = petUtil
        print("‚úì Loaded PetUtil")
    end
    
    -- Load FormatCommas for number formatting
    local success5, formatCommas = pcall(function()
        return require(RS.Shared.Framework.Utilities.String.FormatCommas)
    end)
    if success5 and formatCommas then
        FormatCommas = formatCommas
        print("‚úì Loaded FormatCommas")
    end
    
    -- Load LocalData for player stats
    local success6, localData = pcall(function()
        return require(RS.Client.Framework.Services.LocalData)
    end)
    if success6 and localData then
        LocalData = localData
        print("‚úì Loaded LocalData")
    end
end

loadModules()

-- Load saved settings (before GUI creation, non-blocking)
loadSettings()

-- HTTP for Delta Mobile (using the working method from testing)
local httpLib = nil
local httpLibName = nil
if request then
    httpLib = function(url, method, headers, body)
        local success, res, err = pcall(function()
            return request({Url=url, Method=method, Headers=headers or {}, Body=body})
        end)
        if success and res then
            local status = res.StatusCode or (res.Success and 200 or (res.success and 200 or 0))
            local body = res.Body or res.body or ""
            local ok = res.Success or res.success or status == 200 or status == 204
            return ok, body, status
        end
        return false, err or "Request exception", 0
    end
    httpLibName = "request"
end

-- Function to get Discord-compatible thumbnail URL from Roblox asset ID
local function getThumbnailUrl(assetId)
    if not assetId then
        return nil
    end
    
    local url = "https://thumbnails.roproxy.com/v1/assets?assetIds=" .. assetId .. "&size=420x420&format=Png&isCircular=false"
    
    local success, response, errorMsg = pcall(function()
        -- Try httpLib first (we know this works for webhooks)
        if httpLib then
            local ok, body, status = httpLib(url, "GET", {}, "")
            if ok and status == 200 then
                return body, nil
            else
                return nil, "httpLib returned status " .. tostring(status)
            end
        elseif HttpService and HttpService.GetAsync then
            return HttpService:GetAsync(url), nil
        else
            return nil, "No HTTP method available"
        end
    end)
    
    if not success then
        return nil
    end
    
    if not response then
        return nil
    end
    
    -- Try to decode JSON
    local success2, decoded = pcall(function()
        if HttpService and HttpService.JSONDecode then
            return HttpService:JSONDecode(response)
        end
        return nil
    end)
    
    if not success2 then
        return nil
    end
    
    if decoded and decoded.data and decoded.data[1] and decoded.data[1].imageUrl then
        return decoded.data[1].imageUrl
    end
    
    return nil
end

-- JSON encoder (properly handles nested structures)
local function jsonEncode(t)
    local function encodeValue(v, depth)
        depth = depth or 0
        if depth > 10 then return "null" end -- Prevent infinite recursion
        
        if type(v) == "string" then
            -- Escape special characters
            v = v:gsub("\\", "\\\\")
            v = v:gsub('"', '\\"')
            v = v:gsub("\n", "\\n")
            v = v:gsub("\r", "\\r")
            v = v:gsub("\t", "\\t")
            return '"' .. v .. '"'
        elseif type(v) == "number" then
            return tostring(v)
        elseif type(v) == "boolean" then
            return v and "true" or "false"
        elseif type(v) == "table" then
            -- Check if it's an array
            local isArray = false
            local maxIndex = 0
            for k in pairs(v) do
                if type(k) == "number" then
                    maxIndex = math.max(maxIndex, k)
                end
            end
            isArray = maxIndex > 0 and maxIndex == #v
            
            local parts = {}
            if isArray then
                for i = 1, maxIndex do
                    table.insert(parts, encodeValue(v[i], depth + 1))
                end
                return "[" .. table.concat(parts, ",") .. "]"
            else
                for k, val in pairs(v) do
                    if val ~= nil then
                        local key = type(k) == "string" and ('"' .. k .. '"') or tostring(k)
                        table.insert(parts, key .. ":" .. encodeValue(val, depth + 1))
                    end
                end
                return "{" .. table.concat(parts, ",") .. "}"
            end
        else
            return "null"
        end
    end
    return encodeValue(t, 0)
end

-- Helper function to get embed color based on pet attributes
local function getEmbedColor(shiny, mythic, xl, isSpecialPet)
    if isSpecialPet then
        -- Infinity pet colors
        if shiny and mythic and xl then
            return 8388608 -- Maroon #800000
        elseif mythic and xl then
            return 14745599 -- Pastel pink/purple #E0B0FF
        elseif shiny and xl then
            return 12779520 -- Bright lime green lighter #C2FF00
        elseif shiny and mythic then
            return 16738740 -- Bright hot pink #FF1493
        elseif xl then
            return 16760576 -- Orange closer to yellow #FFA700
        elseif mythic then
            return 16711935 -- Bright magenta #FF00FF
        elseif shiny then
            return 65280 -- Bright pure green #00FF00
        else
            return 65535 -- Cyan #00FFFF
        end
    else
        -- Regular pet colors
        if shiny and mythic and xl then
            return 13369344 -- Darker red #CC0000
        elseif mythic and xl then
            return 255 -- Dark bright blue #0000FF
        elseif shiny and xl then
            return 16776960 -- Pure yellow #FFFF00
        elseif shiny and mythic then
            return 16711680 -- Pure red #FF0000
        elseif xl then
            return 16744448 -- Deep bright orange #FF6600
        elseif mythic then
            return 10494192 -- Purple #A020F0
        elseif shiny then
            return 16766720 -- Slightly darker yellow but bright (Gold) #FFD700
        else
            return 12303291 -- Light grey #BBBBBB
        end
    end
end

-- Helper function to check if a pet is in the special pets list (case insensitive)
-- Optimized: uses pre-computed lowercase lookup table
local function isSpecialPet(petName)
    if not petName then return false end
    return SPECIAL_PETS_LOWER[string.lower(petName)] == true
end

-- Helper function to check if rarity is Infinity (case insensitive)
local function isInfinityRarity(rarity)
    if not rarity then return false end
    return string.lower(tostring(rarity)) == "infinity"
end

-- Function to send plain text webhook
local function sendPlainTextWebhook(message, shouldPing)
    if not httpLib or webhookURL == "" then 
        return true
    end
    
    local content = message
    if shouldPing and discordUserID ~= "" then
        content = "<@" .. discordUserID .. "> " .. message
    end
    
    local payload = {
        content = content
    }
    
    local jsonPayload = jsonEncode(payload)
    
    local success, response, status = pcall(function()
        return httpLib(webhookURL, "POST", {
            ["Content-Type"] = "application/json"
        }, jsonPayload)
    end)
    
    if success and (status == 200 or status == 204) then
        return true
    elseif success and status == 429 then
        return false -- Return false to trigger retry
    else
        return true -- Return true for other errors to not retry
    end
end

-- Function to send debug webhook (no ping, plain text)
local function sendDebugWebhook(message)
    if not httpLib or webhookURL == "" then 
        return true
    end
    
    local embed = {
        title = "üîç Debug Info",
        description = message,
        color = 8421504, -- Grey color for debug
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    local payload = {
        embeds = {embed}
        -- No content field = no ping
    }
    
    local jsonPayload = jsonEncode(payload)
    
    local success, response, status = pcall(function()
        return httpLib(webhookURL, "POST", {
            ["Content-Type"] = "application/json"
        }, jsonPayload)
    end)
    
    if success and status == 200 then
        print("‚úì Debug webhook sent successfully")
        return true
    elseif success and status == 429 then
        print("‚úó Debug webhook rate limited (429)")
        return false -- Return false to trigger retry
    else
        print("‚úó Debug webhook failed: status=" .. tostring(status))
        return true -- Return true for other errors to not retry
    end
end

-- Helper function to get total eggs hatched count
local function getTotalEggsHatched()
    if not LocalData then
        return nil
    end
    
    local success, data = pcall(function()
        return LocalData:Get() -- Use :Get() not :GetData()
    end)
    
    if not success or not data then
        return nil
    end
    
    if not data.Stats then
        return nil
    end
    
    -- Try multiple possible field names
    local hatches = data.Stats.Hatches 
        or data.Stats.TotalEggsOpened 
        or data.Stats["ü•öHatches"]
        or data.Stats["ü•ö Hatches"]
    
    return hatches
end

-- Function to send special webhook (with infinity colors and message)
local function sendSpecialDiscordNotificationInternal(petName, shiny, mythic, xl, eggName, rarity, pet, petImageUrl, isInfinity)
    if not httpLib or webhookURL == "" then 
        return true
    end
    
    -- Get player name
    local playerName = p.Name or "Unknown Player"
    
    -- Get total eggs hatched
    local eggsHatched = getTotalEggsHatched()
    
    -- Build pet name with prefix (XL goes AFTER shiny/mythic)
    local fullPetName = ""
    if shiny and mythic then
        fullPetName = "Shiny Mythic "
    elseif shiny then
        fullPetName = "Shiny "
    elseif mythic then
        fullPetName = "Mythic "
    end
    
    if xl then
        fullPetName = fullPetName .. "XL "
    end
    
    fullPetName = fullPetName .. petName
    
    -- Determine color
    local embedColor = getEmbedColor(shiny, mythic, xl, true)
    
    -- Build mention (for Discord ping)
    local mention = discordUserID ~= "" and ("<@" .. discordUserID .. ">") or ""
    
    -- Calculate probability if PetUtil is available
    local probabilityText = nil
    if PetUtil and pet then
        local success, petChance = pcall(function()
            return PetUtil:GetChance(pet)
        end)
        if success and petChance and petChance > 0 then
            local denominator = math.ceil(100 / petChance)
            if FormatCommas then
                probabilityText = "1/" .. FormatCommas(denominator)
            else
                local formatted = tostring(denominator)
                formatted = formatted:reverse():gsub("(%d%d%d)", "%1,"):reverse()
                formatted = formatted:gsub("^,", "")
                probabilityText = "1/" .. formatted
            end
        end
    end
    
    -- Determine "a" or "an" for the pet name
    local article = "a"
    if not shiny and not mythic and petName then
        local firstLetter = string.lower(string.sub(petName, 1, 1))
        if firstLetter == "a" or firstLetter == "e" or firstLetter == "i" or firstLetter == "o" or firstLetter == "u" then
            article = "an"
        end
    end
    
    -- Build description (infinity message is now in title)
    local description = "**" .. playerName .. "** hatched " .. article .. " **" .. fullPetName .. "**!"
    
    -- Build fields
    local fields = {
        {
            name = "Hatched",
            value = fullPetName,
            inline = false
        }
    }
    
    -- Add probability or rarity field
    if probabilityText then
        table.insert(fields, {
            name = "Rarity",
            value = probabilityText,
            inline = true
        })
    elseif rarity then
        table.insert(fields, {
            name = "Rarity",
            value = rarity,
            inline = true
        })
    end
    
    -- Build embed
    local embed = {
        title = "üéâ Congratulations! You hatched an ***INFINITY***! üéâ",
        description = description,
        color = embedColor,
        fields = fields,
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    -- Add thumbnail if pet image URL is available
    if petImageUrl then
        embed.thumbnail = {
            url = petImageUrl
        }
    end
    
    -- Add footer with eggs hatched count (small text at bottom)
    if eggsHatched then
        local formattedCount = eggsHatched
        if FormatCommas then
            formattedCount = FormatCommas(eggsHatched)
        else
            -- Manual formatting
            formattedCount = tostring(eggsHatched):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")
        end
        embed.footer = {
            text = "Eggs hatched: " .. formattedCount
        }
    end
    
    -- Build payload
    local payload = {
        content = mention, -- Ping in content field
        embeds = {embed}
    }
    
    local jsonPayload = jsonEncode(payload)
    
    local success, response, status = pcall(function()
        return httpLib(webhookURL, "POST", {
            ["Content-Type"] = "application/json"
        }, jsonPayload)
    end)
    
    if success and status == 200 then
        print("‚úì Special Discord notification sent successfully")
        return true
    elseif success and status == 429 then
        print("‚úó Special Discord notification rate limited (429)")
        return false -- Return false to trigger retry
    else
        print("‚úó Special Discord notification failed: status=" .. tostring(status))
        return true -- Return true for other errors to not retry
    end
end

-- Function to send webhook (with 429 retry logic) - MUST be defined first
local function sendDiscordNotificationInternal(petName, shiny, mythic, xl, eggName, rarity, pet, petImageUrl)
    if not httpLib or webhookURL == "" then 
        return true -- Return true to not retry if webhook not configured
    end
    
    -- Get player name
    local playerName = p.Name or "Unknown Player"
    
    -- Get total eggs hatched
    local eggsHatched = getTotalEggsHatched()
    
    -- Build pet name with prefix (XL goes AFTER shiny/mythic)
    local fullPetName = ""
    if shiny and mythic then
        fullPetName = "Shiny Mythic "
    elseif shiny then
        fullPetName = "Shiny "
    elseif mythic then
        fullPetName = "Mythic "
    end
    
    if xl then
        fullPetName = fullPetName .. "XL "
    end
    
    fullPetName = fullPetName .. petName
    
    -- Determine color
    local embedColor = getEmbedColor(shiny, mythic, xl, false)
    
    -- Build mention (for Discord ping)
    local mention = discordUserID ~= "" and ("<@" .. discordUserID .. ">") or ""
    
    -- Calculate probability if PetUtil is available
    local probabilityText = nil
    if PetUtil and pet then
        local success, petChance = pcall(function()
            return PetUtil:GetChance(pet)
        end)
        if success and petChance and petChance > 0 then
            local denominator = math.ceil(100 / petChance)
            if FormatCommas then
                probabilityText = "1/" .. FormatCommas(denominator)
            else
                -- Manual formatting for large numbers
                local formatted = tostring(denominator)
                -- Add commas every 3 digits from right
                formatted = formatted:reverse():gsub("(%d%d%d)", "%1,"):reverse()
                formatted = formatted:gsub("^,", "")
                probabilityText = "1/" .. formatted
            end
        end
    end
    
    -- Determine "a" or "an" for the pet name
    -- Use "a" if shiny/mythic/shiny mythic (regardless of vowel)
    -- Use "an" if pet name starts with a vowel AND is not shiny/mythic
    -- Use "a" if pet name starts with a consonant
    local article = "a"
    if not shiny and not mythic and petName then
        local firstLetter = string.lower(string.sub(petName, 1, 1))
        if firstLetter == "a" or firstLetter == "e" or firstLetter == "i" or firstLetter == "o" or firstLetter == "u" then
            article = "an"
        end
    end
    
    -- Build description
    local description = "**" .. playerName .. "** hatched " .. article .. " **" .. fullPetName .. "**!"
    
    -- Build fields (remove Egg, conditionally include Rarity/Probability)
    local fields = {
        {
            name = "Hatched",
            value = fullPetName,
            inline = false
        }
    }
    
    -- Add probability or rarity field
    if probabilityText then
        table.insert(fields, {
            name = "Rarity",
            value = probabilityText,
            inline = true
        })
    elseif rarity then
        table.insert(fields, {
            name = "Rarity",
            value = rarity,
            inline = true
        })
    end
    
    -- Build embed (always use full format, no simplification)
    local embed = {
        title = "üéâ Congratulations!",
        description = description,
        color = embedColor,
        fields = fields,
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    -- Add thumbnail if pet image URL is available
    if petImageUrl then
        embed.thumbnail = {
            url = petImageUrl
        }
    end
    
    -- Add footer with eggs hatched count (small text at bottom)
    if eggsHatched then
        local formattedCount = eggsHatched
        if FormatCommas then
            formattedCount = FormatCommas(eggsHatched)
        else
            -- Manual formatting
            formattedCount = tostring(eggsHatched):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")
        end
        embed.footer = {
            text = "Eggs hatched: " .. formattedCount
        }
    end
    
    -- Put mention in content field (required for Discord to actually ping)
    local payload = {
        content = mention ~= "" and mention or nil,
        embeds = {embed}
    }
    
    local headers = {["Content-Type"] = "application/json"}
    local json = jsonEncode(payload)
    local success, response, status = httpLib(webhookURL, "POST", headers, json)
    
    if success and (status == 200 or status == 204) then
        print("‚úì Discord notification sent! Status: " .. tostring(status))
        return true
    elseif status == 429 then
        -- Rate limited - return false to trigger retry
        print("‚úó Rate limited (429), will retry...")
        return false
    else
        print("‚úó Webhook failed!")
        print("  Status: " .. tostring(status))
        print("  Response: " .. tostring(response))
        -- For non-429 errors, return true to not retry (400 is likely permanent issue)
        return true
    end
end

-- Process webhook queue
local function processWebhookQueue()
    if isSendingWebhook or #webhookQueue == 0 or not scriptActive then
        return
    end
    
    isSendingWebhook = true
    
    spawn(function()
        while #webhookQueue > 0 and scriptActive do
            local webhookData = table.remove(webhookQueue, 1)
            
            -- Check message type
            if webhookData.isPlainText then
                -- Plain text message
                local maxRetries = 5
                local retryCount = 0
                local success = false
                
                while retryCount < maxRetries and not success do
                    success = sendPlainTextWebhook(webhookData.message, webhookData.shouldPing or false)
                    
                    if not success then
                        retryCount = retryCount + 1
                        if retryCount < maxRetries then
                            task.wait(1)
                        end
                    end
                end
                
                if not success then
                    table.insert(webhookQueue, 1, webhookData)
                    messagesRemainingWithDelay = 5
                end
            elseif webhookData.isDebug and webhookData.debugMessage then
                -- Debug webhook
                local maxRetries = 5
                local retryCount = 0
                local success = false
                
                while retryCount < maxRetries and not success do
                    success = sendDebugWebhook(webhookData.debugMessage)
                    
                    if not success then
                        retryCount = retryCount + 1
                        if retryCount < maxRetries then
                            task.wait(1)
                        end
                    end
                end
                
                if not success then
                    table.insert(webhookQueue, 1, webhookData)
                    messagesRemainingWithDelay = 5
                end
            else
                -- Regular or special notification
                local petName = webhookData.petName
                local shiny = webhookData.shiny
                local mythic = webhookData.mythic
                local xl = webhookData.xl
                local eggName = webhookData.eggName
                local rarity = webhookData.rarity
                local pet = webhookData.pet
                local petImageUrl = webhookData.petImageUrl
                local isSpecial = webhookData.isSpecial == true
                local isInfinity = webhookData.isInfinity == true
                
                local maxRetries = 5
                local retryCount = 0
                local success = false
                
                while retryCount < maxRetries and not success do
                    if isSpecial then
                        success = sendSpecialDiscordNotificationInternal(petName, shiny, mythic, xl, eggName, rarity, pet, petImageUrl, isInfinity)
                    else
                        success = sendDiscordNotificationInternal(petName, shiny, mythic, xl, eggName, rarity, pet, petImageUrl)
                    end
                    
                    if not success then
                        retryCount = retryCount + 1
                        if retryCount < maxRetries then
                            task.wait(1)
                        end
                    end
                end
                
                if not success then
                    table.insert(webhookQueue, 1, webhookData)
                    messagesRemainingWithDelay = 5
                end
            end
            
            -- Determine delay based on rate limit counter
            local delay = (messagesRemainingWithDelay > 0) and 2 or 1
            if messagesRemainingWithDelay > 0 then
                messagesRemainingWithDelay = messagesRemainingWithDelay - 1
            end
            
            -- Wait before sending next message in queue
            if #webhookQueue > 0 then
                task.wait(delay)
            end
        end
        
        isSendingWebhook = false
    end)
end

-- Public function to queue webhook (handles rate limiting)
local function sendDiscordNotification(petName, shiny, mythic, xl, eggName, rarity, pet)
    -- Don't process if script is closed
    if not scriptActive then
        return
    end
    
    if webhookURL == "" then
        print("‚úó Webhook URL not set")
        return
    end
    
    if not httpLib then
        print("‚úó HTTP library not available")
        return
    end
    
    -- Get pet image URL
    local petImageUrl = nil
    if PetsData and petName then
        local success, petData = pcall(function()
            return PetsData[petName]
        end)
        
        if success and petData and petData.Images then
            -- Determine image type based on shiny/mythic/xl status
            local imageType = "Normal"
            if shiny and mythic and xl then
                imageType = "MythicShinyXL" -- Try combinations
            elseif shiny and mythic then
                imageType = "MythicShiny"
            elseif mythic and xl then
                imageType = "MythicXL"
            elseif shiny and xl then
                imageType = "ShinyXL"
            elseif shiny then
                imageType = "Shiny"
            elseif mythic then
                imageType = "Mythic"
            elseif xl then
                imageType = "XL"
            end
            
            -- Get the image asset ID with cascading fallbacks
            local petImageAsset = petData.Images[imageType]
            
            -- If exact combination not found, try simpler versions
            if not petImageAsset then
                if shiny and mythic then
                    petImageAsset = petData.Images["MythicShiny"]
                elseif shiny then
                    petImageAsset = petData.Images["Shiny"]
                elseif mythic then
                    petImageAsset = petData.Images["Mythic"]
                end
            end
            
            -- Final fallback to Normal
            petImageAsset = petImageAsset or petData.Images["Normal"]
            
            if petImageAsset then
                -- Extract asset ID from rbxassetid:// format
                local assetId = petImageAsset:match("rbxassetid://(%d+)")
                
                if assetId then
                    -- Convert to Discord-compatible thumbnail URL
                    petImageUrl = getThumbnailUrl(assetId)
                end
            end
        end
    end
    
    -- Check if this is a special pet
    local isSpecial = isSpecialPet(petName)
    local isInfinity = isInfinityRarity(rarity)
    
    -- If special pet, send special notification and debug message
    if isSpecial then
        -- Add special notification to queue
        table.insert(webhookQueue, {
            petName = petName,
            shiny = shiny,
            mythic = mythic,
            xl = xl,
            eggName = eggName,
            rarity = rarity,
            pet = pet,
            petImageUrl = petImageUrl,
            isSpecial = true,
            isInfinity = isInfinity
        })
        
        -- Add debug message to queue (separate message, no ping)
        local debugMessage = isInfinity and 
            "The rarity of this pet is specified as Infinity" or 
            ("The rarity is not infinity. Rarity: " .. (rarity or "Unknown"))
        table.insert(webhookQueue, {
            debugMessage = debugMessage,
            isDebug = true
        })
    else
        -- Add regular notification to queue
        table.insert(webhookQueue, {
            petName = petName,
            shiny = shiny,
            mythic = mythic,
            xl = xl,
            eggName = eggName,
            rarity = rarity,
            pet = pet,
            petImageUrl = petImageUrl,
            isSpecial = false
        })
    end
    
    -- Start processing queue if not already processing
    processWebhookQueue()
end

-- Connect to HatchEgg event
local function connectToEvents()
    if not Remote then
        print("‚úó Remote module not loaded!")
        return false
    end
    
    if not ItemUtil then
        print("‚úó ItemUtil not loaded!")
        return false
    end
    
    local success, err = pcall(function()
        hatchEventConnection = Remote.Event("HatchEgg"):Connect(function(hatchedTable)
            -- Wrap entire handler in pcall to prevent errors from breaking the connection
            pcall(function()
                -- Don't process if script is closed
                if not scriptActive then
                    return
                end
                
                if type(hatchedTable) == "table" and hatchedTable.Pets then
                    local eggName = hatchedTable.Name
                    
                    for i = 1, 20 do
                        local petData = hatchedTable.Pets[i]
                        if not petData then break end
                        
                        if type(petData) == "table" and petData.Pet then
                            local pet = petData.Pet
                            local petName = pet.Name
                            local shiny = pet.Shiny == true
                            local mythic = pet.Mythic == true
                            
                            -- XL detection with multiple fallback methods (format uncertain)
                            local xl = false
                            if pet.XL == true then
                                xl = true -- Check uppercase XL (most likely)
                            elseif pet.xl == true then
                                xl = true -- Check lowercase xl
                            elseif pet.Xl == true then
                                xl = true -- Check mixed case Xl
                            elseif type(pet.XL) == "number" and pet.XL > 0 then
                                xl = true -- Check if XL is a number value
                            elseif petName and string.find(string.upper(petName), "XL") then
                                xl = true -- Check if "XL" is in the pet name
                            end
                            
                            if petName and ItemUtil then
                                local rarity = ItemUtil:GetRarity(pet)
                                
                                -- Check if this is a special pet (regardless of rarity)
                                local isSpecial = isSpecialPet(petName)
                                
                                -- Check if Secret
                                local isSecret = rarity == "Secret"
                                
                                -- Check if Legendary (only if toggle is enabled)
                                local isLegendary = false
                                if legendaryDetectionEnabled then
                                    isLegendary = (rarity == "Legendary")
                                end
                                
                                -- Send notification if:
                                -- 1. It's a Secret pet, OR
                                -- 2. It's a Legendary pet (only if DETECT_LEGENDARIES is true), OR
                                -- 3. It's a special pet (regardless of rarity)
                                if isSecret or isLegendary or isSpecial then
                                    if isSecret then
                                        print(">>> SECRET DETECTED! <<<")
                                    elseif isLegendary then
                                        print(">>> LEGENDARY DETECTED! <<<")
                                    elseif isSpecial then
                                        print(">>> SPECIAL PET DETECTED! <<<")
                                    end
                                    
                                    -- Send webhook with XL parameter
                                    sendDiscordNotification(petName, shiny, mythic, xl, eggName, rarity, pet)
                                end
                            end
                        end
                    end
                end
            end)
        end)
    end)
    
    if success then
        print("‚úì Connected to HatchEgg events")
        return true
    else
        print("‚úó Failed to connect: " .. tostring(err))
        return false
    end
end

-- Chat monitoring for "Feeling jolly" (Christmas Chest Rifts)
local function setupChatMonitoring()
    -- Try TextChatService (new chat system)
    local success1 = pcall(function()
        if TextChatService and TextChatService.MessageReceived then
            TextChatService.MessageReceived:Connect(function(message)
                if not scriptActive or not riftDetectionEnabled then return end
                
                local text = message.Text or ""
                if string.find(string.lower(text), "feeling jolly") then
                    print(">>> CHRISTMAS CHEST RIFT DETECTED! <<<")
                    table.insert(webhookQueue, {
                        message = "A Christmas Chest Rift has spawned!",
                        isPlainText = true,
                        shouldPing = true
                    })
                    processWebhookQueue()
                end
            end)
            print("‚úì Chat monitoring active (TextChatService)")
        end
    end)
    
    -- Try legacy chat system
    local success2 = pcall(function()
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        if player and player:WaitForChild("PlayerGui"):FindFirstChild("Chat") then
            local chat = player.PlayerGui.Chat
            
            -- Helper function to monitor chat element
            local function monitorChatElement(child)
                if child:IsA("TextLabel") or child:IsA("TextBox") then
                    child:GetPropertyChangedSignal("Text"):Connect(function()
                        if not scriptActive or not riftDetectionEnabled then return end
                        
                        local text = child.Text or ""
                        if string.find(string.lower(text), "feeling jolly") then
                            print(">>> CHRISTMAS CHEST RIFT DETECTED! <<<")
                            table.insert(webhookQueue, {
                                message = "A Christmas Chest Rift has spawned!",
                                isPlainText = true,
                                shouldPing = true
                            })
                            processWebhookQueue()
                        end
                    end)
                end
            end
            
            -- Monitor existing chat elements
            for _, child in pairs(chat:GetDescendants()) do
                monitorChatElement(child)
            end
            
            -- Monitor new chat elements as they're added
            chat.DescendantAdded:Connect(function(child)
                monitorChatElement(child)
            end)
            
            print("‚úì Chat monitoring active (Legacy Chat)")
        end
    end)
    
    if not success1 and not success2 then
        print("‚ö† Chat monitoring not available")
    end
end

-- Hourly status messages (sends at top of each hour)
local function startHourlyStatusMessages()
    spawn(function()
        while scriptActive do
            if hourlyStatusEnabled and webhookURL ~= "" then
                -- Recalculate time until next hour each iteration
                local currentTime = os.date("*t")
                local minutesUntilNextHour = 60 - currentTime.min
                local secondsUntilNextHour = (minutesUntilNextHour * 60) - currentTime.sec
                
                -- Wait until top of the hour
                task.wait(secondsUntilNextHour)
                
                -- Double-check conditions after waiting
                if hourlyStatusEnabled and scriptActive and webhookURL ~= "" then
                    local runtime = os.time() - scriptStartTime
                    local hours = math.floor(runtime / 3600)
                    local minutes = math.floor((runtime % 3600) / 60)
                    
                    local runtimeText = string.format("%dh %dm", hours, minutes)
                    local message = string.format("%s is still in the server. Runtime: %s", p.Name, runtimeText)
                    
                    table.insert(webhookQueue, {
                        message = message,
                        isPlainText = true,
                        shouldPing = false
                    })
                    processWebhookQueue()
                end
                -- Loop continues and recalculates time for next hour
            else
                task.wait(60) -- Check every minute if disabled
            end
        end
    end)
end

-- Player join/leave tracking
local function setupPlayerTracking()
    P.PlayerAdded:Connect(function(player)
        if not scriptActive or not playerTrackingEnabled or webhookURL == "" then return end
        
        table.insert(webhookQueue, {
            message = string.format("%s joined the server", player.Name),
            isPlainText = true,
            shouldPing = false
        })
        processWebhookQueue()
    end)
    
    P.PlayerRemoving:Connect(function(player)
        if not scriptActive or not playerTrackingEnabled or webhookURL == "" then return end
        
        table.insert(webhookQueue, {
            message = string.format("%s left the server", player.Name),
            isPlainText = true,
            shouldPing = false
        })
        processWebhookQueue()
    end)
    
    print("‚úì Player tracking setup complete")
end

-- Connect after modules load
task.wait(1)
connectToEvents()
setupChatMonitoring()
setupPlayerTracking()
startHourlyStatusMessages()

-- GUI with tab system
local g = Instance.new("ScreenGui")
g.Name = "BubblegumAutoHatch"
g.ResetOnSpawn = false
g.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
g.Parent = p.PlayerGui

-- Main frame (slightly wider for tab system)
local f = Instance.new("Frame")
f.Size = UDim2.new(0, 450, 0, 240)
f.Position = UDim2.new(0.5, -225, 0.5, -120)
f.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
f.BorderSizePixel = 0
f.Parent = g

-- Tab container (left side)
local tabContainer = Instance.new("Frame")
tabContainer.Size = UDim2.new(0, 90, 1, 0)
tabContainer.Position = UDim2.new(0, 0, 0, 0)
tabContainer.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
tabContainer.BorderSizePixel = 0
tabContainer.Parent = f

-- Content container (right side)
local contentContainer = Instance.new("Frame")
contentContainer.Size = UDim2.new(0, 360, 1, 0)
contentContainer.Position = UDim2.new(0, 90, 0, 0)
contentContainer.BackgroundTransparency = 1
contentContainer.BorderSizePixel = 0
contentContainer.Parent = f

-- Hatching tab button
local hatchingTab = Instance.new("TextButton")
hatchingTab.Size = UDim2.new(1, 0, 0, 50)
hatchingTab.Position = UDim2.new(0, 0, 0, 0)
hatchingTab.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
hatchingTab.Text = "Hatching"
hatchingTab.TextColor3 = Color3.fromRGB(255, 255, 255)
hatchingTab.TextSize = 14
hatchingTab.Font = Enum.Font.GothamBold
hatchingTab.BorderSizePixel = 0
hatchingTab.Parent = tabContainer

-- Extra tab button
local extraTab = Instance.new("TextButton")
extraTab.Size = UDim2.new(1, 0, 0, 50)
extraTab.Position = UDim2.new(0, 0, 0, 50)
extraTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
extraTab.Text = "Extra"
extraTab.TextColor3 = Color3.fromRGB(255, 255, 255)
extraTab.TextSize = 14
extraTab.Font = Enum.Font.GothamBold
extraTab.BorderSizePixel = 0
extraTab.Parent = tabContainer

-- Hatching content frame
local hatchingContent = Instance.new("Frame")
hatchingContent.Size = UDim2.new(1, 0, 1, 0)
hatchingContent.BackgroundTransparency = 1
hatchingContent.Visible = true
hatchingContent.Parent = contentContainer

-- Extra content frame
local extraContent = Instance.new("Frame")
extraContent.Size = UDim2.new(1, 0, 1, 0)
extraContent.BackgroundTransparency = 1
extraContent.Visible = false
extraContent.Parent = contentContainer

-- Title bar (in hatching content)
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 40)
title.Position = UDim2.new(0, 0, 0, 0)
title.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
title.Text = "Auto Hatch & Notifier"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextSize = 16
title.Font = Enum.Font.GothamBold
title.BorderSizePixel = 0
title.Parent = hatchingContent

-- Auto Hatch button
local autoHatchBtn = Instance.new("TextButton")
autoHatchBtn.Size = UDim2.new(0, 330, 0, 45)
autoHatchBtn.Position = UDim2.new(0, 15, 0, 55)
autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
autoHatchBtn.Text = "Auto Hatch: OFF"
autoHatchBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
autoHatchBtn.TextSize = 14
autoHatchBtn.Font = Enum.Font.GothamBold
autoHatchBtn.BorderSizePixel = 0
autoHatchBtn.Parent = hatchingContent

-- Webhook URL label
local webhookLabel = Instance.new("TextLabel")
webhookLabel.Size = UDim2.new(0, 330, 0, 20)
webhookLabel.Position = UDim2.new(0, 15, 0, 110)
webhookLabel.BackgroundTransparency = 1
webhookLabel.Text = "Discord Webhook URL:"
webhookLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
webhookLabel.TextSize = 11
webhookLabel.Font = Enum.Font.Gotham
webhookLabel.TextXAlignment = Enum.TextXAlignment.Left
webhookLabel.Parent = hatchingContent

-- Webhook URL input
local webhookInput = Instance.new("TextBox")
webhookInput.Size = UDim2.new(0, 330, 0, 30)
webhookInput.Position = UDim2.new(0, 15, 0, 130)
webhookInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
webhookInput.TextColor3 = Color3.fromRGB(255, 255, 255)
webhookInput.Text = webhookURL or ""
webhookInput.PlaceholderText = "https://discord.com/api/webhooks/..."
webhookInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
webhookInput.TextSize = 10
webhookInput.Font = Enum.Font.Gotham
webhookInput.BorderSizePixel = 0
webhookInput.TextTruncate = Enum.TextTruncate.AtEnd
webhookInput.Parent = hatchingContent

-- Discord User ID label
local userIDLabel = Instance.new("TextLabel")
userIDLabel.Size = UDim2.new(0, 330, 0, 20)
userIDLabel.Position = UDim2.new(0, 15, 0, 170)
userIDLabel.BackgroundTransparency = 1
userIDLabel.Text = "Discord User ID (optional):"
userIDLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
userIDLabel.TextSize = 11
userIDLabel.Font = Enum.Font.Gotham
userIDLabel.TextXAlignment = Enum.TextXAlignment.Left
userIDLabel.Parent = hatchingContent

-- Discord User ID input
local userIDInput = Instance.new("TextBox")
userIDInput.Size = UDim2.new(0, 330, 0, 30)
userIDInput.Position = UDim2.new(0, 15, 0, 190)
userIDInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
userIDInput.TextColor3 = Color3.fromRGB(255, 255, 255)
userIDInput.Text = discordUserID or ""
userIDInput.PlaceholderText = "123456789012345678"
userIDInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
userIDInput.TextSize = 11
userIDInput.Font = Enum.Font.Gotham
userIDInput.BorderSizePixel = 0
userIDInput.Parent = hatchingContent

-- X button on main GUI (top right of frame) - hides GUI
local hideXBtn = Instance.new("TextButton")
hideXBtn.Size = UDim2.new(0, 30, 0, 30)
hideXBtn.Position = UDim2.new(1, -35, 0, 5)
hideXBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
hideXBtn.Text = "X"
hideXBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
hideXBtn.TextSize = 18
hideXBtn.Font = Enum.Font.GothamBold
hideXBtn.BorderSizePixel = 0
hideXBtn.ZIndex = 2
hideXBtn.Parent = f

-- Toggle button (top right of screen - always visible)
local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0, 50, 0, 50)
toggleBtn.Position = UDim2.new(1, -60, 0, 10)
toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
toggleBtn.Text = "GUI"
toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleBtn.TextSize = 12
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.BorderSizePixel = 0
toggleBtn.Parent = g

-- Extra content title bar
local extraTitle = Instance.new("TextLabel")
extraTitle.Size = UDim2.new(1, 0, 0, 40)
extraTitle.Position = UDim2.new(0, 0, 0, 0)
extraTitle.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
extraTitle.Text = "Extra Features"
extraTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
extraTitle.TextSize = 16
extraTitle.Font = Enum.Font.GothamBold
extraTitle.BorderSizePixel = 0
extraTitle.Parent = extraContent

-- 2x2 Button grid in Extra tab
-- Row 1: Rift Detection (left) and Hourly Status (right)
-- Row 2: Player Tracking (left) and Close Script (right)

-- Row 1: Rift Detection (left) and Hourly Status (right)
-- Rift detection button (top-left)
local riftBtn = Instance.new("TextButton")
riftBtn.Size = UDim2.new(0, 155, 0, 28)
riftBtn.Position = UDim2.new(0, 15, 0, 50)
riftBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
riftBtn.Text = "Rift Detection: OFF"
riftBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
riftBtn.TextSize = 11
riftBtn.Font = Enum.Font.GothamBold
riftBtn.BorderSizePixel = 0
riftBtn.Parent = extraContent

local riftDesc = Instance.new("TextLabel")
riftDesc.Size = UDim2.new(0, 155, 0, 22)
riftDesc.Position = UDim2.new(0, 15, 0, 82)
riftDesc.BackgroundTransparency = 1
riftDesc.Text = "Detects Christmas Chest Rifts and pings you"
riftDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
riftDesc.TextSize = 8
riftDesc.Font = Enum.Font.Gotham
riftDesc.TextXAlignment = Enum.TextXAlignment.Left
riftDesc.TextYAlignment = Enum.TextYAlignment.Top
riftDesc.TextWrapped = true
riftDesc.Parent = extraContent

-- Hourly status button (top-right)
local hourlyBtn = Instance.new("TextButton")
hourlyBtn.Size = UDim2.new(0, 155, 0, 28)
hourlyBtn.Position = UDim2.new(0, 180, 0, 50)
hourlyBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
hourlyBtn.Text = "Hourly Status: ON"
hourlyBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
hourlyBtn.TextSize = 11
hourlyBtn.Font = Enum.Font.GothamBold
hourlyBtn.BorderSizePixel = 0
hourlyBtn.Parent = extraContent

local hourlyDesc = Instance.new("TextLabel")
hourlyDesc.Size = UDim2.new(0, 155, 0, 22)
hourlyDesc.Position = UDim2.new(0, 180, 0, 82)
hourlyDesc.BackgroundTransparency = 1
hourlyDesc.Text = "Sends status every hour with runtime (no ping)"
hourlyDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
hourlyDesc.TextSize = 8
hourlyDesc.Font = Enum.Font.Gotham
hourlyDesc.TextXAlignment = Enum.TextXAlignment.Left
hourlyDesc.TextYAlignment = Enum.TextYAlignment.Top
hourlyDesc.TextWrapped = true
hourlyDesc.Parent = extraContent

-- Row 2: Player Tracking (left) and Legendary Detection (right)
-- Player tracking button (middle-left)
local playerBtn = Instance.new("TextButton")
playerBtn.Size = UDim2.new(0, 155, 0, 28)
playerBtn.Position = UDim2.new(0, 15, 0, 110)
playerBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
playerBtn.Text = "Player Track: ON"
playerBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
playerBtn.TextSize = 11
playerBtn.Font = Enum.Font.GothamBold
playerBtn.BorderSizePixel = 0
playerBtn.Parent = extraContent

local playerDesc = Instance.new("TextLabel")
playerDesc.Size = UDim2.new(0, 155, 0, 22)
playerDesc.Position = UDim2.new(0, 15, 0, 142)
playerDesc.BackgroundTransparency = 1
playerDesc.Text = "Notifies when players join or leave (no ping)"
playerDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
playerDesc.TextSize = 8
playerDesc.Font = Enum.Font.Gotham
playerDesc.TextXAlignment = Enum.TextXAlignment.Left
playerDesc.TextYAlignment = Enum.TextYAlignment.Top
playerDesc.TextWrapped = true
playerDesc.Parent = extraContent

-- Legendary Detection button (middle-right)
local legendaryBtn = Instance.new("TextButton")
legendaryBtn.Size = UDim2.new(0, 155, 0, 28)
legendaryBtn.Position = UDim2.new(0, 180, 0, 110)
legendaryBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60) -- Start as OFF (default)
legendaryBtn.Text = "Legendary Detection: OFF"
legendaryBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
legendaryBtn.TextSize = 10
legendaryBtn.Font = Enum.Font.GothamBold
legendaryBtn.BorderSizePixel = 0
legendaryBtn.Parent = extraContent

local legendaryDesc = Instance.new("TextLabel")
legendaryDesc.Size = UDim2.new(0, 155, 0, 22)
legendaryDesc.Position = UDim2.new(0, 180, 0, 142)
legendaryDesc.BackgroundTransparency = 1
legendaryDesc.Text = "Toggle legendary detection (testing)"
legendaryDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
legendaryDesc.TextSize = 8
legendaryDesc.Font = Enum.Font.Gotham
legendaryDesc.TextXAlignment = Enum.TextXAlignment.Left
legendaryDesc.TextYAlignment = Enum.TextYAlignment.Top
legendaryDesc.TextWrapped = true
legendaryDesc.Parent = extraContent

-- Close Script button (bottom, full width)
local closeScriptBtn = Instance.new("TextButton")
closeScriptBtn.Size = UDim2.new(0, 320, 0, 28)
closeScriptBtn.Position = UDim2.new(0, 15, 0, 170)
closeScriptBtn.BackgroundColor3 = Color3.fromRGB(80, 40, 40)
closeScriptBtn.Text = "Close Script"
closeScriptBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeScriptBtn.TextSize = 11
closeScriptBtn.Font = Enum.Font.GothamBold
closeScriptBtn.BorderSizePixel = 0
closeScriptBtn.Parent = extraContent

local closeScriptDesc = Instance.new("TextLabel")
closeScriptDesc.Size = UDim2.new(0, 320, 0, 22)
closeScriptDesc.Position = UDim2.new(0, 15, 0, 202)
closeScriptDesc.BackgroundTransparency = 1
closeScriptDesc.Text = "Stop all script functionality"
closeScriptDesc.TextColor3 = Color3.fromRGB(180, 180, 180)
closeScriptDesc.TextSize = 8
closeScriptDesc.Font = Enum.Font.Gotham
closeScriptDesc.TextXAlignment = Enum.TextXAlignment.Left
closeScriptDesc.TextYAlignment = Enum.TextYAlignment.Top
closeScriptDesc.TextWrapped = true
closeScriptDesc.Parent = extraContent

-- Confirmation dialog
local confirmFrame = Instance.new("Frame")
confirmFrame.Size = UDim2.new(0, 300, 0, 150)
confirmFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
confirmFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
confirmFrame.BorderSizePixel = 2
confirmFrame.BorderColor3 = Color3.fromRGB(200, 50, 50)
confirmFrame.Visible = false
confirmFrame.ZIndex = 10
confirmFrame.Parent = g

local confirmTitle = Instance.new("TextLabel")
confirmTitle.Size = UDim2.new(1, 0, 0, 40)
confirmTitle.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
confirmTitle.Text = "Close Script?"
confirmTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmTitle.TextSize = 16
confirmTitle.Font = Enum.Font.GothamBold
confirmTitle.BorderSizePixel = 0
confirmTitle.ZIndex = 11
confirmTitle.Parent = confirmFrame

local confirmText = Instance.new("TextLabel")
confirmText.Size = UDim2.new(0, 280, 0, 50)
confirmText.Position = UDim2.new(0, 10, 0, 45)
confirmText.BackgroundTransparency = 1
confirmText.Text = "Are you sure you want to close the script?\nAll functionality will stop."
confirmText.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmText.TextSize = 12
confirmText.Font = Enum.Font.Gotham
confirmText.TextWrapped = true
confirmText.ZIndex = 11
confirmText.Parent = confirmFrame

local yesBtn = Instance.new("TextButton")
yesBtn.Size = UDim2.new(0, 120, 0, 35)
yesBtn.Position = UDim2.new(0, 20, 1, -50)
yesBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
yesBtn.Text = "Yes, Close"
yesBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
yesBtn.TextSize = 12
yesBtn.Font = Enum.Font.GothamBold
yesBtn.BorderSizePixel = 0
yesBtn.ZIndex = 11
yesBtn.Parent = confirmFrame

local noBtn = Instance.new("TextButton")
noBtn.Size = UDim2.new(0, 120, 0, 35)
noBtn.Position = UDim2.new(1, -140, 1, -50)
noBtn.BackgroundColor3 = Color3.fromRGB(80, 140, 80)
noBtn.Text = "No, Cancel"
noBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
noBtn.TextSize = 12
noBtn.Font = Enum.Font.GothamBold
noBtn.BorderSizePixel = 0
noBtn.ZIndex = 11
noBtn.Parent = confirmFrame

-- Tab switching logic
hatchingTab.Activated:Connect(function()
    hatchingContent.Visible = true
    extraContent.Visible = false
    hatchingTab.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
    extraTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
end)

extraTab.Activated:Connect(function()
    hatchingContent.Visible = false
    extraContent.Visible = true
    hatchingTab.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    extraTab.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
end)

-- Auto Hatch functionality (changed to 0.4s intervals)
autoHatchBtn.Activated:Connect(function()
    if not scriptActive then
        return
    end
    
    autoHatchEnabled = not autoHatchEnabled
    
    if autoHatchEnabled then
        autoHatchBtn.Text = "Auto Hatch: ON"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
        
        -- Start E key spam (0.4s intervals)
        spawn(function()
            while autoHatchEnabled and scriptActive do
                VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                task.wait(0.05)
                VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                task.wait(0.35) -- 0.05 + 0.35 = 0.4s total
            end
        end)
    else
        autoHatchBtn.Text = "Auto Hatch: OFF"
        autoHatchBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
end)

-- Rift detection toggle
riftBtn.Activated:Connect(function()
    if not scriptActive then return end
    
    riftDetectionEnabled = not riftDetectionEnabled
    
    if riftDetectionEnabled then
        riftBtn.Text = "Rift Detection: ON"
        riftBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        riftBtn.Text = "Rift Detection: OFF"
        riftBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
end)

-- Hourly status toggle
hourlyBtn.Activated:Connect(function()
    if not scriptActive then return end
    
    hourlyStatusEnabled = not hourlyStatusEnabled
    
    if hourlyStatusEnabled then
        hourlyBtn.Text = "Hourly Status: ON"
        hourlyBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        hourlyBtn.Text = "Hourly Status: OFF"
        hourlyBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
end)

-- Player tracking toggle
playerBtn.Activated:Connect(function()
    if not scriptActive then return end
    
    playerTrackingEnabled = not playerTrackingEnabled
    
    if playerTrackingEnabled then
        playerBtn.Text = "Player Track: ON"
        playerBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        playerBtn.Text = "Player Track: OFF"
        playerBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
end)

-- Close Script button - opens confirmation dialog
closeScriptBtn.Activated:Connect(function()
    confirmFrame.Visible = true
end)

-- Legendary Detection toggle
legendaryBtn.Activated:Connect(function()
    if not scriptActive then return end
    
    legendaryDetectionEnabled = not legendaryDetectionEnabled
    
    if legendaryDetectionEnabled then
        legendaryBtn.Text = "Legendary Detection: ON"
        legendaryBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
    else
        legendaryBtn.Text = "Legendary Detection: OFF"
        legendaryBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    end
end)

-- Hide X button - hides main GUI
hideXBtn.Activated:Connect(function()
    f.Visible = false
    toggleBtn.Text = ">>>"
    toggleBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
end)

-- Toggle button - shows/hides main GUI
toggleBtn.Activated:Connect(function()
    f.Visible = not f.Visible
    if f.Visible then
        toggleBtn.Text = "GUI"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
    else
        toggleBtn.Text = ">>>"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    end
end)

-- Webhook URL input handler
webhookInput.FocusLost:Connect(function(enterPressed)
    local url = webhookInput.Text:gsub("^%s*(.-)%s*$", "%1")
    webhookURL = url
    print("Webhook URL saved: " .. (url ~= "" and "SET (" .. string.sub(url, 1, 50) .. "...)" or "EMPTY"))
    saveSettings()
end)

-- Discord User ID input handler
userIDInput.FocusLost:Connect(function(enterPressed)
    local id = userIDInput.Text:gsub("^%s*(.-)%s*$", "%1")
    discordUserID = id
    print("Discord User ID saved: " .. (id ~= "" and id or "EMPTY"))
    saveSettings()
end)

-- Yes button - closes everything
yesBtn.Activated:Connect(function()
    print("Closing script...")
    
    -- Mark script as inactive
    scriptActive = false
    
    -- Stop auto hatch
    autoHatchEnabled = false
    
    -- Disconnect event connection
    if hatchEventConnection then
        hatchEventConnection:Disconnect()
        hatchEventConnection = nil
        print("‚úì Event connection disconnected")
    end
    
    -- Clear webhook queue
    webhookQueue = {}
    isSendingWebhook = false
    print("‚úì Webhook queue cleared")
    
    -- Destroy GUI
    g:Destroy()
    print("‚úì GUI destroyed")
    
    print("Script closed by user - all functionality stopped")
    error("Script closed")
end)

-- No button - closes confirmation dialog
noBtn.Activated:Connect(function()
    confirmFrame.Visible = false
end)

print("‚úì GUI created")
print("Ready! Click 'Auto Hatch' to start hatching")

-- Monitor GUI to detect if it gets destroyed unexpectedly
g.AncestryChanged:Connect(function(child, parent)
    if not parent and scriptActive then
        warn("WARNING: GUI was destroyed or removed!")
    end
end)
